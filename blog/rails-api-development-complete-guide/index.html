<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/19bdf9af4d1ae4d4.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-aa7deb192a774533.js"/><script src="/_next/static/chunks/4bd1b696-bc089769d60af88b.js" async=""></script><script src="/_next/static/chunks/1684-b369840b16e4c44b.js" async=""></script><script src="/_next/static/chunks/main-app-2ed07751e45c2a2f.js" async=""></script><script src="/_next/static/chunks/6874-6c1ddde525f3893c.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js" async=""></script><meta name="next-size-adjust" content=""/><link rel="icon" href="/favicon.png" type="image/png"/><title>Maita Tomoya Dev IO</title><meta name="description" content="ç±³ç”°æ™ºå“‰ã®æŠ€è¡“ãƒ–ãƒ­ã‚°ã€‚ã‚­ãƒ£ãƒƒãƒã‚¢ãƒƒãƒ—ã—ãŸã“ã¨ã‚’ãƒ¡ãƒ¢ã—ã¾ã™ã€‚"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 antialiased"><div class="max-w-2xl mx-auto py-10 px-4"><h1 class="text-3xl font-bold mb-2"><span class="text-green-600">#<!-- -->41</span> <!-- -->Ruby on Rails APIé–‹ç™ºå®Œå…¨ã‚¬ã‚¤ãƒ‰ - RESTfulè¨­è¨ˆã‹ã‚‰GraphQLã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¾ã§</h1><ul class="list-none border-b border-gray-600 pb-4 mb-6"><li class="text-gray-500 text-sm">ä½œæˆæ—¥æ™‚: <!-- -->2025-08-25 01:04</li><li class="text-gray-500 text-sm">æ›´æ–°æ—¥æ™‚: <!-- -->2025-08-25 01:04</li><li class="flex flex-wrap gap-2 mt-2"><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">Ruby on Rails</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">API</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">REST</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">GraphQL</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">JWT</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">RSpec</span></li></ul><nav class="mb-6 pb-4 border-b border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">â† ãƒ›ãƒ¼ãƒ ã¸</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">è¨˜äº‹ä¸€è¦§ã¸ â†’</a></nav><article class="prose dark:prose-invert"><p>Ruby on Railsé–‹ç™ºçµŒé¨“3å¹´ä»¥ä¸Šã‚’æ±‚ã‚ã‚‹æ±‚äººã§ã€ŒAPIé–‹ç™ºçµŒé¨“ã€ã¯å¿…é ˆè¦ä»¶ã§ã™ã€‚ã—ã‹ã—ã€å˜ã«ã€ŒRails APIãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ãˆã‚‹ã€ã ã‘ã§ã¯ä¸ååˆ†ã§ã™ã€‚æœ¬è¨˜äº‹ã§ã¯ã€RESTful APIè¨­è¨ˆã®åŸå‰‡ã‹ã‚‰ã€èªè¨¼ãƒ»èªå¯ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€GraphQLå®Ÿè£…ã¾ã§ã€å®Ÿå‹™ã§å¿…è¦ãªçŸ¥è­˜ã‚’ç¶²ç¾…çš„ã«è§£èª¬ã—ã¾ã™ã€‚</p>
<h2 id="-åˆå¿ƒè€…å‘ã‘è§£èª¬">ğŸ’¡ åˆå¿ƒè€…å‘ã‘è§£èª¬</h2>
<h3 id="apiã¨ã¯">APIã¨ã¯ï¼Ÿ</h3>
<p><strong>ç°¡å˜ã«è¨€ã†ã¨</strong>: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åŒå£«ãŒä¼šè©±ã™ã‚‹ãŸã‚ã®çª“å£ã§ã™ã€‚</p>
<pre><code>ä¾‹ï¼šãƒ¬ã‚¹ãƒˆãƒ©ãƒ³ã®æ³¨æ–‡ã‚·ã‚¹ãƒ†ãƒ 
Webã‚µã‚¤ãƒˆ/ã‚¢ãƒ—ãƒªï¼šãŠå®¢æ§˜ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼‰
APIï¼šã‚¦ã‚§ã‚¤ã‚¿ãƒ¼ï¼ˆé€šä¿¡ã®ä»²ä»‹ï¼‰
Railsï¼šå¨æˆ¿ï¼ˆãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼‰
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼šé£Ÿæåº«
</code></pre>
<h3 id="ãªãœrails-apiãŒé¸ã°ã‚Œã‚‹ã®ã‹">ãªãœRails APIãŒé¸ã°ã‚Œã‚‹ã®ã‹ï¼Ÿ</h3>
<ul>
<li><strong>é–‹ç™ºé€Ÿåº¦</strong>: è¦ç´„é‡è¦–ã§é«˜é€Ÿé–‹ç™ºãŒå¯èƒ½</li>
<li><strong>æˆç†Ÿåº¦</strong>: è±Šå¯ŒãªGemã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ </li>
<li><strong>ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£</strong>: å¤§è¦æ¨¡ã‚µãƒ¼ãƒ“ã‚¹ã§ã®å®Ÿç¸¾</li>
<li><strong>ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§</strong>: Railsã®è¦ç´„ã«ã‚ˆã‚‹çµ±ä¸€æ€§</li>
</ul>
<h2 id="-ç›®æ¬¡">ğŸ“š ç›®æ¬¡</h2>
<ul>
<li><a href="#rails-api%E5%9F%BA%E7%A4%8E">Rails APIåŸºç¤</a></li>
<li><a href="#restful-api%E8%A8%AD%E8%A8%88">RESTful APIè¨­è¨ˆ</a></li>
<li><a href="#%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF%E3%81%AE%E5%AE%9F%E8%A3%85">èªè¨¼ãƒ»èªå¯ã®å®Ÿè£…</a></li>
<li><a href="#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B9%E8%A8%AD%E8%A8%88">ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ</a></li>
<li><a href="#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%9C%80%E9%81%A9%E5%8C%96">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–</a></li>
<li><a href="#graphql%E5%AE%9F%E8%A3%85">GraphQLå®Ÿè£…</a></li>
<li><a href="#%E3%83%86%E3%82%B9%E3%83%88%E6%88%A6%E7%95%A5">ãƒ†ã‚¹ãƒˆæˆ¦ç•¥</a></li>
<li><a href="#%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E5%AF%BE%E7%AD%96">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–</a></li>
<li><a href="#%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã¨ãƒ‡ãƒ—ãƒ­ã‚¤</a></li>
</ul>
<h2 id="rails-apiåŸºç¤">Rails APIåŸºç¤</h2>
<h3 id="rails-apiãƒ¢ãƒ¼ãƒ‰ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—">Rails APIãƒ¢ãƒ¼ãƒ‰ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—</h3>
<pre><code class="language-bash"># APIãƒ¢ãƒ¼ãƒ‰ã§Railsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
rails new my_api --api --database=postgresql

# ä¸»ãªé•ã„ï¼š
# - ApplicationControllerãŒActionController::APIã‚’ç¶™æ‰¿
# - ãƒ“ãƒ¥ãƒ¼å±¤ã€ã‚¢ã‚»ãƒƒãƒˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³é–¢é€£ãŒé™¤å¤–
# - CORSã‚„JSONãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«æœ€é©åŒ–
</code></pre>
<h3 id="åŸºæœ¬çš„ãªapiã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼">åŸºæœ¬çš„ãªAPIã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</h3>
<pre><code class="language-ruby"># app/controllers/api/v1/base_controller.rb
module Api
  module V1
    class BaseController &#x3C; ApplicationController
      # å…±é€šã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
      rescue_from ActiveRecord::RecordNotFound, with: :not_found
      rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity
      rescue_from ActionController::ParameterMissing, with: :bad_request

      private

      def not_found(exception)
        render json: { 
          error: {
            message: exception.message,
            type: 'ResourceNotFound'
          }
        }, status: :not_found
      end

      def unprocessable_entity(exception)
        render json: { 
          error: {
            message: exception.record.errors.full_messages.join(', '),
            type: 'ValidationError',
            details: exception.record.errors.details
          }
        }, status: :unprocessable_entity
      end

      def bad_request(exception)
        render json: { 
          error: {
            message: exception.message,
            type: 'BadRequest'
          }
        }, status: :bad_request
      end

      # ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ¡ã‚½ãƒƒãƒ‰
      def paginate(resource)
        resource.page(params[:page] || 1).per(params[:per_page] || 20)
      end

      # ãƒ¡ã‚¿æƒ…å ±ã®è¿½åŠ 
      def render_with_meta(resource, options = {})
        if resource.respond_to?(:current_page)
          options[:meta] = pagination_meta(resource)
        end
        render json: resource, **options
      end

      def pagination_meta(resource)
        {
          current_page: resource.current_page,
          total_pages: resource.total_pages,
          total_count: resource.total_count,
          per_page: resource.limit_value
        }
      end
    end
  end
end
</code></pre>
<h3 id="serializerã®å®Ÿè£…activemodelserializers">Serializerã®å®Ÿè£…ï¼ˆActiveModel::Serializersï¼‰</h3>
<pre><code class="language-ruby"># Gemfile
gem 'active_model_serializers', '~> 0.10.0'

# app/serializers/api/v1/user_serializer.rb
module Api
  module V1
    class UserSerializer &#x3C; ActiveModel::Serializer
      attributes :id, :email, :name, :avatar_url, :created_at
      
      # é–¢é€£ã®å®šç¾©
      has_many :posts
      has_one :profile
      
      # ã‚«ã‚¹ã‚¿ãƒ å±æ€§
      attribute :full_name do
        "#{object.first_name} #{object.last_name}"
      end
      
      # æ¡ä»¶ä»˜ãå±æ€§
      attribute :admin_info, if: :is_admin?
      
      def admin_info
        {
          last_login: object.last_login_at,
          permissions: object.permissions
        }
      end
      
      def is_admin?
        scope &#x26;&#x26; scope.admin?
      end
      
      # URLãƒ˜ãƒ«ãƒ‘ãƒ¼ã®ä½¿ç”¨
      link(:self) { api_v1_user_url(object) }
    end
  end
end
</code></pre>
<h2 id="restful-apiè¨­è¨ˆ">RESTful APIè¨­è¨ˆ</h2>
<h3 id="ãƒªã‚½ãƒ¼ã‚¹ãƒ™ãƒ¼ã‚¹ã®urlè¨­è¨ˆ">ãƒªã‚½ãƒ¼ã‚¹ãƒ™ãƒ¼ã‚¹ã®URLè¨­è¨ˆ</h3>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  namespace :api do
    namespace :v1 do
      # ãƒªã‚½ãƒ¼ã‚¹ãƒ•ãƒ«ãªãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
      resources :users do
        member do
          post :activate
          post :deactivate
        end
        
        collection do
          get :search
          get :export
        end
        
        # ãƒã‚¹ãƒˆã—ãŸãƒªã‚½ãƒ¼ã‚¹
        resources :posts, shallow: true do
          resources :comments
          resources :likes, only: [:create, :destroy]
        end
      end
      
      # ã‚«ã‚¹ã‚¿ãƒ ãƒ«ãƒ¼ãƒˆ
      post 'auth/login', to: 'authentication#login'
      post 'auth/logout', to: 'authentication#logout'
      post 'auth/refresh', to: 'authentication#refresh'
      
      # æ¤œç´¢ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
      namespace :search do
        get 'users', to: 'users#index'
        get 'posts', to: 'posts#index'
        get 'global', to: 'global#index'
      end
    end
  end
end
</code></pre>
<h3 id="httpã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®é©åˆ‡ãªä½¿ç”¨">HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®é©åˆ‡ãªä½¿ç”¨</h3>
<pre><code class="language-ruby"># app/controllers/api/v1/posts_controller.rb
module Api
  module V1
    class PostsController &#x3C; BaseController
      before_action :authenticate_user!
      before_action :set_post, only: [:show, :update, :destroy]
      before_action :authorize_user!, only: [:update, :destroy]

      # GET /api/v1/posts
      def index
        posts = Post.published
                   .includes(:user, :tags, :comments)
                   .search(params[:q])
                   .filter_by_tags(params[:tags])
                   .order(created_at: :desc)
        
        posts = paginate(posts)
        
        render_with_meta(
          posts,
          each_serializer: PostSerializer,
          include: ['user', 'tags']
        )
      end

      # GET /api/v1/posts/:id
      def show
        render json: @post, 
               serializer: PostDetailSerializer,
               include: ['user', 'comments', 'comments.user']
      end

      # POST /api/v1/posts
      def create
        post = current_user.posts.build(post_params)
        
        if post.save
          # 201 Created
          render json: post, 
                 serializer: PostSerializer,
                 status: :created,
                 location: api_v1_post_url(post)
        else
          # 422 Unprocessable Entity
          render json: { 
            errors: post.errors.full_messages,
            details: post.errors.details 
          }, status: :unprocessable_entity
        end
      end

      # PATCH/PUT /api/v1/posts/:id
      def update
        if @post.update(post_params)
          # 200 OK
          render json: @post, serializer: PostSerializer
        else
          # 422 Unprocessable Entity
          render json: { 
            errors: @post.errors.full_messages 
          }, status: :unprocessable_entity
        end
      end

      # DELETE /api/v1/posts/:id
      def destroy
        @post.destroy
        # 204 No Content
        head :no_content
      end

      private

      def set_post
        @post = Post.find(params[:id])
      end

      def authorize_user!
        # 403 Forbidden
        unless @post.user == current_user || current_user.admin?
          render json: { 
            error: 'You are not authorized to perform this action' 
          }, status: :forbidden
        end
      end

      def post_params
        params.require(:post).permit(
          :title, 
          :content, 
          :published, 
          tag_ids: [],
          images_attributes: [:id, :url, :caption, :_destroy]
        )
      end
    end
  end
end
</code></pre>
<h3 id="ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆ">ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆ</h3>
<pre><code class="language-ruby"># app/models/concerns/filterable.rb
module Filterable
  extend ActiveSupport::Concern

  module ClassMethods
    def filter(filtering_params)
      results = self.where(nil)
      filtering_params.each do |key, value|
        results = results.public_send("filter_by_#{key}", value) if value.present?
      end
      results
    end
  end
end

# app/models/post.rb
class Post &#x3C; ApplicationRecord
  include Filterable
  
  belongs_to :user
  has_many :comments, dependent: :destroy
  has_and_belongs_to_many :tags
  
  # ã‚¹ã‚³ãƒ¼ãƒ—å®šç¾©
  scope :published, -> { where(published: true) }
  scope :draft, -> { where(published: false) }
  scope :recent, -> { where('created_at > ?', 1.week.ago) }
  
  # ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ç”¨ã‚¹ã‚³ãƒ¼ãƒ—
  scope :filter_by_status, ->(status) { 
    case status
    when 'published' then published
    when 'draft' then draft
    else all
    end
  }
  
  scope :filter_by_user_id, ->(user_id) { where(user_id: user_id) }
  
  scope :filter_by_tags, ->(tag_names) {
    joins(:tags).where(tags: { name: tag_names })
  }
  
  scope :filter_by_date_range, ->(from, to) {
    where(created_at: from..to)
  }
  
  # å…¨æ–‡æ¤œç´¢
  scope :search, ->(query) {
    return all if query.blank?
    
    where('title ILIKE :q OR content ILIKE :q', q: "%#{query}%")
  }
  
  # ã‚½ãƒ¼ãƒˆ
  scope :sort_by_field, ->(field, direction = 'asc') {
    safe_fields = %w[created_at updated_at title views_count]
    safe_directions = %w[asc desc]
    
    field = 'created_at' unless safe_fields.include?(field)
    direction = 'desc' unless safe_directions.include?(direction)
    
    order(field => direction)
  }
end

# ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã®ä½¿ç”¨
def index
  posts = Post.filter(
    status: params[:status],
    user_id: params[:user_id],
    tags: params[:tags]
  ).sort_by_field(params[:sort], params[:direction])
  
  render json: paginate(posts)
end
</code></pre>
<h2 id="èªè¨¼èªå¯ã®å®Ÿè£…">èªè¨¼ãƒ»èªå¯ã®å®Ÿè£…</h2>
<h3 id="jwtèªè¨¼ã®å®Ÿè£…">JWTèªè¨¼ã®å®Ÿè£…</h3>
<pre><code class="language-ruby"># Gemfile
gem 'jwt'
gem 'bcrypt'

# app/lib/json_web_token.rb
class JsonWebToken
  SECRET_KEY = Rails.application.credentials.secret_key_base || Rails.application.secrets.secret_key_base
  
  def self.encode(payload, exp = 24.hours.from_now)
    payload[:exp] = exp.to_i
    JWT.encode(payload, SECRET_KEY, 'HS256')
  end
  
  def self.decode(token)
    decoded = JWT.decode(token, SECRET_KEY, true, algorithm: 'HS256')[0]
    HashWithIndifferentAccess.new(decoded)
  rescue JWT::DecodeError => e
    raise ExceptionHandler::InvalidToken, e.message
  end
end

# app/controllers/concerns/exception_handler.rb
module ExceptionHandler
  extend ActiveSupport::Concern
  
  class AuthenticationError &#x3C; StandardError; end
  class InvalidToken &#x3C; StandardError; end
  class MissingToken &#x3C; StandardError; end
  class ExpiredToken &#x3C; StandardError; end
  
  included do
    rescue_from ExceptionHandler::AuthenticationError, with: :unauthorized_request
    rescue_from ExceptionHandler::InvalidToken, with: :unauthorized_request
    rescue_from ExceptionHandler::MissingToken, with: :unauthorized_request
    rescue_from ExceptionHandler::ExpiredToken, with: :unauthorized_request
  end
  
  private
  
  def unauthorized_request(e)
    render json: { error: e.message }, status: :unauthorized
  end
end

# app/controllers/concerns/authenticable.rb
module Authenticable
  extend ActiveSupport::Concern
  
  included do
    before_action :authenticate_request
    attr_reader :current_user
  end
  
  private
  
  def authenticate_request
    @current_user = AuthorizeApiRequest.new(request.headers).call
  rescue StandardError => e
    render json: { error: e.message }, status: :unauthorized
  end
  
  def authenticate_user!
    authenticate_request
  end
end

# app/services/authorize_api_request.rb
class AuthorizeApiRequest
  def initialize(headers = {})
    @headers = headers
  end
  
  def call
    user
  end
  
  private
  
  attr_reader :headers
  
  def user
    @user ||= User.find(decoded_auth_token[:user_id]) if decoded_auth_token
  rescue ActiveRecord::RecordNotFound => e
    raise ExceptionHandler::InvalidToken, "Invalid token: #{e.message}"
  end
  
  def decoded_auth_token
    @decoded_auth_token ||= JsonWebToken.decode(http_auth_header)
  end
  
  def http_auth_header
    if headers['Authorization'].present?
      return headers['Authorization'].split(' ').last
    end
    raise ExceptionHandler::MissingToken, 'Missing token'
  end
end
</code></pre>
<h3 id="èªè¨¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼">èªè¨¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</h3>
<pre><code class="language-ruby"># app/controllers/api/v1/authentication_controller.rb
module Api
  module V1
    class AuthenticationController &#x3C; BaseController
      skip_before_action :authenticate_user!, only: [:login, :register]
      
      # POST /api/v1/auth/register
      def register
        user = User.new(user_params)
        
        if user.save
          token = generate_token(user)
          render json: {
            user: UserSerializer.new(user),
            token: token,
            expires_at: 24.hours.from_now
          }, status: :created
        else
          render json: { 
            errors: user.errors.full_messages 
          }, status: :unprocessable_entity
        end
      end
      
      # POST /api/v1/auth/login
      def login
        user = User.find_by(email: params[:email])
        
        if user&#x26;.authenticate(params[:password])
          token = generate_token(user)
          
          # ãƒ­ã‚°ã‚¤ãƒ³å±¥æ­´ã®è¨˜éŒ²
          user.update(
            last_login_at: Time.current,
            last_login_ip: request.remote_ip
          )
          
          render json: {
            user: UserSerializer.new(user),
            token: token,
            expires_at: 24.hours.from_now
          }
        else
          render json: { 
            error: 'Invalid email or password' 
          }, status: :unauthorized
        end
      end
      
      # POST /api/v1/auth/logout
      def logout
        # JWTã®å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‰Šé™¤
        # ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã«è¿½åŠ 
        token = request.headers['Authorization']&#x26;.split(' ')&#x26;.last
        BlacklistedToken.create(token: token, expires_at: 24.hours.from_now) if token
        
        head :no_content
      end
      
      # POST /api/v1/auth/refresh
      def refresh
        # ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®å®Ÿè£…
        refresh_token = params[:refresh_token]
        
        if valid_refresh_token?(refresh_token)
          user = User.find_by(refresh_token: refresh_token)
          new_token = generate_token(user)
          
          render json: {
            token: new_token,
            expires_at: 24.hours.from_now
          }
        else
          render json: { 
            error: 'Invalid refresh token' 
          }, status: :unauthorized
        end
      end
      
      private
      
      def user_params
        params.permit(:email, :password, :password_confirmation, :name)
      end
      
      def generate_token(user)
        JsonWebToken.encode(user_id: user.id)
      end
      
      def valid_refresh_token?(token)
        # ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
        return false if token.blank?
        
        user = User.find_by(refresh_token: token)
        user &#x26;&#x26; user.refresh_token_expires_at > Time.current
      end
    end
  end
end
</code></pre>
<h3 id="èªå¯punditä½¿ç”¨">èªå¯ï¼ˆPunditä½¿ç”¨ï¼‰</h3>
<pre><code class="language-ruby"># Gemfile
gem 'pundit'

# app/policies/application_policy.rb
class ApplicationPolicy
  attr_reader :user, :record

  def initialize(user, record)
    @user = user
    @record = record
  end

  def index?
    true
  end

  def show?
    true
  end

  def create?
    user.present?
  end

  def update?
    user.present? &#x26;&#x26; (record.user == user || user.admin?)
  end

  def destroy?
    update?
  end

  class Scope
    attr_reader :user, :scope

    def initialize(user, scope)
      @user = user
      @scope = scope
    end

    def resolve
      scope.all
    end
  end
end

# app/policies/post_policy.rb
class PostPolicy &#x3C; ApplicationPolicy
  def index?
    true
  end
  
  def show?
    record.published? || record.user == user || user&#x26;.admin?
  end
  
  def create?
    user.present?
  end
  
  def update?
    record.user == user || user&#x26;.admin?
  end
  
  def destroy?
    record.user == user || user&#x26;.admin?
  end
  
  def publish?
    record.user == user || user&#x26;.admin?
  end
  
  class Scope &#x3C; Scope
    def resolve
      if user&#x26;.admin?
        scope.all
      elsif user
        scope.where('published = ? OR user_id = ?', true, user.id)
      else
        scope.published
      end
    end
  end
end

# ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã®ä½¿ç”¨
class PostsController &#x3C; BaseController
  include Pundit
  
  def index
    posts = policy_scope(Post)
    render json: posts
  end
  
  def show
    post = Post.find(params[:id])
    authorize post
    render json: post
  end
  
  def update
    post = Post.find(params[:id])
    authorize post
    
    if post.update(post_params)
      render json: post
    else
      render json: { errors: post.errors }, status: :unprocessable_entity
    end
  end
end
</code></pre>
<h2 id="ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ">ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ</h2>
<h3 id="çµ±ä¸€çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹">çµ±ä¸€çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹</h3>
<pre><code class="language-ruby"># app/controllers/concerns/error_handler.rb
module ErrorHandler
  extend ActiveSupport::Concern
  
  included do
    rescue_from StandardError, with: :handle_internal_server_error
    rescue_from ActiveRecord::RecordNotFound, with: :handle_not_found
    rescue_from ActiveRecord::RecordInvalid, with: :handle_unprocessable_entity
    rescue_from ActionController::ParameterMissing, with: :handle_bad_request
    rescue_from Pundit::NotAuthorizedError, with: :handle_forbidden
    
    # ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼
    rescue_from CustomErrors::ValidationError, with: :handle_validation_error
    rescue_from CustomErrors::AuthenticationError, with: :handle_authentication_error
    rescue_from CustomErrors::RateLimitError, with: :handle_rate_limit
  end
  
  private
  
  def handle_internal_server_error(exception)
    logger.error exception.message
    logger.error exception.backtrace.join("\n")
    
    if Rails.env.production?
      render_error(500, 'Internal Server Error', 'An error occurred')
    else
      render_error(500, 'Internal Server Error', exception.message)
    end
  end
  
  def handle_not_found(exception)
    render_error(404, 'Not Found', exception.message)
  end
  
  def handle_unprocessable_entity(exception)
    render_error(
      422, 
      'Unprocessable Entity', 
      exception.record.errors.full_messages.join(', '),
      exception.record.errors.details
    )
  end
  
  def handle_bad_request(exception)
    render_error(400, 'Bad Request', exception.message)
  end
  
  def handle_forbidden(exception)
    render_error(403, 'Forbidden', 'You are not authorized to perform this action')
  end
  
  def handle_validation_error(exception)
    render_error(422, 'Validation Error', exception.message, exception.errors)
  end
  
  def handle_authentication_error(exception)
    render_error(401, 'Authentication Error', exception.message)
  end
  
  def handle_rate_limit(exception)
    response.headers['X-RateLimit-Limit'] = exception.limit.to_s
    response.headers['X-RateLimit-Remaining'] = '0'
    response.headers['X-RateLimit-Reset'] = exception.reset_at.to_i.to_s
    
    render_error(429, 'Too Many Requests', 'Rate limit exceeded')
  end
  
  def render_error(status, error_type, message, details = nil)
    error_response = {
      error: {
        status: status,
        type: error_type,
        message: message,
        timestamp: Time.current.iso8601
      }
    }
    
    error_response[:error][:details] = details if details.present?
    
    render json: error_response, status: status
  end
end

# app/lib/custom_errors.rb
module CustomErrors
  class BaseError &#x3C; StandardError
    attr_reader :status, :error_type, :details
    
    def initialize(message = nil, status = nil, error_type = nil, details = nil)
      @status = status
      @error_type = error_type
      @details = details
      super(message)
    end
  end
  
  class ValidationError &#x3C; BaseError
    def initialize(message = 'Validation failed', details = nil)
      super(message, 422, 'ValidationError', details)
    end
  end
  
  class AuthenticationError &#x3C; BaseError
    def initialize(message = 'Authentication failed')
      super(message, 401, 'AuthenticationError')
    end
  end
  
  class RateLimitError &#x3C; BaseError
    attr_reader :limit, :reset_at
    
    def initialize(limit, reset_at)
      @limit = limit
      @reset_at = reset_at
      super('Rate limit exceeded', 429, 'RateLimitError')
    end
  end
end
</code></pre>
<h3 id="ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¨™æº–åŒ–">ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¨™æº–åŒ–</h3>
<pre><code class="language-ruby"># app/services/response_builder.rb
class ResponseBuilder
  def self.success(data = nil, message = nil, meta = {})
    response = {
      success: true,
      timestamp: Time.current.iso8601
    }
    
    response[:data] = data if data.present?
    response[:message] = message if message.present?
    response[:meta] = meta if meta.present?
    
    response
  end
  
  def self.error(status, error_type, message, details = nil)
    {
      success: false,
      error: {
        status: status,
        type: error_type,
        message: message,
        details: details
      }.compact,
      timestamp: Time.current.iso8601
    }
  end
  
  def self.paginated(collection, serializer, options = {})
    {
      success: true,
      data: ActiveModelSerializers::SerializableResource.new(
        collection,
        each_serializer: serializer,
        **options
      ),
      meta: {
        pagination: {
          current_page: collection.current_page,
          total_pages: collection.total_pages,
          total_count: collection.total_count,
          per_page: collection.limit_value,
          next_page: collection.next_page,
          prev_page: collection.prev_page
        }
      },
      timestamp: Time.current.iso8601
    }
  end
end

# ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã®ä½¿ç”¨
def index
  posts = Post.published.page(params[:page])
  render json: ResponseBuilder.paginated(posts, PostSerializer)
end

def create
  post = current_user.posts.build(post_params)
  
  if post.save
    render json: ResponseBuilder.success(
      PostSerializer.new(post),
      'Post created successfully'
    ), status: :created
  else
    render json: ResponseBuilder.error(
      422,
      'ValidationError',
      'Validation failed',
      post.errors.details
    ), status: :unprocessable_entity
  end
end
</code></pre>
<h2 id="ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–</h2>
<h3 id="n1å•é¡Œã®è§£æ±º">N+1å•é¡Œã®è§£æ±º</h3>
<pre><code class="language-ruby"># app/models/post.rb
class Post &#x3C; ApplicationRecord
  belongs_to :user
  has_many :comments
  has_many :likes
  has_and_belongs_to_many :tags
  
  # Bullet gemã«ã‚ˆã‚‹æ¤œå‡º
  # Gemfile
  # gem 'bullet', group: :development
  
  # ã‚¹ã‚³ãƒ¼ãƒ—ã§ã®includes
  scope :with_associations, -> {
    includes(:user, :tags, comments: :user)
  }
  
  # ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ä½¿ç”¨
  # comments_count, likes_count ã‚«ãƒ©ãƒ ã‚’è¿½åŠ 
  has_many :comments, counter_cache: true
  has_many :likes, counter_cache: true
end

# app/controllers/api/v1/posts_controller.rb
def index
  # âŒ N+1å•é¡ŒãŒç™ºç”Ÿ
  posts = Post.all
  
  # âœ… includesã§è§£æ±º
  posts = Post.includes(:user, :tags, :comments)
  
  # âœ… ã‚ˆã‚Šè©³ç´°ãªæœ€é©åŒ–
  posts = Post
    .includes(:user, :tags)
    .includes(comments: [:user, :likes])
    .references(:comments)
    .where('comments.created_at > ?', 1.week.ago)
  
  render json: posts
end

# app/serializers/post_serializer.rb
class PostSerializer &#x3C; ActiveModel::Serializer
  attributes :id, :title, :content, :comments_count, :likes_count
  
  belongs_to :user
  has_many :tags
  
  # ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨
  def comments_count
    object.comments_count # N+1ã‚’é¿ã‘ã‚‹
  end
  
  def likes_count
    object.likes_count # N+1ã‚’é¿ã‘ã‚‹
  end
end
</code></pre>
<h3 id="ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥">ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥</h3>
<pre><code class="language-ruby"># config/environments/production.rb
config.cache_store = :redis_cache_store, {
  url: ENV['REDIS_URL'],
  expires_in: 1.hour
}

# app/controllers/api/v1/posts_controller.rb
class PostsController &#x3C; BaseController
  def index
    posts = Rails.cache.fetch(cache_key_for_posts, expires_in: 30.minutes) do
      Post.published
          .includes(:user, :tags)
          .order(created_at: :desc)
          .limit(100)
          .to_a # é…åˆ—ã«å¤‰æ›ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    end
    
    render json: posts
  end
  
  def show
    post = Rails.cache.fetch("post/#{params[:id]}", expires_in: 1.hour) do
      Post.includes(:user, :tags, comments: :user)
          .find(params[:id])
    end
    
    # ETagsä½¿ç”¨
    if stale?(post)
      render json: post, serializer: PostDetailSerializer
    end
  end
  
  private
  
  def cache_key_for_posts
    "posts/#{params[:page]}/#{params[:per_page]}/#{Post.maximum(:updated_at)}"
  end
end

# app/models/post.rb
class Post &#x3C; ApplicationRecord
  # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®è‡ªå‹•ç„¡åŠ¹åŒ–
  after_commit :clear_cache
  
  private
  
  def clear_cache
    Rails.cache.delete("post/#{id}")
    Rails.cache.delete_matched("posts/*")
  end
end

# Fragment Caching in Serializers
class PostSerializer &#x3C; ActiveModel::Serializer
  cache key: 'post', expires_in: 3.hours
  
  attributes :id, :title, :content
  has_many :comments
  
  def cache_key
    "#{object.cache_key}/#{object.comments.maximum(:updated_at)}"
  end
end
</code></pre>
<h3 id="ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–">ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–</h3>
<pre><code class="language-ruby"># app/models/concerns/searchable.rb
module Searchable
  extend ActiveSupport::Concern
  
  included do
    # PostgreSQLå…¨æ–‡æ¤œç´¢
    scope :search, ->(query) {
      return all if query.blank?
      
      # tsvectorã‚«ãƒ©ãƒ ã‚’ä½¿ç”¨ï¼ˆãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§è¿½åŠ ï¼‰
      where("search_vector @@ plainto_tsquery('english', ?)", query)
    }
  end
end

# db/migrate/add_search_vector_to_posts.rb
class AddSearchVectorToPosts &#x3C; ActiveRecord::Migration[7.0]
  def up
    # tsvectorã‚«ãƒ©ãƒ ã‚’è¿½åŠ 
    add_column :posts, :search_vector, :tsvector
    
    # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ 
    add_index :posts, :search_vector, using: :gin
    
    # ãƒˆãƒªã‚¬ãƒ¼ã‚’ä½œæˆ
    execute &#x3C;&#x3C;-SQL
      CREATE TRIGGER posts_search_vector_update
      BEFORE INSERT OR UPDATE ON posts
      FOR EACH ROW EXECUTE FUNCTION
      tsvector_update_trigger(search_vector, 'pg_catalog.english', title, content);
    SQL
  end
  
  def down
    remove_column :posts, :search_vector
  end
end

# è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æ´»ç”¨
class AddCompoundIndexes &#x3C; ActiveRecord::Migration[7.0]
  def change
    # ã‚ˆãä¸€ç·’ã«æ¤œç´¢ã•ã‚Œã‚‹æ¡ä»¶
    add_index :posts, [:user_id, :published, :created_at]
    add_index :posts, [:published, :created_at]
    
    # éƒ¨åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆæ¡ä»¶ä»˜ãã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
    add_index :posts, :created_at, where: "published = true", name: 'index_published_posts_on_created_at'
  end
end

# ã‚¯ã‚¨ãƒªæœ€é©åŒ–
class Post &#x3C; ApplicationRecord
  # ãƒãƒƒãƒå‡¦ç†
  def self.process_all
    find_each(batch_size: 1000) do |post|
      post.process
    end
  end
  
  # SELECTå¥ã®æœ€é©åŒ–
  scope :minimal, -> {
    select(:id, :title, :created_at)
  }
  
  # EXISTSä½¿ç”¨
  scope :with_comments, -> {
    where('EXISTS (SELECT 1 FROM comments WHERE comments.post_id = posts.id)')
  }
  
  # Windowé–¢æ•°ã®æ´»ç”¨
  scope :ranked_by_likes, -> {
    select('posts.*, RANK() OVER (ORDER BY likes_count DESC) as rank')
  }
end
</code></pre>
<h3 id="ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–">ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–</h3>
<pre><code class="language-ruby"># Gemfile
gem 'sidekiq'
gem 'redis'

# app/jobs/notification_job.rb
class NotificationJob &#x3C; ApplicationJob
  queue_as :default
  
  def perform(user_id, notification_type, data = {})
    user = User.find(user_id)
    
    case notification_type
    when 'new_comment'
      NotificationService.send_new_comment_notification(user, data)
    when 'new_like'
      NotificationService.send_new_like_notification(user, data)
    end
  end
end

# app/controllers/api/v1/comments_controller.rb
def create
  comment = @post.comments.build(comment_params)
  comment.user = current_user
  
  if comment.save
    # éåŒæœŸã§é€šçŸ¥ã‚’é€ä¿¡
    NotificationJob.perform_later(
      @post.user_id,
      'new_comment',
      { comment_id: comment.id }
    )
    
    render json: comment, status: :created
  else
    render json: { errors: comment.errors }, status: :unprocessable_entity
  end
end

# app/services/heavy_operation_service.rb
class HeavyOperationService
  def self.process_async(data)
    # Sidekiqã§éåŒæœŸå®Ÿè¡Œ
    ProcessingWorker.perform_async(data)
    
    # ã‚¸ãƒ§ãƒ–IDã‚’è¿”ã™
    { job_id: SecureRandom.uuid, status: 'processing' }
  end
end

# app/workers/processing_worker.rb
class ProcessingWorker
  include Sidekiq::Worker
  
  sidekiq_options retry: 3, dead: false
  
  def perform(data)
    # é‡ã„å‡¦ç†
    result = ComplexCalculation.new(data).execute
    
    # çµæœã‚’Redisã«ä¿å­˜
    Rails.cache.write("processing_result_#{data['id']}", result, expires_in: 1.day)
    
    # WebSocketã§é€šçŸ¥ï¼ˆAction Cableä½¿ç”¨ï¼‰
    ActionCable.server.broadcast(
      "processing_#{data['user_id']}",
      { status: 'completed', result: result }
    )
  end
end
</code></pre>
<h2 id="graphqlå®Ÿè£…">GraphQLå®Ÿè£…</h2>
<h3 id="graphqlåŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—">GraphQLåŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—</h3>
<pre><code class="language-ruby"># Gemfile
gem 'graphql'
gem 'graphiql-rails', group: :development

# app/graphql/types/base_object.rb
module Types
  class BaseObject &#x3C; GraphQL::Schema::Object
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)
    field_class Types::BaseField
  end
end

# app/graphql/types/user_type.rb
module Types
  class UserType &#x3C; Types::BaseObject
    field :id, ID, null: false
    field :email, String, null: false
    field :name, String, null: true
    field :posts, [Types::PostType], null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
    
    # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    field :post_count, Integer, null: false
    
    def post_count
      object.posts.count
    end
    
    # èªè¨¼ãŒå¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    field :private_info, String, null: true
    
    def private_info
      return nil unless context[:current_user] == object
      object.private_info
    end
  end
end

# app/graphql/types/post_type.rb
module Types
  class PostType &#x3C; Types::BaseObject
    field :id, ID, null: false
    field :title, String, null: false
    field :content, String, null: false
    field :published, Boolean, null: false
    field :user, Types::UserType, null: false
    field :comments, [Types::CommentType], null: true
    field :tags, [Types::TagType], null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end

# app/graphql/types/query_type.rb
module Types
  class QueryType &#x3C; Types::BaseObject
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§
    field :users, [Types::UserType], null: false do
      argument :limit, Integer, required: false, default_value: 20
      argument :offset, Integer, required: false, default_value: 0
    end
    
    def users(limit:, offset:)
      User.limit(limit).offset(offset)
    end
    
    # å˜ä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼
    field :user, Types::UserType, null: true do
      argument :id, ID, required: true
    end
    
    def user(id:)
      User.find_by(id: id)
    end
    
    # æŠ•ç¨¿æ¤œç´¢
    field :posts, Types::PostType.connection_type, null: false do
      argument :filter, Types::PostFilterType, required: false
      argument :order_by, Types::PostOrderType, required: false
    end
    
    def posts(filter: nil, order_by: nil)
      scope = Post.published
      scope = apply_filter(scope, filter) if filter
      scope = apply_order(scope, order_by) if order_by
      scope
    end
    
    private
    
    def apply_filter(scope, filter)
      scope = scope.where(user_id: filter.user_id) if filter.user_id
      scope = scope.search(filter.search) if filter.search
      scope = scope.where('created_at >= ?', filter.from_date) if filter.from_date
      scope = scope.where('created_at &#x3C;= ?', filter.to_date) if filter.to_date
      scope
    end
    
    def apply_order(scope, order_by)
      case order_by
      when 'CREATED_AT_ASC'
        scope.order(created_at: :asc)
      when 'CREATED_AT_DESC'
        scope.order(created_at: :desc)
      when 'TITLE_ASC'
        scope.order(title: :asc)
      else
        scope
      end
    end
  end
end

# app/graphql/types/mutation_type.rb
module Types
  class MutationType &#x3C; Types::BaseObject
    field :create_post, mutation: Mutations::CreatePost
    field :update_post, mutation: Mutations::UpdatePost
    field :delete_post, mutation: Mutations::DeletePost
    field :login, mutation: Mutations::Login
    field :register, mutation: Mutations::Register
  end
end

# app/graphql/mutations/create_post.rb
module Mutations
  class CreatePost &#x3C; BaseMutation
    # å¼•æ•°ã®å®šç¾©
    argument :title, String, required: true
    argument :content, String, required: true
    argument :published, Boolean, required: false, default_value: false
    argument :tag_ids, [ID], required: false
    
    # æˆ»ã‚Šå€¤ã®å®šç¾©
    field :post, Types::PostType, null: true
    field :errors, [String], null: false
    
    def resolve(title:, content:, published:, tag_ids: [])
      # èªè¨¼ãƒã‚§ãƒƒã‚¯
      return { post: nil, errors: ['Not authenticated'] } unless context[:current_user]
      
      post = context[:current_user].posts.build(
        title: title,
        content: content,
        published: published
      )
      
      post.tag_ids = tag_ids if tag_ids.present?
      
      if post.save
        { post: post, errors: [] }
      else
        { post: nil, errors: post.errors.full_messages }
      end
    end
  end
end
</code></pre>
<h3 id="graphqlèªè¨¼ã¨n1å¯¾ç­–">GraphQLèªè¨¼ã¨N+1å¯¾ç­–</h3>
<pre><code class="language-ruby"># app/graphql/my_api_schema.rb
class MyApiSchema &#x3C; GraphQL::Schema
  mutation(Types::MutationType)
  query(Types::QueryType)
  
  # GraphQL-Batch for N+1 prevention
  use GraphQL::Batch
  
  # Query complexity prevention
  max_complexity 300
  max_depth 10
  
  def self.unauthorized_object(error)
    raise GraphQL::ExecutionError, "You don't have permission to access #{error.object}"
  end
end

# app/graphql/loaders/association_loader.rb
class Loaders::AssociationLoader &#x3C; GraphQL::Batch::Loader
  def initialize(model, association_name)
    @model = model
    @association_name = association_name
  end
  
  def perform(records)
    preload_association(records)
    records.each { |record| fulfill(record, read_association(record)) }
  end
  
  private
  
  def preload_association(records)
    ActiveRecord::Associations::Preloader.new(
      records: records,
      associations: @association_name
    ).call
  end
  
  def read_association(record)
    record.public_send(@association_name)
  end
end

# app/graphql/types/post_type.rb
module Types
  class PostType &#x3C; Types::BaseObject
    field :comments, [Types::CommentType], null: true
    
    # N+1ã‚’é˜²ããŸã‚ã®DataLoaderä½¿ç”¨
    def comments
      Loaders::AssociationLoader.for(Post, :comments).load(object)
    end
    
    field :user, Types::UserType, null: false
    
    def user
      Loaders::RecordLoader.for(User).load(object.user_id)
    end
  end
end

# app/controllers/graphql_controller.rb
class GraphqlController &#x3C; ApplicationController
  skip_before_action :verify_authenticity_token
  
  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    
    context = {
      current_user: current_user,
      request: request
    }
    
    result = MyApiSchema.execute(
      query,
      variables: variables,
      context: context,
      operation_name: operation_name
    )
    
    render json: result
  rescue StandardError => e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end
  
  private
  
  def current_user
    token = request.headers['Authorization']&#x26;.split(' ')&#x26;.last
    return nil unless token
    
    decoded = JsonWebToken.decode(token)
    User.find(decoded[:user_id])
  rescue StandardError
    nil
  end
  
  def prepare_variables(variables_param)
    case variables_param
    when String
      variables_param.present? ? JSON.parse(variables_param) || {} : {}
    when Hash
      variables_param
    when ActionController::Parameters
      variables_param.to_unsafe_hash
    when nil
      {}
    else
      raise ArgumentError, "Unexpected parameter: #{variables_param}"
    end
  end
  
  def handle_error_in_development(e)
    logger.error e.message
    logger.error e.backtrace.join("\n")
    
    render json: {
      errors: [{ message: e.message, backtrace: e.backtrace }],
      data: {}
    }, status: 500
  end
end
</code></pre>
<h2 id="ãƒ†ã‚¹ãƒˆæˆ¦ç•¥">ãƒ†ã‚¹ãƒˆæˆ¦ç•¥</h2>
<h3 id="rspecã§ã®api-ãƒ†ã‚¹ãƒˆ">RSpecã§ã®API ãƒ†ã‚¹ãƒˆ</h3>
<pre><code class="language-ruby"># spec/rails_helper.rb
require 'spec_helper'
ENV['RAILS_ENV'] ||= 'test'
require_relative '../config/environment'

RSpec.configure do |config|
  config.include FactoryBot::Syntax::Methods
  config.include RequestSpecHelper, type: :request
  
  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end
end

# spec/support/request_spec_helper.rb
module RequestSpecHelper
  def json
    JSON.parse(response.body)
  end
  
  def auth_headers(user)
    token = JsonWebToken.encode(user_id: user.id)
    { 'Authorization' => "Bearer #{token}" }
  end
end

# spec/requests/api/v1/posts_spec.rb
require 'rails_helper'

RSpec.describe 'Posts API', type: :request do
  let(:user) { create(:user) }
  let(:headers) { auth_headers(user) }
  
  describe 'GET /api/v1/posts' do
    let!(:posts) { create_list(:post, 10, published: true) }
    
    before { get '/api/v1/posts', params: {}, headers: headers }
    
    it 'returns posts' do
      expect(json).not_to be_empty
      expect(json['data'].size).to eq(10)
    end
    
    it 'returns status code 200' do
      expect(response).to have_http_status(200)
    end
    
    context 'with pagination' do
      before do
        get '/api/v1/posts', params: { page: 2, per_page: 5 }, headers: headers
      end
      
      it 'returns paginated results' do
        expect(json['data'].size).to eq(5)
        expect(json['meta']['current_page']).to eq(2)
      end
    end
    
    context 'with filters' do
      let!(:user_posts) { create_list(:post, 3, user: user, published: true) }
      
      before do
        get '/api/v1/posts', params: { user_id: user.id }, headers: headers
      end
      
      it 'returns filtered posts' do
        expect(json['data'].size).to eq(3)
        expect(json['data'].all? { |p| p['user_id'] == user.id }).to be true
      end
    end
  end
  
  describe 'POST /api/v1/posts' do
    let(:valid_attributes) do
      { post: { title: 'Test Post', content: 'Test content', published: true } }
    end
    
    context 'when the request is valid' do
      before { post '/api/v1/posts', params: valid_attributes, headers: headers }
      
      it 'creates a post' do
        expect(json['data']['title']).to eq('Test Post')
      end
      
      it 'returns status code 201' do
        expect(response).to have_http_status(201)
      end
    end
    
    context 'when the request is invalid' do
      let(:invalid_attributes) { { post: { title: '' } } }
      
      before { post '/api/v1/posts', params: invalid_attributes, headers: headers }
      
      it 'returns status code 422' do
        expect(response).to have_http_status(422)
      end
      
      it 'returns a validation failure message' do
        expect(json['errors']).to include("Title can't be blank")
      end
    end
  end
  
  describe 'PUT /api/v1/posts/:id' do
    let(:post_record) { create(:post, user: user) }
    let(:valid_attributes) { { post: { title: 'Updated Title' } } }
    
    before do
      put "/api/v1/posts/#{post_record.id}", 
          params: valid_attributes, 
          headers: headers
    end
    
    context 'when the record exists' do
      it 'updates the record' do
        expect(json['data']['title']).to eq('Updated Title')
      end
      
      it 'returns status code 200' do
        expect(response).to have_http_status(200)
      end
    end
    
    context 'when user is not the owner' do
      let(:other_user) { create(:user) }
      let(:headers) { auth_headers(other_user) }
      
      it 'returns status code 403' do
        expect(response).to have_http_status(403)
      end
    end
  end
  
  describe 'DELETE /api/v1/posts/:id' do
    let!(:post_record) { create(:post, user: user) }
    
    before { delete "/api/v1/posts/#{post_record.id}", headers: headers }
    
    it 'returns status code 204' do
      expect(response).to have_http_status(204)
    end
    
    it 'deletes the record' do
      expect(Post.find_by(id: post_record.id)).to be_nil
    end
  end
end

# spec/integration/api_integration_spec.rb
RSpec.describe 'API Integration', type: :request do
  describe 'complete user flow' do
    it 'allows user registration, login, and resource creation' do
      # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
      post '/api/v1/auth/register', params: {
        email: 'test@example.com',
        password: 'password123',
        name: 'Test User'
      }
      
      expect(response).to have_http_status(201)
      token = json['token']
      
      # ãƒ­ã‚°ã‚¤ãƒ³
      post '/api/v1/auth/login', params: {
        email: 'test@example.com',
        password: 'password123'
      }
      
      expect(response).to have_http_status(200)
      expect(json['token']).to be_present
      
      # ãƒªã‚½ãƒ¼ã‚¹ä½œæˆ
      post '/api/v1/posts', 
           params: { post: { title: 'Test', content: 'Content' } },
           headers: { 'Authorization' => "Bearer #{token}" }
      
      expect(response).to have_http_status(201)
      expect(json['data']['title']).to eq('Test')
    end
  end
end
</code></pre>
<h2 id="ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–</h2>
<h3 id="api-ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹">API ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹</h3>
<pre><code class="language-ruby"># config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins ENV.fetch('ALLOWED_ORIGINS', '*').split(',')
    
    resource '*',
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete, :options, :head],
      credentials: true,
      max_age: 86400
  end
end

# app/controllers/application_controller.rb
class ApplicationController &#x3C; ActionController::API
  # Rate limiting
  include Rack::Attack
  
  # SQL Injectionå¯¾ç­–ã¯æ¨™æº–ã®Active Recordãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
  # XSSå¯¾ç­–ã¯APIãƒ¢ãƒ¼ãƒ‰ã§ã¯åŸºæœ¬çš„ã«ä¸è¦ï¼ˆJSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãŸã‚ï¼‰
  
  # CSRFå¯¾ç­–ï¼ˆAPIã§ã¯é€šå¸¸ä¸è¦ã ãŒã€Cookieèªè¨¼ã®å ´åˆã¯å¿…è¦ï¼‰
  # protect_from_forgery with: :null_session
  
  # Strong Parameters
  before_action :configure_permitted_parameters, if: :devise_controller?
  
  # APIã‚­ãƒ¼èªè¨¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  before_action :authenticate_api_key!, if: :api_key_required?
  
  private
  
  def authenticate_api_key!
    api_key = request.headers['X-API-Key']
    
    unless api_key &#x26;&#x26; ApiKey.active.exists?(key: api_key)
      render json: { error: 'Invalid API key' }, status: :unauthorized
    end
  end
  
  def api_key_required?
    # ç‰¹å®šã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§APIã‚­ãƒ¼ã‚’è¦æ±‚
    request.path.start_with?('/api/admin')
  end
end

# config/initializers/rack_attack.rb
class Rack::Attack
  # Rate limiting
  throttle('api/ip', limit: 100, period: 5.minutes) do |req|
    req.ip if req.path.start_with?('/api')
  end
  
  # ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã®åˆ¶é™
  throttle('logins/ip', limit: 5, period: 20.seconds) do |req|
    if req.path == '/api/v1/auth/login' &#x26;&#x26; req.post?
      req.ip
    end
  end
  
  # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã®åˆ¶é™
  throttle('api/user', limit: 1000, period: 1.hour) do |req|
    if req.env['HTTP_AUTHORIZATION']
      token = req.env['HTTP_AUTHORIZATION'].split(' ').last
      decoded = JsonWebToken.decode(token) rescue nil
      decoded[:user_id] if decoded
    end
  end
  
  # Blockãƒ«ãƒ¼ãƒ«
  blocklist('block suspicious requests') do |req|
    # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
    Rack::Attack::Fail2Ban.filter("pentesters-#{req.ip}", maxretry: 3, findtime: 10.minutes, bantime: 30.minutes) do
      CGI.unescape(req.query_string) =~ /(%27|')|(%3B|;)|(&#x3C;|%3C)|(>|%3E)/i
    end
  end
end

# app/services/security_audit_service.rb
class SecurityAuditService
  def self.audit_request(request, user = nil)
    AuditLog.create!(
      user: user,
      action: "#{request.method} #{request.path}",
      ip_address: request.remote_ip,
      user_agent: request.user_agent,
      parameters: filter_sensitive_params(request.params),
      performed_at: Time.current
    )
  end
  
  private
  
  def self.filter_sensitive_params(params)
    Rails.application.config.filter_parameters.each do |param|
      params = params.deep_transform_values do |value|
        value.to_s.include?(param.to_s) ? '[FILTERED]' : value
      end
    end
    params
  end
end
</code></pre>
<h2 id="ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã¨ãƒ‡ãƒ—ãƒ­ã‚¤">ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã¨ãƒ‡ãƒ—ãƒ­ã‚¤</h2>
<h3 id="apiãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°æˆ¦ç•¥">APIãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°æˆ¦ç•¥</h3>
<pre><code class="language-ruby"># URLãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°
Rails.application.routes.draw do
  namespace :api do
    namespace :v1 do
      resources :posts
    end
    
    namespace :v2 do
      resources :posts do
        member do
          post :react
        end
      end
    end
  end
  
  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
  get 'api/posts', to: redirect('/api/v1/posts')
end

# ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°
class ApplicationController &#x3C; ActionController::API
  before_action :set_api_version
  
  private
  
  def set_api_version
    @api_version = request.headers['Accept-Version'] || 'v1'
    
    unless %w[v1 v2].include?(@api_version)
      render json: { error: 'Invalid API version' }, status: :bad_request
    end
  end
end

# app/controllers/api/posts_controller.rb
module Api
  class PostsController &#x3C; BaseController
    def index
      case @api_version
      when 'v1'
        render json: posts_v1
      when 'v2'
        render json: posts_v2
      end
    end
    
    private
    
    def posts_v1
      Post.all.as_json(only: [:id, :title, :content])
    end
    
    def posts_v2
      Post.all.as_json(
        only: [:id, :title, :content],
        methods: [:reactions_count, :views_count]
      )
    end
  end
end
</code></pre>
<h3 id="ãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š">ãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š</h3>
<pre><code class="language-ruby"># config/deploy.rb (Capistrano)
lock '~> 3.17.0'

set :application, 'my_api'
set :repo_url, 'git@github.com:username/my_api.git'
set :deploy_to, '/var/www/my_api'
set :rbenv_ruby, '3.2.0'

append :linked_files, 'config/database.yml', 'config/master.key'
append :linked_dirs, 'log', 'tmp/pids', 'tmp/cache', 'tmp/sockets', 'public/system'

namespace :deploy do
  desc 'Restart application'
  task :restart do
    on roles(:app), in: :sequence, wait: 5 do
      execute :touch, release_path.join('tmp/restart.txt')
    end
  end
  
  after :publishing, :restart
end

# docker-compose.yml
version: '3.8'
services:
  db:
    image: postgres:14
    environment:
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    command: redis-server
    volumes:
      - redis_data:/data
  
  web:
    build: .
    command: bundle exec puma -C config/puma.rb
    volumes:
      - .:/app
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
    environment:
      DATABASE_URL: postgresql://postgres:password@db/my_api_production
      REDIS_URL: redis://redis:6379/0
  
  sidekiq:
    build: .
    command: bundle exec sidekiq
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    environment:
      DATABASE_URL: postgresql://postgres:password@db/my_api_production
      REDIS_URL: redis://redis:6379/0

volumes:
  postgres_data:
  redis_data:

# Dockerfile
FROM ruby:3.2.0
RUN apt-get update -qq &#x26;&#x26; apt-get install -y postgresql-client
WORKDIR /app
COPY Gemfile* ./
RUN bundle install
COPY . .
EXPOSE 3000
CMD ["rails", "server", "-b", "0.0.0.0"]
</code></pre>
<h2 id="ã¾ã¨ã‚">ã¾ã¨ã‚</h2>
<h3 id="rails-apié–‹ç™ºãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ">Rails APIé–‹ç™ºãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ</h3>
<p><strong>è¨­è¨ˆ</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> RESTfulåŸå‰‡ã«å¾“ã£ãŸURLè¨­è¨ˆ</li>
<li class="task-list-item"><input type="checkbox" disabled> é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®ä½¿ç”¨</li>
<li class="task-list-item"><input type="checkbox" disabled> ä¸€è²«æ€§ã®ã‚ã‚‹ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</li>
<li class="task-list-item"><input type="checkbox" disabled> ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å®Ÿè£…</li>
</ul>
<p><strong>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> N+1å•é¡Œã®è§£æ±ºï¼ˆincludes, eager_loadï¼‰</li>
<li class="task-list-item"><input type="checkbox" disabled> é©åˆ‡ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¨­å®š</li>
<li class="task-list-item"><input type="checkbox" disabled> ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥ã®å®Ÿè£…</li>
<li class="task-list-item"><input type="checkbox" disabled> ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–ã®æ´»ç”¨</li>
</ul>
<p><strong>ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> èªè¨¼ãƒ»èªå¯ã®å®Ÿè£…</li>
<li class="task-list-item"><input type="checkbox" disabled> Rate limitingã®è¨­å®š</li>
<li class="task-list-item"><input type="checkbox" disabled> CORSè¨­å®š</li>
<li class="task-list-item"><input type="checkbox" disabled> SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–</li>
</ul>
<p><strong>ãƒ†ã‚¹ãƒˆ</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> Request specã®ä½œæˆ</li>
<li class="task-list-item"><input type="checkbox" disabled> çµ±åˆãƒ†ã‚¹ãƒˆã®å®Ÿè£…</li>
<li class="task-list-item"><input type="checkbox" disabled> ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ</li>
<li class="task-list-item"><input type="checkbox" disabled> ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ</li>
</ul>
<h3 id="é¢æ¥ã§ã®å›ç­”ä¾‹">é¢æ¥ã§ã®å›ç­”ä¾‹</h3>
<p><strong>Q: Rails APIãƒ¢ãƒ¼ãƒ‰ã®åˆ©ç‚¹ã¯ï¼Ÿ</strong></p>
<pre><code>A: Rails APIãƒ¢ãƒ¼ãƒ‰ã¯é€šå¸¸ã®Railsã‹ã‚‰ä¸è¦ãªæ©Ÿèƒ½ã‚’å‰Šé™¤ã—ã€
APIé–‹ç™ºã«æœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚

ä¸»ãªåˆ©ç‚¹ï¼š
1. è»½é‡åŒ–ï¼šãƒ“ãƒ¥ãƒ¼å±¤ã‚„ã‚¢ã‚»ãƒƒãƒˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’é™¤å¤–
2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼šãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å‰Šæ¸›ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹é€Ÿåº¦å‘ä¸Š
3. ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æœ€é©åŒ–ï¼šAPIç”¨ã«æœ€é©åŒ–ã•ã‚ŒãŸæ§‹æˆ

å®Ÿè£…é¢ã§ã¯ã€ApplicationControllerãŒActionController::APIã‚’
ç¶™æ‰¿ã—ã€JSONãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«ç‰¹åŒ–ã—ãŸè¨­å®šã«ãªã£ã¦ã„ã¾ã™ã€‚
</code></pre>
<p><strong>Q: N+1å•é¡Œã‚’ã©ã†è§£æ±ºã—ã¾ã™ã‹ï¼Ÿ</strong></p>
<pre><code>A: N+1å•é¡Œã¯ä¸»ã«3ã¤ã®æ–¹æ³•ã§è§£æ±ºã—ã¾ã™ï¼š

1. includesï¼šé–¢é€£ãƒ‡ãƒ¼ã‚¿ã‚’äº‹å‰èª­ã¿è¾¼ã¿
   Post.includes(:comments, :user)

2. eager_loadï¼šLEFT JOINã§ä¸€åº¦ã«å–å¾—
   Post.eager_load(:comments).where(comments: { approved: true })

3. ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼šé›†è¨ˆå€¤ã‚’ã‚«ãƒ©ãƒ ã«ä¿å­˜
   has_many :comments, counter_cache: true

é–‹ç™ºç’°å¢ƒã§ã¯Bullet gemã§æ¤œå‡ºã—ã€
æœ¬ç•ªç’°å¢ƒã§ã¯New Relicã‚„Datadogã§ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚
</code></pre>
<h3 id="ç¶™ç¶šçš„ãªå­¦ç¿’ã®ãŸã‚ã«">ç¶™ç¶šçš„ãªå­¦ç¿’ã®ãŸã‚ã«</h3>
<ol>
<li><strong>å®Ÿè·µãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</strong>: å®Ÿéš›ã®APIã‚’æ§‹ç¯‰</li>
<li><strong>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š</strong>: Apache Benchã€JMeterã§ã®è² è·ãƒ†ã‚¹ãƒˆ</li>
<li><strong>æœ€æ–°å‹•å‘</strong>: Rails 7.1ã®æ–°æ©Ÿèƒ½ã€Hotwire Turbo</li>
<li><strong>ä»–è¨€èªã¨ã®æ¯”è¼ƒ</strong>: Goã€Node.jsã®APIé–‹ç™ºã‚‚å­¦ç¿’</li>
</ol>
<h2 id="å‚è€ƒãƒªãƒ³ã‚¯">å‚è€ƒãƒªãƒ³ã‚¯</h2>
<ul>
<li><a href="https://guides.rubyonrails.org/api_app.html">Ruby on Rails Guides</a></li>
<li><a href="https://jsonapi.org/">JSON:API Specification</a></li>
<li><a href="https://graphql-ruby.org/">GraphQL Ruby</a></li>
<li><a href="https://www.speedshop.co/">Rails Performance</a></li>
<li><a href="https://guides.rubyonrails.org/security.html">Rails Security Guide</a></li>
</ul>
<hr>
<p><em>ã“ã®è¨˜äº‹ã¯ã€Ruby on Rails APIé–‹ç™ºã«ãŠã‘ã‚‹3å¹´ä»¥ä¸Šã®å®Ÿå‹™çµŒé¨“ã§å¿…è¦ãªçŸ¥è­˜ã‚’ç¶²ç¾…çš„ã«ã¾ã¨ã‚ã¾ã—ãŸã€‚</em></p></article><nav class="mt-8 pt-4 border-t border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">â† ãƒ›ãƒ¼ãƒ ã¸</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">è¨˜äº‹ä¸€è¦§ã¸ â†’</a></nav></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-aa7deb192a774533.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[87555,[],\"\"]\n3:I[31295,[],\"\"]\n5:I[59665,[],\"MetadataBoundary\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[26614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/19bdf9af4d1ae4d4.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"JSnVZeqt76ScGbbxQqRWu\",\"p\":\"\",\"c\":[\"\",\"blog\",\"rails-api-development-complete-guide\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"rails-api-development-complete-guide\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/19bdf9af4d1ae4d4.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png\",\"type\":\"image/png\"}]}],[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"rails-api-development-complete-guide\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[\"$\",\"$L5\",null,{\"children\":\"$L6\"}],null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"I6gu-AUKXMbbRq77GYUhV\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:\"$Sreact.suspense\"\n10:I[74911,[],\"AsyncMetadata\"]\n6:[\"$\",\"$f\",null,{\"fallback\":null,\"children\":[\"$\",\"$L10\",null,{\"promise\":\"$@11\"}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"12:I[6874,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"\"]\n14:I[31203,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"default\"]\n15:I[4197,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"default\"]\n13:Td8eb,"])</script><script>self.__next_f.push([1,"\u003cp\u003eRuby on Railsé–‹ç™ºçµŒé¨“3å¹´ä»¥ä¸Šã‚’æ±‚ã‚ã‚‹æ±‚äººã§ã€ŒAPIé–‹ç™ºçµŒé¨“ã€ã¯å¿…é ˆè¦ä»¶ã§ã™ã€‚ã—ã‹ã—ã€å˜ã«ã€ŒRails APIãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ãˆã‚‹ã€ã ã‘ã§ã¯ä¸ååˆ†ã§ã™ã€‚æœ¬è¨˜äº‹ã§ã¯ã€RESTful APIè¨­è¨ˆã®åŸå‰‡ã‹ã‚‰ã€èªè¨¼ãƒ»èªå¯ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€GraphQLå®Ÿè£…ã¾ã§ã€å®Ÿå‹™ã§å¿…è¦ãªçŸ¥è­˜ã‚’ç¶²ç¾…çš„ã«è§£èª¬ã—ã¾ã™ã€‚\u003c/p\u003e\n\u003ch2 id=\"-åˆå¿ƒè€…å‘ã‘è§£èª¬\"\u003eğŸ’¡ åˆå¿ƒè€…å‘ã‘è§£èª¬\u003c/h2\u003e\n\u003ch3 id=\"apiã¨ã¯\"\u003eAPIã¨ã¯ï¼Ÿ\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eç°¡å˜ã«è¨€ã†ã¨\u003c/strong\u003e: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åŒå£«ãŒä¼šè©±ã™ã‚‹ãŸã‚ã®çª“å£ã§ã™ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eä¾‹ï¼šãƒ¬ã‚¹ãƒˆãƒ©ãƒ³ã®æ³¨æ–‡ã‚·ã‚¹ãƒ†ãƒ \nWebã‚µã‚¤ãƒˆ/ã‚¢ãƒ—ãƒªï¼šãŠå®¢æ§˜ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼‰\nAPIï¼šã‚¦ã‚§ã‚¤ã‚¿ãƒ¼ï¼ˆé€šä¿¡ã®ä»²ä»‹ï¼‰\nRailsï¼šå¨æˆ¿ï¼ˆãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼‰\nãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼šé£Ÿæåº«\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ãªãœrails-apiãŒé¸ã°ã‚Œã‚‹ã®ã‹\"\u003eãªãœRails APIãŒé¸ã°ã‚Œã‚‹ã®ã‹ï¼Ÿ\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eé–‹ç™ºé€Ÿåº¦\u003c/strong\u003e: è¦ç´„é‡è¦–ã§é«˜é€Ÿé–‹ç™ºãŒå¯èƒ½\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eæˆç†Ÿåº¦\u003c/strong\u003e: è±Šå¯ŒãªGemã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£\u003c/strong\u003e: å¤§è¦æ¨¡ã‚µãƒ¼ãƒ“ã‚¹ã§ã®å®Ÿç¸¾\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§\u003c/strong\u003e: Railsã®è¦ç´„ã«ã‚ˆã‚‹çµ±ä¸€æ€§\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"-ç›®æ¬¡\"\u003eğŸ“š ç›®æ¬¡\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#rails-api%E5%9F%BA%E7%A4%8E\"\u003eRails APIåŸºç¤\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#restful-api%E8%A8%AD%E8%A8%88\"\u003eRESTful APIè¨­è¨ˆ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF%E3%81%AE%E5%AE%9F%E8%A3%85\"\u003eèªè¨¼ãƒ»èªå¯ã®å®Ÿè£…\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B9%E8%A8%AD%E8%A8%88\"\u003eã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%9C%80%E9%81%A9%E5%8C%96\"\u003eãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#graphql%E5%AE%9F%E8%A3%85\"\u003eGraphQLå®Ÿè£…\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%86%E3%82%B9%E3%83%88%E6%88%A6%E7%95%A5\"\u003eãƒ†ã‚¹ãƒˆæˆ¦ç•¥\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E5%AF%BE%E7%AD%96\"\u003eã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4\"\u003eãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã¨ãƒ‡ãƒ—ãƒ­ã‚¤\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"rails-apiåŸºç¤\"\u003eRails APIåŸºç¤\u003c/h2\u003e\n\u003ch3 id=\"rails-apiãƒ¢ãƒ¼ãƒ‰ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—\"\u003eRails APIãƒ¢ãƒ¼ãƒ‰ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# APIãƒ¢ãƒ¼ãƒ‰ã§Railsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ\nrails new my_api --api --database=postgresql\n\n# ä¸»ãªé•ã„ï¼š\n# - ApplicationControllerãŒActionController::APIã‚’ç¶™æ‰¿\n# - ãƒ“ãƒ¥ãƒ¼å±¤ã€ã‚¢ã‚»ãƒƒãƒˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³é–¢é€£ãŒé™¤å¤–\n# - CORSã‚„JSONãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«æœ€é©åŒ–\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"åŸºæœ¬çš„ãªapiã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼\"\u003eåŸºæœ¬çš„ãªAPIã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/api/v1/base_controller.rb\nmodule Api\n  module V1\n    class BaseController \u0026#x3C; ApplicationController\n      # å…±é€šã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°\n      rescue_from ActiveRecord::RecordNotFound, with: :not_found\n      rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity\n      rescue_from ActionController::ParameterMissing, with: :bad_request\n\n      private\n\n      def not_found(exception)\n        render json: { \n          error: {\n            message: exception.message,\n            type: 'ResourceNotFound'\n          }\n        }, status: :not_found\n      end\n\n      def unprocessable_entity(exception)\n        render json: { \n          error: {\n            message: exception.record.errors.full_messages.join(', '),\n            type: 'ValidationError',\n            details: exception.record.errors.details\n          }\n        }, status: :unprocessable_entity\n      end\n\n      def bad_request(exception)\n        render json: { \n          error: {\n            message: exception.message,\n            type: 'BadRequest'\n          }\n        }, status: :bad_request\n      end\n\n      # ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ¡ã‚½ãƒƒãƒ‰\n      def paginate(resource)\n        resource.page(params[:page] || 1).per(params[:per_page] || 20)\n      end\n\n      # ãƒ¡ã‚¿æƒ…å ±ã®è¿½åŠ \n      def render_with_meta(resource, options = {})\n        if resource.respond_to?(:current_page)\n          options[:meta] = pagination_meta(resource)\n        end\n        render json: resource, **options\n      end\n\n      def pagination_meta(resource)\n        {\n          current_page: resource.current_page,\n          total_pages: resource.total_pages,\n          total_count: resource.total_count,\n          per_page: resource.limit_value\n        }\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"serializerã®å®Ÿè£…activemodelserializers\"\u003eSerializerã®å®Ÿè£…ï¼ˆActiveModel::Serializersï¼‰\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'active_model_serializers', '~\u003e 0.10.0'\n\n# app/serializers/api/v1/user_serializer.rb\nmodule Api\n  module V1\n    class UserSerializer \u0026#x3C; ActiveModel::Serializer\n      attributes :id, :email, :name, :avatar_url, :created_at\n      \n      # é–¢é€£ã®å®šç¾©\n      has_many :posts\n      has_one :profile\n      \n      # ã‚«ã‚¹ã‚¿ãƒ å±æ€§\n      attribute :full_name do\n        \"#{object.first_name} #{object.last_name}\"\n      end\n      \n      # æ¡ä»¶ä»˜ãå±æ€§\n      attribute :admin_info, if: :is_admin?\n      \n      def admin_info\n        {\n          last_login: object.last_login_at,\n          permissions: object.permissions\n        }\n      end\n      \n      def is_admin?\n        scope \u0026#x26;\u0026#x26; scope.admin?\n      end\n      \n      # URLãƒ˜ãƒ«ãƒ‘ãƒ¼ã®ä½¿ç”¨\n      link(:self) { api_v1_user_url(object) }\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"restful-apiè¨­è¨ˆ\"\u003eRESTful APIè¨­è¨ˆ\u003c/h2\u003e\n\u003ch3 id=\"ãƒªã‚½ãƒ¼ã‚¹ãƒ™ãƒ¼ã‚¹ã®urlè¨­è¨ˆ\"\u003eãƒªã‚½ãƒ¼ã‚¹ãƒ™ãƒ¼ã‚¹ã®URLè¨­è¨ˆ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/routes.rb\nRails.application.routes.draw do\n  namespace :api do\n    namespace :v1 do\n      # ãƒªã‚½ãƒ¼ã‚¹ãƒ•ãƒ«ãªãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°\n      resources :users do\n        member do\n          post :activate\n          post :deactivate\n        end\n        \n        collection do\n          get :search\n          get :export\n        end\n        \n        # ãƒã‚¹ãƒˆã—ãŸãƒªã‚½ãƒ¼ã‚¹\n        resources :posts, shallow: true do\n          resources :comments\n          resources :likes, only: [:create, :destroy]\n        end\n      end\n      \n      # ã‚«ã‚¹ã‚¿ãƒ ãƒ«ãƒ¼ãƒˆ\n      post 'auth/login', to: 'authentication#login'\n      post 'auth/logout', to: 'authentication#logout'\n      post 'auth/refresh', to: 'authentication#refresh'\n      \n      # æ¤œç´¢ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ\n      namespace :search do\n        get 'users', to: 'users#index'\n        get 'posts', to: 'posts#index'\n        get 'global', to: 'global#index'\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"httpã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®é©åˆ‡ãªä½¿ç”¨\"\u003eHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®é©åˆ‡ãªä½¿ç”¨\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/api/v1/posts_controller.rb\nmodule Api\n  module V1\n    class PostsController \u0026#x3C; BaseController\n      before_action :authenticate_user!\n      before_action :set_post, only: [:show, :update, :destroy]\n      before_action :authorize_user!, only: [:update, :destroy]\n\n      # GET /api/v1/posts\n      def index\n        posts = Post.published\n                   .includes(:user, :tags, :comments)\n                   .search(params[:q])\n                   .filter_by_tags(params[:tags])\n                   .order(created_at: :desc)\n        \n        posts = paginate(posts)\n        \n        render_with_meta(\n          posts,\n          each_serializer: PostSerializer,\n          include: ['user', 'tags']\n        )\n      end\n\n      # GET /api/v1/posts/:id\n      def show\n        render json: @post, \n               serializer: PostDetailSerializer,\n               include: ['user', 'comments', 'comments.user']\n      end\n\n      # POST /api/v1/posts\n      def create\n        post = current_user.posts.build(post_params)\n        \n        if post.save\n          # 201 Created\n          render json: post, \n                 serializer: PostSerializer,\n                 status: :created,\n                 location: api_v1_post_url(post)\n        else\n          # 422 Unprocessable Entity\n          render json: { \n            errors: post.errors.full_messages,\n            details: post.errors.details \n          }, status: :unprocessable_entity\n        end\n      end\n\n      # PATCH/PUT /api/v1/posts/:id\n      def update\n        if @post.update(post_params)\n          # 200 OK\n          render json: @post, serializer: PostSerializer\n        else\n          # 422 Unprocessable Entity\n          render json: { \n            errors: @post.errors.full_messages \n          }, status: :unprocessable_entity\n        end\n      end\n\n      # DELETE /api/v1/posts/:id\n      def destroy\n        @post.destroy\n        # 204 No Content\n        head :no_content\n      end\n\n      private\n\n      def set_post\n        @post = Post.find(params[:id])\n      end\n\n      def authorize_user!\n        # 403 Forbidden\n        unless @post.user == current_user || current_user.admin?\n          render json: { \n            error: 'You are not authorized to perform this action' \n          }, status: :forbidden\n        end\n      end\n\n      def post_params\n        params.require(:post).permit(\n          :title, \n          :content, \n          :published, \n          tag_ids: [],\n          images_attributes: [:id, :url, :caption, :_destroy]\n        )\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆ\"\u003eãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/models/concerns/filterable.rb\nmodule Filterable\n  extend ActiveSupport::Concern\n\n  module ClassMethods\n    def filter(filtering_params)\n      results = self.where(nil)\n      filtering_params.each do |key, value|\n        results = results.public_send(\"filter_by_#{key}\", value) if value.present?\n      end\n      results\n    end\n  end\nend\n\n# app/models/post.rb\nclass Post \u0026#x3C; ApplicationRecord\n  include Filterable\n  \n  belongs_to :user\n  has_many :comments, dependent: :destroy\n  has_and_belongs_to_many :tags\n  \n  # ã‚¹ã‚³ãƒ¼ãƒ—å®šç¾©\n  scope :published, -\u003e { where(published: true) }\n  scope :draft, -\u003e { where(published: false) }\n  scope :recent, -\u003e { where('created_at \u003e ?', 1.week.ago) }\n  \n  # ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ç”¨ã‚¹ã‚³ãƒ¼ãƒ—\n  scope :filter_by_status, -\u003e(status) { \n    case status\n    when 'published' then published\n    when 'draft' then draft\n    else all\n    end\n  }\n  \n  scope :filter_by_user_id, -\u003e(user_id) { where(user_id: user_id) }\n  \n  scope :filter_by_tags, -\u003e(tag_names) {\n    joins(:tags).where(tags: { name: tag_names })\n  }\n  \n  scope :filter_by_date_range, -\u003e(from, to) {\n    where(created_at: from..to)\n  }\n  \n  # å…¨æ–‡æ¤œç´¢\n  scope :search, -\u003e(query) {\n    return all if query.blank?\n    \n    where('title ILIKE :q OR content ILIKE :q', q: \"%#{query}%\")\n  }\n  \n  # ã‚½ãƒ¼ãƒˆ\n  scope :sort_by_field, -\u003e(field, direction = 'asc') {\n    safe_fields = %w[created_at updated_at title views_count]\n    safe_directions = %w[asc desc]\n    \n    field = 'created_at' unless safe_fields.include?(field)\n    direction = 'desc' unless safe_directions.include?(direction)\n    \n    order(field =\u003e direction)\n  }\nend\n\n# ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã®ä½¿ç”¨\ndef index\n  posts = Post.filter(\n    status: params[:status],\n    user_id: params[:user_id],\n    tags: params[:tags]\n  ).sort_by_field(params[:sort], params[:direction])\n  \n  render json: paginate(posts)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"èªè¨¼èªå¯ã®å®Ÿè£…\"\u003eèªè¨¼ãƒ»èªå¯ã®å®Ÿè£…\u003c/h2\u003e\n\u003ch3 id=\"jwtèªè¨¼ã®å®Ÿè£…\"\u003eJWTèªè¨¼ã®å®Ÿè£…\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'jwt'\ngem 'bcrypt'\n\n# app/lib/json_web_token.rb\nclass JsonWebToken\n  SECRET_KEY = Rails.application.credentials.secret_key_base || Rails.application.secrets.secret_key_base\n  \n  def self.encode(payload, exp = 24.hours.from_now)\n    payload[:exp] = exp.to_i\n    JWT.encode(payload, SECRET_KEY, 'HS256')\n  end\n  \n  def self.decode(token)\n    decoded = JWT.decode(token, SECRET_KEY, true, algorithm: 'HS256')[0]\n    HashWithIndifferentAccess.new(decoded)\n  rescue JWT::DecodeError =\u003e e\n    raise ExceptionHandler::InvalidToken, e.message\n  end\nend\n\n# app/controllers/concerns/exception_handler.rb\nmodule ExceptionHandler\n  extend ActiveSupport::Concern\n  \n  class AuthenticationError \u0026#x3C; StandardError; end\n  class InvalidToken \u0026#x3C; StandardError; end\n  class MissingToken \u0026#x3C; StandardError; end\n  class ExpiredToken \u0026#x3C; StandardError; end\n  \n  included do\n    rescue_from ExceptionHandler::AuthenticationError, with: :unauthorized_request\n    rescue_from ExceptionHandler::InvalidToken, with: :unauthorized_request\n    rescue_from ExceptionHandler::MissingToken, with: :unauthorized_request\n    rescue_from ExceptionHandler::ExpiredToken, with: :unauthorized_request\n  end\n  \n  private\n  \n  def unauthorized_request(e)\n    render json: { error: e.message }, status: :unauthorized\n  end\nend\n\n# app/controllers/concerns/authenticable.rb\nmodule Authenticable\n  extend ActiveSupport::Concern\n  \n  included do\n    before_action :authenticate_request\n    attr_reader :current_user\n  end\n  \n  private\n  \n  def authenticate_request\n    @current_user = AuthorizeApiRequest.new(request.headers).call\n  rescue StandardError =\u003e e\n    render json: { error: e.message }, status: :unauthorized\n  end\n  \n  def authenticate_user!\n    authenticate_request\n  end\nend\n\n# app/services/authorize_api_request.rb\nclass AuthorizeApiRequest\n  def initialize(headers = {})\n    @headers = headers\n  end\n  \n  def call\n    user\n  end\n  \n  private\n  \n  attr_reader :headers\n  \n  def user\n    @user ||= User.find(decoded_auth_token[:user_id]) if decoded_auth_token\n  rescue ActiveRecord::RecordNotFound =\u003e e\n    raise ExceptionHandler::InvalidToken, \"Invalid token: #{e.message}\"\n  end\n  \n  def decoded_auth_token\n    @decoded_auth_token ||= JsonWebToken.decode(http_auth_header)\n  end\n  \n  def http_auth_header\n    if headers['Authorization'].present?\n      return headers['Authorization'].split(' ').last\n    end\n    raise ExceptionHandler::MissingToken, 'Missing token'\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"èªè¨¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼\"\u003eèªè¨¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/api/v1/authentication_controller.rb\nmodule Api\n  module V1\n    class AuthenticationController \u0026#x3C; BaseController\n      skip_before_action :authenticate_user!, only: [:login, :register]\n      \n      # POST /api/v1/auth/register\n      def register\n        user = User.new(user_params)\n        \n        if user.save\n          token = generate_token(user)\n          render json: {\n            user: UserSerializer.new(user),\n            token: token,\n            expires_at: 24.hours.from_now\n          }, status: :created\n        else\n          render json: { \n            errors: user.errors.full_messages \n          }, status: :unprocessable_entity\n        end\n      end\n      \n      # POST /api/v1/auth/login\n      def login\n        user = User.find_by(email: params[:email])\n        \n        if user\u0026#x26;.authenticate(params[:password])\n          token = generate_token(user)\n          \n          # ãƒ­ã‚°ã‚¤ãƒ³å±¥æ­´ã®è¨˜éŒ²\n          user.update(\n            last_login_at: Time.current,\n            last_login_ip: request.remote_ip\n          )\n          \n          render json: {\n            user: UserSerializer.new(user),\n            token: token,\n            expires_at: 24.hours.from_now\n          }\n        else\n          render json: { \n            error: 'Invalid email or password' \n          }, status: :unauthorized\n        end\n      end\n      \n      # POST /api/v1/auth/logout\n      def logout\n        # JWTã®å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‰Šé™¤\n        # ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã«è¿½åŠ \n        token = request.headers['Authorization']\u0026#x26;.split(' ')\u0026#x26;.last\n        BlacklistedToken.create(token: token, expires_at: 24.hours.from_now) if token\n        \n        head :no_content\n      end\n      \n      # POST /api/v1/auth/refresh\n      def refresh\n        # ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®å®Ÿè£…\n        refresh_token = params[:refresh_token]\n        \n        if valid_refresh_token?(refresh_token)\n          user = User.find_by(refresh_token: refresh_token)\n          new_token = generate_token(user)\n          \n          render json: {\n            token: new_token,\n            expires_at: 24.hours.from_now\n          }\n        else\n          render json: { \n            error: 'Invalid refresh token' \n          }, status: :unauthorized\n        end\n      end\n      \n      private\n      \n      def user_params\n        params.permit(:email, :password, :password_confirmation, :name)\n      end\n      \n      def generate_token(user)\n        JsonWebToken.encode(user_id: user.id)\n      end\n      \n      def valid_refresh_token?(token)\n        # ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯\n        return false if token.blank?\n        \n        user = User.find_by(refresh_token: token)\n        user \u0026#x26;\u0026#x26; user.refresh_token_expires_at \u003e Time.current\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"èªå¯punditä½¿ç”¨\"\u003eèªå¯ï¼ˆPunditä½¿ç”¨ï¼‰\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'pundit'\n\n# app/policies/application_policy.rb\nclass ApplicationPolicy\n  attr_reader :user, :record\n\n  def initialize(user, record)\n    @user = user\n    @record = record\n  end\n\n  def index?\n    true\n  end\n\n  def show?\n    true\n  end\n\n  def create?\n    user.present?\n  end\n\n  def update?\n    user.present? \u0026#x26;\u0026#x26; (record.user == user || user.admin?)\n  end\n\n  def destroy?\n    update?\n  end\n\n  class Scope\n    attr_reader :user, :scope\n\n    def initialize(user, scope)\n      @user = user\n      @scope = scope\n    end\n\n    def resolve\n      scope.all\n    end\n  end\nend\n\n# app/policies/post_policy.rb\nclass PostPolicy \u0026#x3C; ApplicationPolicy\n  def index?\n    true\n  end\n  \n  def show?\n    record.published? || record.user == user || user\u0026#x26;.admin?\n  end\n  \n  def create?\n    user.present?\n  end\n  \n  def update?\n    record.user == user || user\u0026#x26;.admin?\n  end\n  \n  def destroy?\n    record.user == user || user\u0026#x26;.admin?\n  end\n  \n  def publish?\n    record.user == user || user\u0026#x26;.admin?\n  end\n  \n  class Scope \u0026#x3C; Scope\n    def resolve\n      if user\u0026#x26;.admin?\n        scope.all\n      elsif user\n        scope.where('published = ? OR user_id = ?', true, user.id)\n      else\n        scope.published\n      end\n    end\n  end\nend\n\n# ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã®ä½¿ç”¨\nclass PostsController \u0026#x3C; BaseController\n  include Pundit\n  \n  def index\n    posts = policy_scope(Post)\n    render json: posts\n  end\n  \n  def show\n    post = Post.find(params[:id])\n    authorize post\n    render json: post\n  end\n  \n  def update\n    post = Post.find(params[:id])\n    authorize post\n    \n    if post.update(post_params)\n      render json: post\n    else\n      render json: { errors: post.errors }, status: :unprocessable_entity\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ\"\u003eã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ\u003c/h2\u003e\n\u003ch3 id=\"çµ±ä¸€çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹\"\u003eçµ±ä¸€çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/concerns/error_handler.rb\nmodule ErrorHandler\n  extend ActiveSupport::Concern\n  \n  included do\n    rescue_from StandardError, with: :handle_internal_server_error\n    rescue_from ActiveRecord::RecordNotFound, with: :handle_not_found\n    rescue_from ActiveRecord::RecordInvalid, with: :handle_unprocessable_entity\n    rescue_from ActionController::ParameterMissing, with: :handle_bad_request\n    rescue_from Pundit::NotAuthorizedError, with: :handle_forbidden\n    \n    # ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼\n    rescue_from CustomErrors::ValidationError, with: :handle_validation_error\n    rescue_from CustomErrors::AuthenticationError, with: :handle_authentication_error\n    rescue_from CustomErrors::RateLimitError, with: :handle_rate_limit\n  end\n  \n  private\n  \n  def handle_internal_server_error(exception)\n    logger.error exception.message\n    logger.error exception.backtrace.join(\"\\n\")\n    \n    if Rails.env.production?\n      render_error(500, 'Internal Server Error', 'An error occurred')\n    else\n      render_error(500, 'Internal Server Error', exception.message)\n    end\n  end\n  \n  def handle_not_found(exception)\n    render_error(404, 'Not Found', exception.message)\n  end\n  \n  def handle_unprocessable_entity(exception)\n    render_error(\n      422, \n      'Unprocessable Entity', \n      exception.record.errors.full_messages.join(', '),\n      exception.record.errors.details\n    )\n  end\n  \n  def handle_bad_request(exception)\n    render_error(400, 'Bad Request', exception.message)\n  end\n  \n  def handle_forbidden(exception)\n    render_error(403, 'Forbidden', 'You are not authorized to perform this action')\n  end\n  \n  def handle_validation_error(exception)\n    render_error(422, 'Validation Error', exception.message, exception.errors)\n  end\n  \n  def handle_authentication_error(exception)\n    render_error(401, 'Authentication Error', exception.message)\n  end\n  \n  def handle_rate_limit(exception)\n    response.headers['X-RateLimit-Limit'] = exception.limit.to_s\n    response.headers['X-RateLimit-Remaining'] = '0'\n    response.headers['X-RateLimit-Reset'] = exception.reset_at.to_i.to_s\n    \n    render_error(429, 'Too Many Requests', 'Rate limit exceeded')\n  end\n  \n  def render_error(status, error_type, message, details = nil)\n    error_response = {\n      error: {\n        status: status,\n        type: error_type,\n        message: message,\n        timestamp: Time.current.iso8601\n      }\n    }\n    \n    error_response[:error][:details] = details if details.present?\n    \n    render json: error_response, status: status\n  end\nend\n\n# app/lib/custom_errors.rb\nmodule CustomErrors\n  class BaseError \u0026#x3C; StandardError\n    attr_reader :status, :error_type, :details\n    \n    def initialize(message = nil, status = nil, error_type = nil, details = nil)\n      @status = status\n      @error_type = error_type\n      @details = details\n      super(message)\n    end\n  end\n  \n  class ValidationError \u0026#x3C; BaseError\n    def initialize(message = 'Validation failed', details = nil)\n      super(message, 422, 'ValidationError', details)\n    end\n  end\n  \n  class AuthenticationError \u0026#x3C; BaseError\n    def initialize(message = 'Authentication failed')\n      super(message, 401, 'AuthenticationError')\n    end\n  end\n  \n  class RateLimitError \u0026#x3C; BaseError\n    attr_reader :limit, :reset_at\n    \n    def initialize(limit, reset_at)\n      @limit = limit\n      @reset_at = reset_at\n      super('Rate limit exceeded', 429, 'RateLimitError')\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¨™æº–åŒ–\"\u003eãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¨™æº–åŒ–\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/services/response_builder.rb\nclass ResponseBuilder\n  def self.success(data = nil, message = nil, meta = {})\n    response = {\n      success: true,\n      timestamp: Time.current.iso8601\n    }\n    \n    response[:data] = data if data.present?\n    response[:message] = message if message.present?\n    response[:meta] = meta if meta.present?\n    \n    response\n  end\n  \n  def self.error(status, error_type, message, details = nil)\n    {\n      success: false,\n      error: {\n        status: status,\n        type: error_type,\n        message: message,\n        details: details\n      }.compact,\n      timestamp: Time.current.iso8601\n    }\n  end\n  \n  def self.paginated(collection, serializer, options = {})\n    {\n      success: true,\n      data: ActiveModelSerializers::SerializableResource.new(\n        collection,\n        each_serializer: serializer,\n        **options\n      ),\n      meta: {\n        pagination: {\n          current_page: collection.current_page,\n          total_pages: collection.total_pages,\n          total_count: collection.total_count,\n          per_page: collection.limit_value,\n          next_page: collection.next_page,\n          prev_page: collection.prev_page\n        }\n      },\n      timestamp: Time.current.iso8601\n    }\n  end\nend\n\n# ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã®ä½¿ç”¨\ndef index\n  posts = Post.published.page(params[:page])\n  render json: ResponseBuilder.paginated(posts, PostSerializer)\nend\n\ndef create\n  post = current_user.posts.build(post_params)\n  \n  if post.save\n    render json: ResponseBuilder.success(\n      PostSerializer.new(post),\n      'Post created successfully'\n    ), status: :created\n  else\n    render json: ResponseBuilder.error(\n      422,\n      'ValidationError',\n      'Validation failed',\n      post.errors.details\n    ), status: :unprocessable_entity\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–\"\u003eãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–\u003c/h2\u003e\n\u003ch3 id=\"n1å•é¡Œã®è§£æ±º\"\u003eN+1å•é¡Œã®è§£æ±º\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/models/post.rb\nclass Post \u0026#x3C; ApplicationRecord\n  belongs_to :user\n  has_many :comments\n  has_many :likes\n  has_and_belongs_to_many :tags\n  \n  # Bullet gemã«ã‚ˆã‚‹æ¤œå‡º\n  # Gemfile\n  # gem 'bullet', group: :development\n  \n  # ã‚¹ã‚³ãƒ¼ãƒ—ã§ã®includes\n  scope :with_associations, -\u003e {\n    includes(:user, :tags, comments: :user)\n  }\n  \n  # ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ä½¿ç”¨\n  # comments_count, likes_count ã‚«ãƒ©ãƒ ã‚’è¿½åŠ \n  has_many :comments, counter_cache: true\n  has_many :likes, counter_cache: true\nend\n\n# app/controllers/api/v1/posts_controller.rb\ndef index\n  # âŒ N+1å•é¡ŒãŒç™ºç”Ÿ\n  posts = Post.all\n  \n  # âœ… includesã§è§£æ±º\n  posts = Post.includes(:user, :tags, :comments)\n  \n  # âœ… ã‚ˆã‚Šè©³ç´°ãªæœ€é©åŒ–\n  posts = Post\n    .includes(:user, :tags)\n    .includes(comments: [:user, :likes])\n    .references(:comments)\n    .where('comments.created_at \u003e ?', 1.week.ago)\n  \n  render json: posts\nend\n\n# app/serializers/post_serializer.rb\nclass PostSerializer \u0026#x3C; ActiveModel::Serializer\n  attributes :id, :title, :content, :comments_count, :likes_count\n  \n  belongs_to :user\n  has_many :tags\n  \n  # ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨\n  def comments_count\n    object.comments_count # N+1ã‚’é¿ã‘ã‚‹\n  end\n  \n  def likes_count\n    object.likes_count # N+1ã‚’é¿ã‘ã‚‹\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥\"\u003eã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/environments/production.rb\nconfig.cache_store = :redis_cache_store, {\n  url: ENV['REDIS_URL'],\n  expires_in: 1.hour\n}\n\n# app/controllers/api/v1/posts_controller.rb\nclass PostsController \u0026#x3C; BaseController\n  def index\n    posts = Rails.cache.fetch(cache_key_for_posts, expires_in: 30.minutes) do\n      Post.published\n          .includes(:user, :tags)\n          .order(created_at: :desc)\n          .limit(100)\n          .to_a # é…åˆ—ã«å¤‰æ›ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥\n    end\n    \n    render json: posts\n  end\n  \n  def show\n    post = Rails.cache.fetch(\"post/#{params[:id]}\", expires_in: 1.hour) do\n      Post.includes(:user, :tags, comments: :user)\n          .find(params[:id])\n    end\n    \n    # ETagsä½¿ç”¨\n    if stale?(post)\n      render json: post, serializer: PostDetailSerializer\n    end\n  end\n  \n  private\n  \n  def cache_key_for_posts\n    \"posts/#{params[:page]}/#{params[:per_page]}/#{Post.maximum(:updated_at)}\"\n  end\nend\n\n# app/models/post.rb\nclass Post \u0026#x3C; ApplicationRecord\n  # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®è‡ªå‹•ç„¡åŠ¹åŒ–\n  after_commit :clear_cache\n  \n  private\n  \n  def clear_cache\n    Rails.cache.delete(\"post/#{id}\")\n    Rails.cache.delete_matched(\"posts/*\")\n  end\nend\n\n# Fragment Caching in Serializers\nclass PostSerializer \u0026#x3C; ActiveModel::Serializer\n  cache key: 'post', expires_in: 3.hours\n  \n  attributes :id, :title, :content\n  has_many :comments\n  \n  def cache_key\n    \"#{object.cache_key}/#{object.comments.maximum(:updated_at)}\"\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–\"\u003eãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/models/concerns/searchable.rb\nmodule Searchable\n  extend ActiveSupport::Concern\n  \n  included do\n    # PostgreSQLå…¨æ–‡æ¤œç´¢\n    scope :search, -\u003e(query) {\n      return all if query.blank?\n      \n      # tsvectorã‚«ãƒ©ãƒ ã‚’ä½¿ç”¨ï¼ˆãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§è¿½åŠ ï¼‰\n      where(\"search_vector @@ plainto_tsquery('english', ?)\", query)\n    }\n  end\nend\n\n# db/migrate/add_search_vector_to_posts.rb\nclass AddSearchVectorToPosts \u0026#x3C; ActiveRecord::Migration[7.0]\n  def up\n    # tsvectorã‚«ãƒ©ãƒ ã‚’è¿½åŠ \n    add_column :posts, :search_vector, :tsvector\n    \n    # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ \n    add_index :posts, :search_vector, using: :gin\n    \n    # ãƒˆãƒªã‚¬ãƒ¼ã‚’ä½œæˆ\n    execute \u0026#x3C;\u0026#x3C;-SQL\n      CREATE TRIGGER posts_search_vector_update\n      BEFORE INSERT OR UPDATE ON posts\n      FOR EACH ROW EXECUTE FUNCTION\n      tsvector_update_trigger(search_vector, 'pg_catalog.english', title, content);\n    SQL\n  end\n  \n  def down\n    remove_column :posts, :search_vector\n  end\nend\n\n# è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æ´»ç”¨\nclass AddCompoundIndexes \u0026#x3C; ActiveRecord::Migration[7.0]\n  def change\n    # ã‚ˆãä¸€ç·’ã«æ¤œç´¢ã•ã‚Œã‚‹æ¡ä»¶\n    add_index :posts, [:user_id, :published, :created_at]\n    add_index :posts, [:published, :created_at]\n    \n    # éƒ¨åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆæ¡ä»¶ä»˜ãã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰\n    add_index :posts, :created_at, where: \"published = true\", name: 'index_published_posts_on_created_at'\n  end\nend\n\n# ã‚¯ã‚¨ãƒªæœ€é©åŒ–\nclass Post \u0026#x3C; ApplicationRecord\n  # ãƒãƒƒãƒå‡¦ç†\n  def self.process_all\n    find_each(batch_size: 1000) do |post|\n      post.process\n    end\n  end\n  \n  # SELECTå¥ã®æœ€é©åŒ–\n  scope :minimal, -\u003e {\n    select(:id, :title, :created_at)\n  }\n  \n  # EXISTSä½¿ç”¨\n  scope :with_comments, -\u003e {\n    where('EXISTS (SELECT 1 FROM comments WHERE comments.post_id = posts.id)')\n  }\n  \n  # Windowé–¢æ•°ã®æ´»ç”¨\n  scope :ranked_by_likes, -\u003e {\n    select('posts.*, RANK() OVER (ORDER BY likes_count DESC) as rank')\n  }\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–\"\u003eãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'sidekiq'\ngem 'redis'\n\n# app/jobs/notification_job.rb\nclass NotificationJob \u0026#x3C; ApplicationJob\n  queue_as :default\n  \n  def perform(user_id, notification_type, data = {})\n    user = User.find(user_id)\n    \n    case notification_type\n    when 'new_comment'\n      NotificationService.send_new_comment_notification(user, data)\n    when 'new_like'\n      NotificationService.send_new_like_notification(user, data)\n    end\n  end\nend\n\n# app/controllers/api/v1/comments_controller.rb\ndef create\n  comment = @post.comments.build(comment_params)\n  comment.user = current_user\n  \n  if comment.save\n    # éåŒæœŸã§é€šçŸ¥ã‚’é€ä¿¡\n    NotificationJob.perform_later(\n      @post.user_id,\n      'new_comment',\n      { comment_id: comment.id }\n    )\n    \n    render json: comment, status: :created\n  else\n    render json: { errors: comment.errors }, status: :unprocessable_entity\n  end\nend\n\n# app/services/heavy_operation_service.rb\nclass HeavyOperationService\n  def self.process_async(data)\n    # Sidekiqã§éåŒæœŸå®Ÿè¡Œ\n    ProcessingWorker.perform_async(data)\n    \n    # ã‚¸ãƒ§ãƒ–IDã‚’è¿”ã™\n    { job_id: SecureRandom.uuid, status: 'processing' }\n  end\nend\n\n# app/workers/processing_worker.rb\nclass ProcessingWorker\n  include Sidekiq::Worker\n  \n  sidekiq_options retry: 3, dead: false\n  \n  def perform(data)\n    # é‡ã„å‡¦ç†\n    result = ComplexCalculation.new(data).execute\n    \n    # çµæœã‚’Redisã«ä¿å­˜\n    Rails.cache.write(\"processing_result_#{data['id']}\", result, expires_in: 1.day)\n    \n    # WebSocketã§é€šçŸ¥ï¼ˆAction Cableä½¿ç”¨ï¼‰\n    ActionCable.server.broadcast(\n      \"processing_#{data['user_id']}\",\n      { status: 'completed', result: result }\n    )\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"graphqlå®Ÿè£…\"\u003eGraphQLå®Ÿè£…\u003c/h2\u003e\n\u003ch3 id=\"graphqlåŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—\"\u003eGraphQLåŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'graphql'\ngem 'graphiql-rails', group: :development\n\n# app/graphql/types/base_object.rb\nmodule Types\n  class BaseObject \u0026#x3C; GraphQL::Schema::Object\n    edge_type_class(Types::BaseEdge)\n    connection_type_class(Types::BaseConnection)\n    field_class Types::BaseField\n  end\nend\n\n# app/graphql/types/user_type.rb\nmodule Types\n  class UserType \u0026#x3C; Types::BaseObject\n    field :id, ID, null: false\n    field :email, String, null: false\n    field :name, String, null: true\n    field :posts, [Types::PostType], null: true\n    field :created_at, GraphQL::Types::ISO8601DateTime, null: false\n    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false\n    \n    # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰\n    field :post_count, Integer, null: false\n    \n    def post_count\n      object.posts.count\n    end\n    \n    # èªè¨¼ãŒå¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰\n    field :private_info, String, null: true\n    \n    def private_info\n      return nil unless context[:current_user] == object\n      object.private_info\n    end\n  end\nend\n\n# app/graphql/types/post_type.rb\nmodule Types\n  class PostType \u0026#x3C; Types::BaseObject\n    field :id, ID, null: false\n    field :title, String, null: false\n    field :content, String, null: false\n    field :published, Boolean, null: false\n    field :user, Types::UserType, null: false\n    field :comments, [Types::CommentType], null: true\n    field :tags, [Types::TagType], null: true\n    field :created_at, GraphQL::Types::ISO8601DateTime, null: false\n  end\nend\n\n# app/graphql/types/query_type.rb\nmodule Types\n  class QueryType \u0026#x3C; Types::BaseObject\n    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§\n    field :users, [Types::UserType], null: false do\n      argument :limit, Integer, required: false, default_value: 20\n      argument :offset, Integer, required: false, default_value: 0\n    end\n    \n    def users(limit:, offset:)\n      User.limit(limit).offset(offset)\n    end\n    \n    # å˜ä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼\n    field :user, Types::UserType, null: true do\n      argument :id, ID, required: true\n    end\n    \n    def user(id:)\n      User.find_by(id: id)\n    end\n    \n    # æŠ•ç¨¿æ¤œç´¢\n    field :posts, Types::PostType.connection_type, null: false do\n      argument :filter, Types::PostFilterType, required: false\n      argument :order_by, Types::PostOrderType, required: false\n    end\n    \n    def posts(filter: nil, order_by: nil)\n      scope = Post.published\n      scope = apply_filter(scope, filter) if filter\n      scope = apply_order(scope, order_by) if order_by\n      scope\n    end\n    \n    private\n    \n    def apply_filter(scope, filter)\n      scope = scope.where(user_id: filter.user_id) if filter.user_id\n      scope = scope.search(filter.search) if filter.search\n      scope = scope.where('created_at \u003e= ?', filter.from_date) if filter.from_date\n      scope = scope.where('created_at \u0026#x3C;= ?', filter.to_date) if filter.to_date\n      scope\n    end\n    \n    def apply_order(scope, order_by)\n      case order_by\n      when 'CREATED_AT_ASC'\n        scope.order(created_at: :asc)\n      when 'CREATED_AT_DESC'\n        scope.order(created_at: :desc)\n      when 'TITLE_ASC'\n        scope.order(title: :asc)\n      else\n        scope\n      end\n    end\n  end\nend\n\n# app/graphql/types/mutation_type.rb\nmodule Types\n  class MutationType \u0026#x3C; Types::BaseObject\n    field :create_post, mutation: Mutations::CreatePost\n    field :update_post, mutation: Mutations::UpdatePost\n    field :delete_post, mutation: Mutations::DeletePost\n    field :login, mutation: Mutations::Login\n    field :register, mutation: Mutations::Register\n  end\nend\n\n# app/graphql/mutations/create_post.rb\nmodule Mutations\n  class CreatePost \u0026#x3C; BaseMutation\n    # å¼•æ•°ã®å®šç¾©\n    argument :title, String, required: true\n    argument :content, String, required: true\n    argument :published, Boolean, required: false, default_value: false\n    argument :tag_ids, [ID], required: false\n    \n    # æˆ»ã‚Šå€¤ã®å®šç¾©\n    field :post, Types::PostType, null: true\n    field :errors, [String], null: false\n    \n    def resolve(title:, content:, published:, tag_ids: [])\n      # èªè¨¼ãƒã‚§ãƒƒã‚¯\n      return { post: nil, errors: ['Not authenticated'] } unless context[:current_user]\n      \n      post = context[:current_user].posts.build(\n        title: title,\n        content: content,\n        published: published\n      )\n      \n      post.tag_ids = tag_ids if tag_ids.present?\n      \n      if post.save\n        { post: post, errors: [] }\n      else\n        { post: nil, errors: post.errors.full_messages }\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"graphqlèªè¨¼ã¨n1å¯¾ç­–\"\u003eGraphQLèªè¨¼ã¨N+1å¯¾ç­–\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/graphql/my_api_schema.rb\nclass MyApiSchema \u0026#x3C; GraphQL::Schema\n  mutation(Types::MutationType)\n  query(Types::QueryType)\n  \n  # GraphQL-Batch for N+1 prevention\n  use GraphQL::Batch\n  \n  # Query complexity prevention\n  max_complexity 300\n  max_depth 10\n  \n  def self.unauthorized_object(error)\n    raise GraphQL::ExecutionError, \"You don't have permission to access #{error.object}\"\n  end\nend\n\n# app/graphql/loaders/association_loader.rb\nclass Loaders::AssociationLoader \u0026#x3C; GraphQL::Batch::Loader\n  def initialize(model, association_name)\n    @model = model\n    @association_name = association_name\n  end\n  \n  def perform(records)\n    preload_association(records)\n    records.each { |record| fulfill(record, read_association(record)) }\n  end\n  \n  private\n  \n  def preload_association(records)\n    ActiveRecord::Associations::Preloader.new(\n      records: records,\n      associations: @association_name\n    ).call\n  end\n  \n  def read_association(record)\n    record.public_send(@association_name)\n  end\nend\n\n# app/graphql/types/post_type.rb\nmodule Types\n  class PostType \u0026#x3C; Types::BaseObject\n    field :comments, [Types::CommentType], null: true\n    \n    # N+1ã‚’é˜²ããŸã‚ã®DataLoaderä½¿ç”¨\n    def comments\n      Loaders::AssociationLoader.for(Post, :comments).load(object)\n    end\n    \n    field :user, Types::UserType, null: false\n    \n    def user\n      Loaders::RecordLoader.for(User).load(object.user_id)\n    end\n  end\nend\n\n# app/controllers/graphql_controller.rb\nclass GraphqlController \u0026#x3C; ApplicationController\n  skip_before_action :verify_authenticity_token\n  \n  def execute\n    variables = prepare_variables(params[:variables])\n    query = params[:query]\n    operation_name = params[:operationName]\n    \n    context = {\n      current_user: current_user,\n      request: request\n    }\n    \n    result = MyApiSchema.execute(\n      query,\n      variables: variables,\n      context: context,\n      operation_name: operation_name\n    )\n    \n    render json: result\n  rescue StandardError =\u003e e\n    raise e unless Rails.env.development?\n    handle_error_in_development(e)\n  end\n  \n  private\n  \n  def current_user\n    token = request.headers['Authorization']\u0026#x26;.split(' ')\u0026#x26;.last\n    return nil unless token\n    \n    decoded = JsonWebToken.decode(token)\n    User.find(decoded[:user_id])\n  rescue StandardError\n    nil\n  end\n  \n  def prepare_variables(variables_param)\n    case variables_param\n    when String\n      variables_param.present? ? JSON.parse(variables_param) || {} : {}\n    when Hash\n      variables_param\n    when ActionController::Parameters\n      variables_param.to_unsafe_hash\n    when nil\n      {}\n    else\n      raise ArgumentError, \"Unexpected parameter: #{variables_param}\"\n    end\n  end\n  \n  def handle_error_in_development(e)\n    logger.error e.message\n    logger.error e.backtrace.join(\"\\n\")\n    \n    render json: {\n      errors: [{ message: e.message, backtrace: e.backtrace }],\n      data: {}\n    }, status: 500\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ãƒ†ã‚¹ãƒˆæˆ¦ç•¥\"\u003eãƒ†ã‚¹ãƒˆæˆ¦ç•¥\u003c/h2\u003e\n\u003ch3 id=\"rspecã§ã®api-ãƒ†ã‚¹ãƒˆ\"\u003eRSpecã§ã®API ãƒ†ã‚¹ãƒˆ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# spec/rails_helper.rb\nrequire 'spec_helper'\nENV['RAILS_ENV'] ||= 'test'\nrequire_relative '../config/environment'\n\nRSpec.configure do |config|\n  config.include FactoryBot::Syntax::Methods\n  config.include RequestSpecHelper, type: :request\n  \n  config.before(:suite) do\n    DatabaseCleaner.strategy = :transaction\n    DatabaseCleaner.clean_with(:truncation)\n  end\nend\n\n# spec/support/request_spec_helper.rb\nmodule RequestSpecHelper\n  def json\n    JSON.parse(response.body)\n  end\n  \n  def auth_headers(user)\n    token = JsonWebToken.encode(user_id: user.id)\n    { 'Authorization' =\u003e \"Bearer #{token}\" }\n  end\nend\n\n# spec/requests/api/v1/posts_spec.rb\nrequire 'rails_helper'\n\nRSpec.describe 'Posts API', type: :request do\n  let(:user) { create(:user) }\n  let(:headers) { auth_headers(user) }\n  \n  describe 'GET /api/v1/posts' do\n    let!(:posts) { create_list(:post, 10, published: true) }\n    \n    before { get '/api/v1/posts', params: {}, headers: headers }\n    \n    it 'returns posts' do\n      expect(json).not_to be_empty\n      expect(json['data'].size).to eq(10)\n    end\n    \n    it 'returns status code 200' do\n      expect(response).to have_http_status(200)\n    end\n    \n    context 'with pagination' do\n      before do\n        get '/api/v1/posts', params: { page: 2, per_page: 5 }, headers: headers\n      end\n      \n      it 'returns paginated results' do\n        expect(json['data'].size).to eq(5)\n        expect(json['meta']['current_page']).to eq(2)\n      end\n    end\n    \n    context 'with filters' do\n      let!(:user_posts) { create_list(:post, 3, user: user, published: true) }\n      \n      before do\n        get '/api/v1/posts', params: { user_id: user.id }, headers: headers\n      end\n      \n      it 'returns filtered posts' do\n        expect(json['data'].size).to eq(3)\n        expect(json['data'].all? { |p| p['user_id'] == user.id }).to be true\n      end\n    end\n  end\n  \n  describe 'POST /api/v1/posts' do\n    let(:valid_attributes) do\n      { post: { title: 'Test Post', content: 'Test content', published: true } }\n    end\n    \n    context 'when the request is valid' do\n      before { post '/api/v1/posts', params: valid_attributes, headers: headers }\n      \n      it 'creates a post' do\n        expect(json['data']['title']).to eq('Test Post')\n      end\n      \n      it 'returns status code 201' do\n        expect(response).to have_http_status(201)\n      end\n    end\n    \n    context 'when the request is invalid' do\n      let(:invalid_attributes) { { post: { title: '' } } }\n      \n      before { post '/api/v1/posts', params: invalid_attributes, headers: headers }\n      \n      it 'returns status code 422' do\n        expect(response).to have_http_status(422)\n      end\n      \n      it 'returns a validation failure message' do\n        expect(json['errors']).to include(\"Title can't be blank\")\n      end\n    end\n  end\n  \n  describe 'PUT /api/v1/posts/:id' do\n    let(:post_record) { create(:post, user: user) }\n    let(:valid_attributes) { { post: { title: 'Updated Title' } } }\n    \n    before do\n      put \"/api/v1/posts/#{post_record.id}\", \n          params: valid_attributes, \n          headers: headers\n    end\n    \n    context 'when the record exists' do\n      it 'updates the record' do\n        expect(json['data']['title']).to eq('Updated Title')\n      end\n      \n      it 'returns status code 200' do\n        expect(response).to have_http_status(200)\n      end\n    end\n    \n    context 'when user is not the owner' do\n      let(:other_user) { create(:user) }\n      let(:headers) { auth_headers(other_user) }\n      \n      it 'returns status code 403' do\n        expect(response).to have_http_status(403)\n      end\n    end\n  end\n  \n  describe 'DELETE /api/v1/posts/:id' do\n    let!(:post_record) { create(:post, user: user) }\n    \n    before { delete \"/api/v1/posts/#{post_record.id}\", headers: headers }\n    \n    it 'returns status code 204' do\n      expect(response).to have_http_status(204)\n    end\n    \n    it 'deletes the record' do\n      expect(Post.find_by(id: post_record.id)).to be_nil\n    end\n  end\nend\n\n# spec/integration/api_integration_spec.rb\nRSpec.describe 'API Integration', type: :request do\n  describe 'complete user flow' do\n    it 'allows user registration, login, and resource creation' do\n      # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²\n      post '/api/v1/auth/register', params: {\n        email: 'test@example.com',\n        password: 'password123',\n        name: 'Test User'\n      }\n      \n      expect(response).to have_http_status(201)\n      token = json['token']\n      \n      # ãƒ­ã‚°ã‚¤ãƒ³\n      post '/api/v1/auth/login', params: {\n        email: 'test@example.com',\n        password: 'password123'\n      }\n      \n      expect(response).to have_http_status(200)\n      expect(json['token']).to be_present\n      \n      # ãƒªã‚½ãƒ¼ã‚¹ä½œæˆ\n      post '/api/v1/posts', \n           params: { post: { title: 'Test', content: 'Content' } },\n           headers: { 'Authorization' =\u003e \"Bearer #{token}\" }\n      \n      expect(response).to have_http_status(201)\n      expect(json['data']['title']).to eq('Test')\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–\"\u003eã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–\u003c/h2\u003e\n\u003ch3 id=\"api-ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹\"\u003eAPI ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/initializers/cors.rb\nRails.application.config.middleware.insert_before 0, Rack::Cors do\n  allow do\n    origins ENV.fetch('ALLOWED_ORIGINS', '*').split(',')\n    \n    resource '*',\n      headers: :any,\n      methods: [:get, :post, :put, :patch, :delete, :options, :head],\n      credentials: true,\n      max_age: 86400\n  end\nend\n\n# app/controllers/application_controller.rb\nclass ApplicationController \u0026#x3C; ActionController::API\n  # Rate limiting\n  include Rack::Attack\n  \n  # SQL Injectionå¯¾ç­–ã¯æ¨™æº–ã®Active Recordãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨\n  # XSSå¯¾ç­–ã¯APIãƒ¢ãƒ¼ãƒ‰ã§ã¯åŸºæœ¬çš„ã«ä¸è¦ï¼ˆJSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãŸã‚ï¼‰\n  \n  # CSRFå¯¾ç­–ï¼ˆAPIã§ã¯é€šå¸¸ä¸è¦ã ãŒã€Cookieèªè¨¼ã®å ´åˆã¯å¿…è¦ï¼‰\n  # protect_from_forgery with: :null_session\n  \n  # Strong Parameters\n  before_action :configure_permitted_parameters, if: :devise_controller?\n  \n  # APIã‚­ãƒ¼èªè¨¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰\n  before_action :authenticate_api_key!, if: :api_key_required?\n  \n  private\n  \n  def authenticate_api_key!\n    api_key = request.headers['X-API-Key']\n    \n    unless api_key \u0026#x26;\u0026#x26; ApiKey.active.exists?(key: api_key)\n      render json: { error: 'Invalid API key' }, status: :unauthorized\n    end\n  end\n  \n  def api_key_required?\n    # ç‰¹å®šã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§APIã‚­ãƒ¼ã‚’è¦æ±‚\n    request.path.start_with?('/api/admin')\n  end\nend\n\n# config/initializers/rack_attack.rb\nclass Rack::Attack\n  # Rate limiting\n  throttle('api/ip', limit: 100, period: 5.minutes) do |req|\n    req.ip if req.path.start_with?('/api')\n  end\n  \n  # ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã®åˆ¶é™\n  throttle('logins/ip', limit: 5, period: 20.seconds) do |req|\n    if req.path == '/api/v1/auth/login' \u0026#x26;\u0026#x26; req.post?\n      req.ip\n    end\n  end\n  \n  # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã®åˆ¶é™\n  throttle('api/user', limit: 1000, period: 1.hour) do |req|\n    if req.env['HTTP_AUTHORIZATION']\n      token = req.env['HTTP_AUTHORIZATION'].split(' ').last\n      decoded = JsonWebToken.decode(token) rescue nil\n      decoded[:user_id] if decoded\n    end\n  end\n  \n  # Blockãƒ«ãƒ¼ãƒ«\n  blocklist('block suspicious requests') do |req|\n    # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º\n    Rack::Attack::Fail2Ban.filter(\"pentesters-#{req.ip}\", maxretry: 3, findtime: 10.minutes, bantime: 30.minutes) do\n      CGI.unescape(req.query_string) =~ /(%27|')|(%3B|;)|(\u0026#x3C;|%3C)|(\u003e|%3E)/i\n    end\n  end\nend\n\n# app/services/security_audit_service.rb\nclass SecurityAuditService\n  def self.audit_request(request, user = nil)\n    AuditLog.create!(\n      user: user,\n      action: \"#{request.method} #{request.path}\",\n      ip_address: request.remote_ip,\n      user_agent: request.user_agent,\n      parameters: filter_sensitive_params(request.params),\n      performed_at: Time.current\n    )\n  end\n  \n  private\n  \n  def self.filter_sensitive_params(params)\n    Rails.application.config.filter_parameters.each do |param|\n      params = params.deep_transform_values do |value|\n        value.to_s.include?(param.to_s) ? '[FILTERED]' : value\n      end\n    end\n    params\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã¨ãƒ‡ãƒ—ãƒ­ã‚¤\"\u003eãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã¨ãƒ‡ãƒ—ãƒ­ã‚¤\u003c/h2\u003e\n\u003ch3 id=\"apiãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°æˆ¦ç•¥\"\u003eAPIãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°æˆ¦ç•¥\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# URLãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°\nRails.application.routes.draw do\n  namespace :api do\n    namespace :v1 do\n      resources :posts\n    end\n    \n    namespace :v2 do\n      resources :posts do\n        member do\n          post :react\n        end\n      end\n    end\n  end\n  \n  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ\n  get 'api/posts', to: redirect('/api/v1/posts')\nend\n\n# ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°\nclass ApplicationController \u0026#x3C; ActionController::API\n  before_action :set_api_version\n  \n  private\n  \n  def set_api_version\n    @api_version = request.headers['Accept-Version'] || 'v1'\n    \n    unless %w[v1 v2].include?(@api_version)\n      render json: { error: 'Invalid API version' }, status: :bad_request\n    end\n  end\nend\n\n# app/controllers/api/posts_controller.rb\nmodule Api\n  class PostsController \u0026#x3C; BaseController\n    def index\n      case @api_version\n      when 'v1'\n        render json: posts_v1\n      when 'v2'\n        render json: posts_v2\n      end\n    end\n    \n    private\n    \n    def posts_v1\n      Post.all.as_json(only: [:id, :title, :content])\n    end\n    \n    def posts_v2\n      Post.all.as_json(\n        only: [:id, :title, :content],\n        methods: [:reactions_count, :views_count]\n      )\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š\"\u003eãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/deploy.rb (Capistrano)\nlock '~\u003e 3.17.0'\n\nset :application, 'my_api'\nset :repo_url, 'git@github.com:username/my_api.git'\nset :deploy_to, '/var/www/my_api'\nset :rbenv_ruby, '3.2.0'\n\nappend :linked_files, 'config/database.yml', 'config/master.key'\nappend :linked_dirs, 'log', 'tmp/pids', 'tmp/cache', 'tmp/sockets', 'public/system'\n\nnamespace :deploy do\n  desc 'Restart application'\n  task :restart do\n    on roles(:app), in: :sequence, wait: 5 do\n      execute :touch, release_path.join('tmp/restart.txt')\n    end\n  end\n  \n  after :publishing, :restart\nend\n\n# docker-compose.yml\nversion: '3.8'\nservices:\n  db:\n    image: postgres:14\n    environment:\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n  \n  redis:\n    image: redis:7-alpine\n    command: redis-server\n    volumes:\n      - redis_data:/data\n  \n  web:\n    build: .\n    command: bundle exec puma -C config/puma.rb\n    volumes:\n      - .:/app\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n      - redis\n    environment:\n      DATABASE_URL: postgresql://postgres:password@db/my_api_production\n      REDIS_URL: redis://redis:6379/0\n  \n  sidekiq:\n    build: .\n    command: bundle exec sidekiq\n    volumes:\n      - .:/app\n    depends_on:\n      - db\n      - redis\n    environment:\n      DATABASE_URL: postgresql://postgres:password@db/my_api_production\n      REDIS_URL: redis://redis:6379/0\n\nvolumes:\n  postgres_data:\n  redis_data:\n\n# Dockerfile\nFROM ruby:3.2.0\nRUN apt-get update -qq \u0026#x26;\u0026#x26; apt-get install -y postgresql-client\nWORKDIR /app\nCOPY Gemfile* ./\nRUN bundle install\nCOPY . .\nEXPOSE 3000\nCMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ã¾ã¨ã‚\"\u003eã¾ã¨ã‚\u003c/h2\u003e\n\u003ch3 id=\"rails-apié–‹ç™ºãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ\"\u003eRails APIé–‹ç™ºãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eè¨­è¨ˆ\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e RESTfulåŸå‰‡ã«å¾“ã£ãŸURLè¨­è¨ˆ\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®ä½¿ç”¨\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e ä¸€è²«æ€§ã®ã‚ã‚‹ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å®Ÿè£…\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e N+1å•é¡Œã®è§£æ±ºï¼ˆincludes, eager_loadï¼‰\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e é©åˆ‡ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¨­å®š\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥ã®å®Ÿè£…\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–ã®æ´»ç”¨\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e èªè¨¼ãƒ»èªå¯ã®å®Ÿè£…\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Rate limitingã®è¨­å®š\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e CORSè¨­å®š\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eãƒ†ã‚¹ãƒˆ\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Request specã®ä½œæˆ\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e çµ±åˆãƒ†ã‚¹ãƒˆã®å®Ÿè£…\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"é¢æ¥ã§ã®å›ç­”ä¾‹\"\u003eé¢æ¥ã§ã®å›ç­”ä¾‹\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eQ: Rails APIãƒ¢ãƒ¼ãƒ‰ã®åˆ©ç‚¹ã¯ï¼Ÿ\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: Rails APIãƒ¢ãƒ¼ãƒ‰ã¯é€šå¸¸ã®Railsã‹ã‚‰ä¸è¦ãªæ©Ÿèƒ½ã‚’å‰Šé™¤ã—ã€\nAPIé–‹ç™ºã«æœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚\n\nä¸»ãªåˆ©ç‚¹ï¼š\n1. è»½é‡åŒ–ï¼šãƒ“ãƒ¥ãƒ¼å±¤ã‚„ã‚¢ã‚»ãƒƒãƒˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’é™¤å¤–\n2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼šãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å‰Šæ¸›ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹é€Ÿåº¦å‘ä¸Š\n3. ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æœ€é©åŒ–ï¼šAPIç”¨ã«æœ€é©åŒ–ã•ã‚ŒãŸæ§‹æˆ\n\nå®Ÿè£…é¢ã§ã¯ã€ApplicationControllerãŒActionController::APIã‚’\nç¶™æ‰¿ã—ã€JSONãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«ç‰¹åŒ–ã—ãŸè¨­å®šã«ãªã£ã¦ã„ã¾ã™ã€‚\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eQ: N+1å•é¡Œã‚’ã©ã†è§£æ±ºã—ã¾ã™ã‹ï¼Ÿ\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: N+1å•é¡Œã¯ä¸»ã«3ã¤ã®æ–¹æ³•ã§è§£æ±ºã—ã¾ã™ï¼š\n\n1. includesï¼šé–¢é€£ãƒ‡ãƒ¼ã‚¿ã‚’äº‹å‰èª­ã¿è¾¼ã¿\n   Post.includes(:comments, :user)\n\n2. eager_loadï¼šLEFT JOINã§ä¸€åº¦ã«å–å¾—\n   Post.eager_load(:comments).where(comments: { approved: true })\n\n3. ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼šé›†è¨ˆå€¤ã‚’ã‚«ãƒ©ãƒ ã«ä¿å­˜\n   has_many :comments, counter_cache: true\n\né–‹ç™ºç’°å¢ƒã§ã¯Bullet gemã§æ¤œå‡ºã—ã€\næœ¬ç•ªç’°å¢ƒã§ã¯New Relicã‚„Datadogã§ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ç¶™ç¶šçš„ãªå­¦ç¿’ã®ãŸã‚ã«\"\u003eç¶™ç¶šçš„ãªå­¦ç¿’ã®ãŸã‚ã«\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eå®Ÿè·µãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ\u003c/strong\u003e: å®Ÿéš›ã®APIã‚’æ§‹ç¯‰\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š\u003c/strong\u003e: Apache Benchã€JMeterã§ã®è² è·ãƒ†ã‚¹ãƒˆ\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eæœ€æ–°å‹•å‘\u003c/strong\u003e: Rails 7.1ã®æ–°æ©Ÿèƒ½ã€Hotwire Turbo\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eä»–è¨€èªã¨ã®æ¯”è¼ƒ\u003c/strong\u003e: Goã€Node.jsã®APIé–‹ç™ºã‚‚å­¦ç¿’\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"å‚è€ƒãƒªãƒ³ã‚¯\"\u003eå‚è€ƒãƒªãƒ³ã‚¯\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://guides.rubyonrails.org/api_app.html\"\u003eRuby on Rails Guides\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://jsonapi.org/\"\u003eJSON:API Specification\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://graphql-ruby.org/\"\u003eGraphQL Ruby\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.speedshop.co/\"\u003eRails Performance\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://guides.rubyonrails.org/security.html\"\u003eRails Security Guide\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cem\u003eã“ã®è¨˜äº‹ã¯ã€Ruby on Rails APIé–‹ç™ºã«ãŠã‘ã‚‹3å¹´ä»¥ä¸Šã®å®Ÿå‹™çµŒé¨“ã§å¿…è¦ãªçŸ¥è­˜ã‚’ç¶²ç¾…çš„ã«ã¾ã¨ã‚ã¾ã—ãŸã€‚\u003c/em\u003e\u003c/p\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold mb-2\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-green-600\",\"children\":[\"#\",41]}],\" \",\"Ruby on Rails APIé–‹ç™ºå®Œå…¨ã‚¬ã‚¤ãƒ‰ - RESTfulè¨­è¨ˆã‹ã‚‰GraphQLã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¾ã§\"]}],[\"$\",\"ul\",null,{\"className\":\"list-none border-b border-gray-600 pb-4 mb-6\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"ä½œæˆæ—¥æ™‚: \",\"2025-08-25 01:04\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"æ›´æ–°æ—¥æ™‚: \",\"2025-08-25 01:04\"]}],[\"$\",\"li\",null,{\"className\":\"flex flex-wrap gap-2 mt-2\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"Ruby on Rails\"}],[\"$\",\"span\",\"1\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"API\"}],[\"$\",\"span\",\"2\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"REST\"}],[\"$\",\"span\",\"3\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"GraphQL\"}],[\"$\",\"span\",\"4\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"JWT\"}],[\"$\",\"span\",\"5\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹\"}],[\"$\",\"span\",\"6\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£\"}],[\"$\",\"span\",\"7\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"RSpec\"}]]}]]}],[\"$\",\"nav\",null,{\"className\":\"mb-6 pb-4 border-b border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"â† ãƒ›ãƒ¼ãƒ ã¸\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"è¨˜äº‹ä¸€è¦§ã¸ â†’\"}]]}],[\"$\",\"article\",null,{\"className\":\"prose dark:prose-invert\",\"dangerouslySetInnerHTML\":{\"__html\":\"$13\"}}],[\"$\",\"$L14\",null,{}],[\"$\",\"nav\",null,{\"className\":\"mt-8 pt-4 border-t border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"â† ãƒ›ãƒ¼ãƒ ã¸\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"è¨˜äº‹ä¸€è¦§ã¸ â†’\"}]]}],[\"$\",\"$L15\",null,{}]]}]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"11:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Maita Tomoya Dev IO\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"ç±³ç”°æ™ºå“‰ã®æŠ€è¡“ãƒ–ãƒ­ã‚°ã€‚ã‚­ãƒ£ãƒƒãƒã‚¢ãƒƒãƒ—ã—ãŸã“ã¨ã‚’ãƒ¡ãƒ¢ã—ã¾ã™ã€‚\"}]],\"error\":null,\"digest\":\"$undefined\"}\nb:{\"metadata\":\"$11:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>