<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/19bdf9af4d1ae4d4.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-aa7deb192a774533.js"/><script src="/_next/static/chunks/4bd1b696-bc089769d60af88b.js" async=""></script><script src="/_next/static/chunks/1684-b369840b16e4c44b.js" async=""></script><script src="/_next/static/chunks/main-app-2ed07751e45c2a2f.js" async=""></script><script src="/_next/static/chunks/6874-6c1ddde525f3893c.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js" async=""></script><meta name="next-size-adjust" content=""/><link rel="icon" href="/favicon.png" type="image/png"/><title>Maita Tomoya Dev IO</title><meta name="description" content="米田智哉の技術ブログ。キャッチアップしたことをメモします。"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 antialiased"><div class="max-w-2xl mx-auto py-10 px-4"><h1 class="text-3xl font-bold mb-2"><span class="text-green-600">#<!-- -->41</span> <!-- -->Ruby on Rails API開発完全ガイド - RESTful設計からGraphQL、パフォーマンス最適化まで</h1><ul class="list-none border-b border-gray-600 pb-4 mb-6"><li class="text-gray-500 text-sm">作成日時: <!-- -->2025-08-25 01:04</li><li class="text-gray-500 text-sm">更新日時: <!-- -->2025-08-25 01:04</li><li class="flex flex-wrap gap-2 mt-2"><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">Ruby on Rails</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">API</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">REST</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">GraphQL</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">JWT</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">パフォーマンス</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">セキュリティ</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">RSpec</span></li></ul><nav class="mb-6 pb-4 border-b border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav><article class="prose dark:prose-invert"><p>Ruby on Rails開発経験3年以上を求める求人で「API開発経験」は必須要件です。しかし、単に「Rails APIモードを使える」だけでは不十分です。本記事では、RESTful API設計の原則から、認証・認可、パフォーマンス最適化、GraphQL実装まで、実務で必要な知識を網羅的に解説します。</p>
<h2 id="-初心者向け解説">💡 初心者向け解説</h2>
<h3 id="apiとは">APIとは？</h3>
<p><strong>簡単に言うと</strong>: アプリケーション同士が会話するための窓口です。</p>
<pre><code>例：レストランの注文システム
Webサイト/アプリ：お客様（フロントエンド）
API：ウェイター（通信の仲介）
Rails：厨房（バックエンド）
データベース：食材庫
</code></pre>
<h3 id="なぜrails-apiが選ばれるのか">なぜRails APIが選ばれるのか？</h3>
<ul>
<li><strong>開発速度</strong>: 規約重視で高速開発が可能</li>
<li><strong>成熟度</strong>: 豊富なGemエコシステム</li>
<li><strong>スケーラビリティ</strong>: 大規模サービスでの実績</li>
<li><strong>メンテナンス性</strong>: Railsの規約による統一性</li>
</ul>
<h2 id="-目次">📚 目次</h2>
<ul>
<li><a href="#rails-api%E5%9F%BA%E7%A4%8E">Rails API基礎</a></li>
<li><a href="#restful-api%E8%A8%AD%E8%A8%88">RESTful API設計</a></li>
<li><a href="#%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF%E3%81%AE%E5%AE%9F%E8%A3%85">認証・認可の実装</a></li>
<li><a href="#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B9%E8%A8%AD%E8%A8%88">エラーハンドリングとレスポンス設計</a></li>
<li><a href="#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%9C%80%E9%81%A9%E5%8C%96">パフォーマンス最適化</a></li>
<li><a href="#graphql%E5%AE%9F%E8%A3%85">GraphQL実装</a></li>
<li><a href="#%E3%83%86%E3%82%B9%E3%83%88%E6%88%A6%E7%95%A5">テスト戦略</a></li>
<li><a href="#%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E5%AF%BE%E7%AD%96">セキュリティ対策</a></li>
<li><a href="#%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">バージョニングとデプロイ</a></li>
</ul>
<h2 id="rails-api基礎">Rails API基礎</h2>
<h3 id="rails-apiモードのセットアップ">Rails APIモードのセットアップ</h3>
<pre><code class="language-bash"># APIモードでRailsアプリケーション作成
rails new my_api --api --database=postgresql

# 主な違い：
# - ApplicationControllerがActionController::APIを継承
# - ビュー層、アセットパイプライン、セッション関連が除外
# - CORSやJSONレンダリングに最適化
</code></pre>
<h3 id="基本的なapiコントローラー">基本的なAPIコントローラー</h3>
<pre><code class="language-ruby"># app/controllers/api/v1/base_controller.rb
module Api
  module V1
    class BaseController &#x3C; ApplicationController
      # 共通のエラーハンドリング
      rescue_from ActiveRecord::RecordNotFound, with: :not_found
      rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity
      rescue_from ActionController::ParameterMissing, with: :bad_request

      private

      def not_found(exception)
        render json: { 
          error: {
            message: exception.message,
            type: 'ResourceNotFound'
          }
        }, status: :not_found
      end

      def unprocessable_entity(exception)
        render json: { 
          error: {
            message: exception.record.errors.full_messages.join(', '),
            type: 'ValidationError',
            details: exception.record.errors.details
          }
        }, status: :unprocessable_entity
      end

      def bad_request(exception)
        render json: { 
          error: {
            message: exception.message,
            type: 'BadRequest'
          }
        }, status: :bad_request
      end

      # ページネーション用メソッド
      def paginate(resource)
        resource.page(params[:page] || 1).per(params[:per_page] || 20)
      end

      # メタ情報の追加
      def render_with_meta(resource, options = {})
        if resource.respond_to?(:current_page)
          options[:meta] = pagination_meta(resource)
        end
        render json: resource, **options
      end

      def pagination_meta(resource)
        {
          current_page: resource.current_page,
          total_pages: resource.total_pages,
          total_count: resource.total_count,
          per_page: resource.limit_value
        }
      end
    end
  end
end
</code></pre>
<h3 id="serializerの実装activemodelserializers">Serializerの実装（ActiveModel::Serializers）</h3>
<pre><code class="language-ruby"># Gemfile
gem 'active_model_serializers', '~> 0.10.0'

# app/serializers/api/v1/user_serializer.rb
module Api
  module V1
    class UserSerializer &#x3C; ActiveModel::Serializer
      attributes :id, :email, :name, :avatar_url, :created_at
      
      # 関連の定義
      has_many :posts
      has_one :profile
      
      # カスタム属性
      attribute :full_name do
        "#{object.first_name} #{object.last_name}"
      end
      
      # 条件付き属性
      attribute :admin_info, if: :is_admin?
      
      def admin_info
        {
          last_login: object.last_login_at,
          permissions: object.permissions
        }
      end
      
      def is_admin?
        scope &#x26;&#x26; scope.admin?
      end
      
      # URLヘルパーの使用
      link(:self) { api_v1_user_url(object) }
    end
  end
end
</code></pre>
<h2 id="restful-api設計">RESTful API設計</h2>
<h3 id="リソースベースのurl設計">リソースベースのURL設計</h3>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  namespace :api do
    namespace :v1 do
      # リソースフルなルーティング
      resources :users do
        member do
          post :activate
          post :deactivate
        end
        
        collection do
          get :search
          get :export
        end
        
        # ネストしたリソース
        resources :posts, shallow: true do
          resources :comments
          resources :likes, only: [:create, :destroy]
        end
      end
      
      # カスタムルート
      post 'auth/login', to: 'authentication#login'
      post 'auth/logout', to: 'authentication#logout'
      post 'auth/refresh', to: 'authentication#refresh'
      
      # 検索エンドポイント
      namespace :search do
        get 'users', to: 'users#index'
        get 'posts', to: 'posts#index'
        get 'global', to: 'global#index'
      end
    end
  end
end
</code></pre>
<h3 id="httpステータスコードの適切な使用">HTTPステータスコードの適切な使用</h3>
<pre><code class="language-ruby"># app/controllers/api/v1/posts_controller.rb
module Api
  module V1
    class PostsController &#x3C; BaseController
      before_action :authenticate_user!
      before_action :set_post, only: [:show, :update, :destroy]
      before_action :authorize_user!, only: [:update, :destroy]

      # GET /api/v1/posts
      def index
        posts = Post.published
                   .includes(:user, :tags, :comments)
                   .search(params[:q])
                   .filter_by_tags(params[:tags])
                   .order(created_at: :desc)
        
        posts = paginate(posts)
        
        render_with_meta(
          posts,
          each_serializer: PostSerializer,
          include: ['user', 'tags']
        )
      end

      # GET /api/v1/posts/:id
      def show
        render json: @post, 
               serializer: PostDetailSerializer,
               include: ['user', 'comments', 'comments.user']
      end

      # POST /api/v1/posts
      def create
        post = current_user.posts.build(post_params)
        
        if post.save
          # 201 Created
          render json: post, 
                 serializer: PostSerializer,
                 status: :created,
                 location: api_v1_post_url(post)
        else
          # 422 Unprocessable Entity
          render json: { 
            errors: post.errors.full_messages,
            details: post.errors.details 
          }, status: :unprocessable_entity
        end
      end

      # PATCH/PUT /api/v1/posts/:id
      def update
        if @post.update(post_params)
          # 200 OK
          render json: @post, serializer: PostSerializer
        else
          # 422 Unprocessable Entity
          render json: { 
            errors: @post.errors.full_messages 
          }, status: :unprocessable_entity
        end
      end

      # DELETE /api/v1/posts/:id
      def destroy
        @post.destroy
        # 204 No Content
        head :no_content
      end

      private

      def set_post
        @post = Post.find(params[:id])
      end

      def authorize_user!
        # 403 Forbidden
        unless @post.user == current_user || current_user.admin?
          render json: { 
            error: 'You are not authorized to perform this action' 
          }, status: :forbidden
        end
      end

      def post_params
        params.require(:post).permit(
          :title, 
          :content, 
          :published, 
          tag_ids: [],
          images_attributes: [:id, :url, :caption, :_destroy]
        )
      end
    end
  end
end
</code></pre>
<h3 id="フィルタリングとソート">フィルタリングとソート</h3>
<pre><code class="language-ruby"># app/models/concerns/filterable.rb
module Filterable
  extend ActiveSupport::Concern

  module ClassMethods
    def filter(filtering_params)
      results = self.where(nil)
      filtering_params.each do |key, value|
        results = results.public_send("filter_by_#{key}", value) if value.present?
      end
      results
    end
  end
end

# app/models/post.rb
class Post &#x3C; ApplicationRecord
  include Filterable
  
  belongs_to :user
  has_many :comments, dependent: :destroy
  has_and_belongs_to_many :tags
  
  # スコープ定義
  scope :published, -> { where(published: true) }
  scope :draft, -> { where(published: false) }
  scope :recent, -> { where('created_at > ?', 1.week.ago) }
  
  # フィルタリング用スコープ
  scope :filter_by_status, ->(status) { 
    case status
    when 'published' then published
    when 'draft' then draft
    else all
    end
  }
  
  scope :filter_by_user_id, ->(user_id) { where(user_id: user_id) }
  
  scope :filter_by_tags, ->(tag_names) {
    joins(:tags).where(tags: { name: tag_names })
  }
  
  scope :filter_by_date_range, ->(from, to) {
    where(created_at: from..to)
  }
  
  # 全文検索
  scope :search, ->(query) {
    return all if query.blank?
    
    where('title ILIKE :q OR content ILIKE :q', q: "%#{query}%")
  }
  
  # ソート
  scope :sort_by_field, ->(field, direction = 'asc') {
    safe_fields = %w[created_at updated_at title views_count]
    safe_directions = %w[asc desc]
    
    field = 'created_at' unless safe_fields.include?(field)
    direction = 'desc' unless safe_directions.include?(direction)
    
    order(field => direction)
  }
end

# コントローラーでの使用
def index
  posts = Post.filter(
    status: params[:status],
    user_id: params[:user_id],
    tags: params[:tags]
  ).sort_by_field(params[:sort], params[:direction])
  
  render json: paginate(posts)
end
</code></pre>
<h2 id="認証認可の実装">認証・認可の実装</h2>
<h3 id="jwt認証の実装">JWT認証の実装</h3>
<pre><code class="language-ruby"># Gemfile
gem 'jwt'
gem 'bcrypt'

# app/lib/json_web_token.rb
class JsonWebToken
  SECRET_KEY = Rails.application.credentials.secret_key_base || Rails.application.secrets.secret_key_base
  
  def self.encode(payload, exp = 24.hours.from_now)
    payload[:exp] = exp.to_i
    JWT.encode(payload, SECRET_KEY, 'HS256')
  end
  
  def self.decode(token)
    decoded = JWT.decode(token, SECRET_KEY, true, algorithm: 'HS256')[0]
    HashWithIndifferentAccess.new(decoded)
  rescue JWT::DecodeError => e
    raise ExceptionHandler::InvalidToken, e.message
  end
end

# app/controllers/concerns/exception_handler.rb
module ExceptionHandler
  extend ActiveSupport::Concern
  
  class AuthenticationError &#x3C; StandardError; end
  class InvalidToken &#x3C; StandardError; end
  class MissingToken &#x3C; StandardError; end
  class ExpiredToken &#x3C; StandardError; end
  
  included do
    rescue_from ExceptionHandler::AuthenticationError, with: :unauthorized_request
    rescue_from ExceptionHandler::InvalidToken, with: :unauthorized_request
    rescue_from ExceptionHandler::MissingToken, with: :unauthorized_request
    rescue_from ExceptionHandler::ExpiredToken, with: :unauthorized_request
  end
  
  private
  
  def unauthorized_request(e)
    render json: { error: e.message }, status: :unauthorized
  end
end

# app/controllers/concerns/authenticable.rb
module Authenticable
  extend ActiveSupport::Concern
  
  included do
    before_action :authenticate_request
    attr_reader :current_user
  end
  
  private
  
  def authenticate_request
    @current_user = AuthorizeApiRequest.new(request.headers).call
  rescue StandardError => e
    render json: { error: e.message }, status: :unauthorized
  end
  
  def authenticate_user!
    authenticate_request
  end
end

# app/services/authorize_api_request.rb
class AuthorizeApiRequest
  def initialize(headers = {})
    @headers = headers
  end
  
  def call
    user
  end
  
  private
  
  attr_reader :headers
  
  def user
    @user ||= User.find(decoded_auth_token[:user_id]) if decoded_auth_token
  rescue ActiveRecord::RecordNotFound => e
    raise ExceptionHandler::InvalidToken, "Invalid token: #{e.message}"
  end
  
  def decoded_auth_token
    @decoded_auth_token ||= JsonWebToken.decode(http_auth_header)
  end
  
  def http_auth_header
    if headers['Authorization'].present?
      return headers['Authorization'].split(' ').last
    end
    raise ExceptionHandler::MissingToken, 'Missing token'
  end
end
</code></pre>
<h3 id="認証コントローラー">認証コントローラー</h3>
<pre><code class="language-ruby"># app/controllers/api/v1/authentication_controller.rb
module Api
  module V1
    class AuthenticationController &#x3C; BaseController
      skip_before_action :authenticate_user!, only: [:login, :register]
      
      # POST /api/v1/auth/register
      def register
        user = User.new(user_params)
        
        if user.save
          token = generate_token(user)
          render json: {
            user: UserSerializer.new(user),
            token: token,
            expires_at: 24.hours.from_now
          }, status: :created
        else
          render json: { 
            errors: user.errors.full_messages 
          }, status: :unprocessable_entity
        end
      end
      
      # POST /api/v1/auth/login
      def login
        user = User.find_by(email: params[:email])
        
        if user&#x26;.authenticate(params[:password])
          token = generate_token(user)
          
          # ログイン履歴の記録
          user.update(
            last_login_at: Time.current,
            last_login_ip: request.remote_ip
          )
          
          render json: {
            user: UserSerializer.new(user),
            token: token,
            expires_at: 24.hours.from_now
          }
        else
          render json: { 
            error: 'Invalid email or password' 
          }, status: :unauthorized
        end
      end
      
      # POST /api/v1/auth/logout
      def logout
        # JWTの場合、クライアント側でトークンを削除
        # オプション：トークンをブラックリストに追加
        token = request.headers['Authorization']&#x26;.split(' ')&#x26;.last
        BlacklistedToken.create(token: token, expires_at: 24.hours.from_now) if token
        
        head :no_content
      end
      
      # POST /api/v1/auth/refresh
      def refresh
        # リフレッシュトークンの実装
        refresh_token = params[:refresh_token]
        
        if valid_refresh_token?(refresh_token)
          user = User.find_by(refresh_token: refresh_token)
          new_token = generate_token(user)
          
          render json: {
            token: new_token,
            expires_at: 24.hours.from_now
          }
        else
          render json: { 
            error: 'Invalid refresh token' 
          }, status: :unauthorized
        end
      end
      
      private
      
      def user_params
        params.permit(:email, :password, :password_confirmation, :name)
      end
      
      def generate_token(user)
        JsonWebToken.encode(user_id: user.id)
      end
      
      def valid_refresh_token?(token)
        # リフレッシュトークンの検証ロジック
        return false if token.blank?
        
        user = User.find_by(refresh_token: token)
        user &#x26;&#x26; user.refresh_token_expires_at > Time.current
      end
    end
  end
end
</code></pre>
<h3 id="認可pundit使用">認可（Pundit使用）</h3>
<pre><code class="language-ruby"># Gemfile
gem 'pundit'

# app/policies/application_policy.rb
class ApplicationPolicy
  attr_reader :user, :record

  def initialize(user, record)
    @user = user
    @record = record
  end

  def index?
    true
  end

  def show?
    true
  end

  def create?
    user.present?
  end

  def update?
    user.present? &#x26;&#x26; (record.user == user || user.admin?)
  end

  def destroy?
    update?
  end

  class Scope
    attr_reader :user, :scope

    def initialize(user, scope)
      @user = user
      @scope = scope
    end

    def resolve
      scope.all
    end
  end
end

# app/policies/post_policy.rb
class PostPolicy &#x3C; ApplicationPolicy
  def index?
    true
  end
  
  def show?
    record.published? || record.user == user || user&#x26;.admin?
  end
  
  def create?
    user.present?
  end
  
  def update?
    record.user == user || user&#x26;.admin?
  end
  
  def destroy?
    record.user == user || user&#x26;.admin?
  end
  
  def publish?
    record.user == user || user&#x26;.admin?
  end
  
  class Scope &#x3C; Scope
    def resolve
      if user&#x26;.admin?
        scope.all
      elsif user
        scope.where('published = ? OR user_id = ?', true, user.id)
      else
        scope.published
      end
    end
  end
end

# コントローラーでの使用
class PostsController &#x3C; BaseController
  include Pundit
  
  def index
    posts = policy_scope(Post)
    render json: posts
  end
  
  def show
    post = Post.find(params[:id])
    authorize post
    render json: post
  end
  
  def update
    post = Post.find(params[:id])
    authorize post
    
    if post.update(post_params)
      render json: post
    else
      render json: { errors: post.errors }, status: :unprocessable_entity
    end
  end
end
</code></pre>
<h2 id="エラーハンドリングとレスポンス設計">エラーハンドリングとレスポンス設計</h2>
<h3 id="統一的なエラーレスポンス">統一的なエラーレスポンス</h3>
<pre><code class="language-ruby"># app/controllers/concerns/error_handler.rb
module ErrorHandler
  extend ActiveSupport::Concern
  
  included do
    rescue_from StandardError, with: :handle_internal_server_error
    rescue_from ActiveRecord::RecordNotFound, with: :handle_not_found
    rescue_from ActiveRecord::RecordInvalid, with: :handle_unprocessable_entity
    rescue_from ActionController::ParameterMissing, with: :handle_bad_request
    rescue_from Pundit::NotAuthorizedError, with: :handle_forbidden
    
    # カスタムエラー
    rescue_from CustomErrors::ValidationError, with: :handle_validation_error
    rescue_from CustomErrors::AuthenticationError, with: :handle_authentication_error
    rescue_from CustomErrors::RateLimitError, with: :handle_rate_limit
  end
  
  private
  
  def handle_internal_server_error(exception)
    logger.error exception.message
    logger.error exception.backtrace.join("\n")
    
    if Rails.env.production?
      render_error(500, 'Internal Server Error', 'An error occurred')
    else
      render_error(500, 'Internal Server Error', exception.message)
    end
  end
  
  def handle_not_found(exception)
    render_error(404, 'Not Found', exception.message)
  end
  
  def handle_unprocessable_entity(exception)
    render_error(
      422, 
      'Unprocessable Entity', 
      exception.record.errors.full_messages.join(', '),
      exception.record.errors.details
    )
  end
  
  def handle_bad_request(exception)
    render_error(400, 'Bad Request', exception.message)
  end
  
  def handle_forbidden(exception)
    render_error(403, 'Forbidden', 'You are not authorized to perform this action')
  end
  
  def handle_validation_error(exception)
    render_error(422, 'Validation Error', exception.message, exception.errors)
  end
  
  def handle_authentication_error(exception)
    render_error(401, 'Authentication Error', exception.message)
  end
  
  def handle_rate_limit(exception)
    response.headers['X-RateLimit-Limit'] = exception.limit.to_s
    response.headers['X-RateLimit-Remaining'] = '0'
    response.headers['X-RateLimit-Reset'] = exception.reset_at.to_i.to_s
    
    render_error(429, 'Too Many Requests', 'Rate limit exceeded')
  end
  
  def render_error(status, error_type, message, details = nil)
    error_response = {
      error: {
        status: status,
        type: error_type,
        message: message,
        timestamp: Time.current.iso8601
      }
    }
    
    error_response[:error][:details] = details if details.present?
    
    render json: error_response, status: status
  end
end

# app/lib/custom_errors.rb
module CustomErrors
  class BaseError &#x3C; StandardError
    attr_reader :status, :error_type, :details
    
    def initialize(message = nil, status = nil, error_type = nil, details = nil)
      @status = status
      @error_type = error_type
      @details = details
      super(message)
    end
  end
  
  class ValidationError &#x3C; BaseError
    def initialize(message = 'Validation failed', details = nil)
      super(message, 422, 'ValidationError', details)
    end
  end
  
  class AuthenticationError &#x3C; BaseError
    def initialize(message = 'Authentication failed')
      super(message, 401, 'AuthenticationError')
    end
  end
  
  class RateLimitError &#x3C; BaseError
    attr_reader :limit, :reset_at
    
    def initialize(limit, reset_at)
      @limit = limit
      @reset_at = reset_at
      super('Rate limit exceeded', 429, 'RateLimitError')
    end
  end
end
</code></pre>
<h3 id="レスポンスフォーマット標準化">レスポンスフォーマット標準化</h3>
<pre><code class="language-ruby"># app/services/response_builder.rb
class ResponseBuilder
  def self.success(data = nil, message = nil, meta = {})
    response = {
      success: true,
      timestamp: Time.current.iso8601
    }
    
    response[:data] = data if data.present?
    response[:message] = message if message.present?
    response[:meta] = meta if meta.present?
    
    response
  end
  
  def self.error(status, error_type, message, details = nil)
    {
      success: false,
      error: {
        status: status,
        type: error_type,
        message: message,
        details: details
      }.compact,
      timestamp: Time.current.iso8601
    }
  end
  
  def self.paginated(collection, serializer, options = {})
    {
      success: true,
      data: ActiveModelSerializers::SerializableResource.new(
        collection,
        each_serializer: serializer,
        **options
      ),
      meta: {
        pagination: {
          current_page: collection.current_page,
          total_pages: collection.total_pages,
          total_count: collection.total_count,
          per_page: collection.limit_value,
          next_page: collection.next_page,
          prev_page: collection.prev_page
        }
      },
      timestamp: Time.current.iso8601
    }
  end
end

# コントローラーでの使用
def index
  posts = Post.published.page(params[:page])
  render json: ResponseBuilder.paginated(posts, PostSerializer)
end

def create
  post = current_user.posts.build(post_params)
  
  if post.save
    render json: ResponseBuilder.success(
      PostSerializer.new(post),
      'Post created successfully'
    ), status: :created
  else
    render json: ResponseBuilder.error(
      422,
      'ValidationError',
      'Validation failed',
      post.errors.details
    ), status: :unprocessable_entity
  end
end
</code></pre>
<h2 id="パフォーマンス最適化">パフォーマンス最適化</h2>
<h3 id="n1問題の解決">N+1問題の解決</h3>
<pre><code class="language-ruby"># app/models/post.rb
class Post &#x3C; ApplicationRecord
  belongs_to :user
  has_many :comments
  has_many :likes
  has_and_belongs_to_many :tags
  
  # Bullet gemによる検出
  # Gemfile
  # gem 'bullet', group: :development
  
  # スコープでのincludes
  scope :with_associations, -> {
    includes(:user, :tags, comments: :user)
  }
  
  # カウンターキャッシュの使用
  # comments_count, likes_count カラムを追加
  has_many :comments, counter_cache: true
  has_many :likes, counter_cache: true
end

# app/controllers/api/v1/posts_controller.rb
def index
  # ❌ N+1問題が発生
  posts = Post.all
  
  # ✅ includesで解決
  posts = Post.includes(:user, :tags, :comments)
  
  # ✅ より詳細な最適化
  posts = Post
    .includes(:user, :tags)
    .includes(comments: [:user, :likes])
    .references(:comments)
    .where('comments.created_at > ?', 1.week.ago)
  
  render json: posts
end

# app/serializers/post_serializer.rb
class PostSerializer &#x3C; ActiveModel::Serializer
  attributes :id, :title, :content, :comments_count, :likes_count
  
  belongs_to :user
  has_many :tags
  
  # カウンターキャッシュを活用
  def comments_count
    object.comments_count # N+1を避ける
  end
  
  def likes_count
    object.likes_count # N+1を避ける
  end
end
</code></pre>
<h3 id="キャッシング戦略">キャッシング戦略</h3>
<pre><code class="language-ruby"># config/environments/production.rb
config.cache_store = :redis_cache_store, {
  url: ENV['REDIS_URL'],
  expires_in: 1.hour
}

# app/controllers/api/v1/posts_controller.rb
class PostsController &#x3C; BaseController
  def index
    posts = Rails.cache.fetch(cache_key_for_posts, expires_in: 30.minutes) do
      Post.published
          .includes(:user, :tags)
          .order(created_at: :desc)
          .limit(100)
          .to_a # 配列に変換してキャッシュ
    end
    
    render json: posts
  end
  
  def show
    post = Rails.cache.fetch("post/#{params[:id]}", expires_in: 1.hour) do
      Post.includes(:user, :tags, comments: :user)
          .find(params[:id])
    end
    
    # ETags使用
    if stale?(post)
      render json: post, serializer: PostDetailSerializer
    end
  end
  
  private
  
  def cache_key_for_posts
    "posts/#{params[:page]}/#{params[:per_page]}/#{Post.maximum(:updated_at)}"
  end
end

# app/models/post.rb
class Post &#x3C; ApplicationRecord
  # キャッシュの自動無効化
  after_commit :clear_cache
  
  private
  
  def clear_cache
    Rails.cache.delete("post/#{id}")
    Rails.cache.delete_matched("posts/*")
  end
end

# Fragment Caching in Serializers
class PostSerializer &#x3C; ActiveModel::Serializer
  cache key: 'post', expires_in: 3.hours
  
  attributes :id, :title, :content
  has_many :comments
  
  def cache_key
    "#{object.cache_key}/#{object.comments.maximum(:updated_at)}"
  end
end
</code></pre>
<h3 id="データベース最適化">データベース最適化</h3>
<pre><code class="language-ruby"># app/models/concerns/searchable.rb
module Searchable
  extend ActiveSupport::Concern
  
  included do
    # PostgreSQL全文検索
    scope :search, ->(query) {
      return all if query.blank?
      
      # tsvectorカラムを使用（マイグレーションで追加）
      where("search_vector @@ plainto_tsquery('english', ?)", query)
    }
  end
end

# db/migrate/add_search_vector_to_posts.rb
class AddSearchVectorToPosts &#x3C; ActiveRecord::Migration[7.0]
  def up
    # tsvectorカラムを追加
    add_column :posts, :search_vector, :tsvector
    
    # インデックスを追加
    add_index :posts, :search_vector, using: :gin
    
    # トリガーを作成
    execute &#x3C;&#x3C;-SQL
      CREATE TRIGGER posts_search_vector_update
      BEFORE INSERT OR UPDATE ON posts
      FOR EACH ROW EXECUTE FUNCTION
      tsvector_update_trigger(search_vector, 'pg_catalog.english', title, content);
    SQL
  end
  
  def down
    remove_column :posts, :search_vector
  end
end

# 複合インデックスの活用
class AddCompoundIndexes &#x3C; ActiveRecord::Migration[7.0]
  def change
    # よく一緒に検索される条件
    add_index :posts, [:user_id, :published, :created_at]
    add_index :posts, [:published, :created_at]
    
    # 部分インデックス（条件付きインデックス）
    add_index :posts, :created_at, where: "published = true", name: 'index_published_posts_on_created_at'
  end
end

# クエリ最適化
class Post &#x3C; ApplicationRecord
  # バッチ処理
  def self.process_all
    find_each(batch_size: 1000) do |post|
      post.process
    end
  end
  
  # SELECT句の最適化
  scope :minimal, -> {
    select(:id, :title, :created_at)
  }
  
  # EXISTS使用
  scope :with_comments, -> {
    where('EXISTS (SELECT 1 FROM comments WHERE comments.post_id = posts.id)')
  }
  
  # Window関数の活用
  scope :ranked_by_likes, -> {
    select('posts.*, RANK() OVER (ORDER BY likes_count DESC) as rank')
  }
end
</code></pre>
<h3 id="バックグラウンドジョブ">バックグラウンドジョブ</h3>
<pre><code class="language-ruby"># Gemfile
gem 'sidekiq'
gem 'redis'

# app/jobs/notification_job.rb
class NotificationJob &#x3C; ApplicationJob
  queue_as :default
  
  def perform(user_id, notification_type, data = {})
    user = User.find(user_id)
    
    case notification_type
    when 'new_comment'
      NotificationService.send_new_comment_notification(user, data)
    when 'new_like'
      NotificationService.send_new_like_notification(user, data)
    end
  end
end

# app/controllers/api/v1/comments_controller.rb
def create
  comment = @post.comments.build(comment_params)
  comment.user = current_user
  
  if comment.save
    # 非同期で通知を送信
    NotificationJob.perform_later(
      @post.user_id,
      'new_comment',
      { comment_id: comment.id }
    )
    
    render json: comment, status: :created
  else
    render json: { errors: comment.errors }, status: :unprocessable_entity
  end
end

# app/services/heavy_operation_service.rb
class HeavyOperationService
  def self.process_async(data)
    # Sidekiqで非同期実行
    ProcessingWorker.perform_async(data)
    
    # ジョブIDを返す
    { job_id: SecureRandom.uuid, status: 'processing' }
  end
end

# app/workers/processing_worker.rb
class ProcessingWorker
  include Sidekiq::Worker
  
  sidekiq_options retry: 3, dead: false
  
  def perform(data)
    # 重い処理
    result = ComplexCalculation.new(data).execute
    
    # 結果をRedisに保存
    Rails.cache.write("processing_result_#{data['id']}", result, expires_in: 1.day)
    
    # WebSocketで通知（Action Cable使用）
    ActionCable.server.broadcast(
      "processing_#{data['user_id']}",
      { status: 'completed', result: result }
    )
  end
end
</code></pre>
<h2 id="graphql実装">GraphQL実装</h2>
<h3 id="graphql基本セットアップ">GraphQL基本セットアップ</h3>
<pre><code class="language-ruby"># Gemfile
gem 'graphql'
gem 'graphiql-rails', group: :development

# app/graphql/types/base_object.rb
module Types
  class BaseObject &#x3C; GraphQL::Schema::Object
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)
    field_class Types::BaseField
  end
end

# app/graphql/types/user_type.rb
module Types
  class UserType &#x3C; Types::BaseObject
    field :id, ID, null: false
    field :email, String, null: false
    field :name, String, null: true
    field :posts, [Types::PostType], null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
    
    # カスタムフィールド
    field :post_count, Integer, null: false
    
    def post_count
      object.posts.count
    end
    
    # 認証が必要なフィールド
    field :private_info, String, null: true
    
    def private_info
      return nil unless context[:current_user] == object
      object.private_info
    end
  end
end

# app/graphql/types/post_type.rb
module Types
  class PostType &#x3C; Types::BaseObject
    field :id, ID, null: false
    field :title, String, null: false
    field :content, String, null: false
    field :published, Boolean, null: false
    field :user, Types::UserType, null: false
    field :comments, [Types::CommentType], null: true
    field :tags, [Types::TagType], null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end

# app/graphql/types/query_type.rb
module Types
  class QueryType &#x3C; Types::BaseObject
    # ユーザー一覧
    field :users, [Types::UserType], null: false do
      argument :limit, Integer, required: false, default_value: 20
      argument :offset, Integer, required: false, default_value: 0
    end
    
    def users(limit:, offset:)
      User.limit(limit).offset(offset)
    end
    
    # 単一ユーザー
    field :user, Types::UserType, null: true do
      argument :id, ID, required: true
    end
    
    def user(id:)
      User.find_by(id: id)
    end
    
    # 投稿検索
    field :posts, Types::PostType.connection_type, null: false do
      argument :filter, Types::PostFilterType, required: false
      argument :order_by, Types::PostOrderType, required: false
    end
    
    def posts(filter: nil, order_by: nil)
      scope = Post.published
      scope = apply_filter(scope, filter) if filter
      scope = apply_order(scope, order_by) if order_by
      scope
    end
    
    private
    
    def apply_filter(scope, filter)
      scope = scope.where(user_id: filter.user_id) if filter.user_id
      scope = scope.search(filter.search) if filter.search
      scope = scope.where('created_at >= ?', filter.from_date) if filter.from_date
      scope = scope.where('created_at &#x3C;= ?', filter.to_date) if filter.to_date
      scope
    end
    
    def apply_order(scope, order_by)
      case order_by
      when 'CREATED_AT_ASC'
        scope.order(created_at: :asc)
      when 'CREATED_AT_DESC'
        scope.order(created_at: :desc)
      when 'TITLE_ASC'
        scope.order(title: :asc)
      else
        scope
      end
    end
  end
end

# app/graphql/types/mutation_type.rb
module Types
  class MutationType &#x3C; Types::BaseObject
    field :create_post, mutation: Mutations::CreatePost
    field :update_post, mutation: Mutations::UpdatePost
    field :delete_post, mutation: Mutations::DeletePost
    field :login, mutation: Mutations::Login
    field :register, mutation: Mutations::Register
  end
end

# app/graphql/mutations/create_post.rb
module Mutations
  class CreatePost &#x3C; BaseMutation
    # 引数の定義
    argument :title, String, required: true
    argument :content, String, required: true
    argument :published, Boolean, required: false, default_value: false
    argument :tag_ids, [ID], required: false
    
    # 戻り値の定義
    field :post, Types::PostType, null: true
    field :errors, [String], null: false
    
    def resolve(title:, content:, published:, tag_ids: [])
      # 認証チェック
      return { post: nil, errors: ['Not authenticated'] } unless context[:current_user]
      
      post = context[:current_user].posts.build(
        title: title,
        content: content,
        published: published
      )
      
      post.tag_ids = tag_ids if tag_ids.present?
      
      if post.save
        { post: post, errors: [] }
      else
        { post: nil, errors: post.errors.full_messages }
      end
    end
  end
end
</code></pre>
<h3 id="graphql認証とn1対策">GraphQL認証とN+1対策</h3>
<pre><code class="language-ruby"># app/graphql/my_api_schema.rb
class MyApiSchema &#x3C; GraphQL::Schema
  mutation(Types::MutationType)
  query(Types::QueryType)
  
  # GraphQL-Batch for N+1 prevention
  use GraphQL::Batch
  
  # Query complexity prevention
  max_complexity 300
  max_depth 10
  
  def self.unauthorized_object(error)
    raise GraphQL::ExecutionError, "You don't have permission to access #{error.object}"
  end
end

# app/graphql/loaders/association_loader.rb
class Loaders::AssociationLoader &#x3C; GraphQL::Batch::Loader
  def initialize(model, association_name)
    @model = model
    @association_name = association_name
  end
  
  def perform(records)
    preload_association(records)
    records.each { |record| fulfill(record, read_association(record)) }
  end
  
  private
  
  def preload_association(records)
    ActiveRecord::Associations::Preloader.new(
      records: records,
      associations: @association_name
    ).call
  end
  
  def read_association(record)
    record.public_send(@association_name)
  end
end

# app/graphql/types/post_type.rb
module Types
  class PostType &#x3C; Types::BaseObject
    field :comments, [Types::CommentType], null: true
    
    # N+1を防ぐためのDataLoader使用
    def comments
      Loaders::AssociationLoader.for(Post, :comments).load(object)
    end
    
    field :user, Types::UserType, null: false
    
    def user
      Loaders::RecordLoader.for(User).load(object.user_id)
    end
  end
end

# app/controllers/graphql_controller.rb
class GraphqlController &#x3C; ApplicationController
  skip_before_action :verify_authenticity_token
  
  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    
    context = {
      current_user: current_user,
      request: request
    }
    
    result = MyApiSchema.execute(
      query,
      variables: variables,
      context: context,
      operation_name: operation_name
    )
    
    render json: result
  rescue StandardError => e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end
  
  private
  
  def current_user
    token = request.headers['Authorization']&#x26;.split(' ')&#x26;.last
    return nil unless token
    
    decoded = JsonWebToken.decode(token)
    User.find(decoded[:user_id])
  rescue StandardError
    nil
  end
  
  def prepare_variables(variables_param)
    case variables_param
    when String
      variables_param.present? ? JSON.parse(variables_param) || {} : {}
    when Hash
      variables_param
    when ActionController::Parameters
      variables_param.to_unsafe_hash
    when nil
      {}
    else
      raise ArgumentError, "Unexpected parameter: #{variables_param}"
    end
  end
  
  def handle_error_in_development(e)
    logger.error e.message
    logger.error e.backtrace.join("\n")
    
    render json: {
      errors: [{ message: e.message, backtrace: e.backtrace }],
      data: {}
    }, status: 500
  end
end
</code></pre>
<h2 id="テスト戦略">テスト戦略</h2>
<h3 id="rspecでのapi-テスト">RSpecでのAPI テスト</h3>
<pre><code class="language-ruby"># spec/rails_helper.rb
require 'spec_helper'
ENV['RAILS_ENV'] ||= 'test'
require_relative '../config/environment'

RSpec.configure do |config|
  config.include FactoryBot::Syntax::Methods
  config.include RequestSpecHelper, type: :request
  
  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end
end

# spec/support/request_spec_helper.rb
module RequestSpecHelper
  def json
    JSON.parse(response.body)
  end
  
  def auth_headers(user)
    token = JsonWebToken.encode(user_id: user.id)
    { 'Authorization' => "Bearer #{token}" }
  end
end

# spec/requests/api/v1/posts_spec.rb
require 'rails_helper'

RSpec.describe 'Posts API', type: :request do
  let(:user) { create(:user) }
  let(:headers) { auth_headers(user) }
  
  describe 'GET /api/v1/posts' do
    let!(:posts) { create_list(:post, 10, published: true) }
    
    before { get '/api/v1/posts', params: {}, headers: headers }
    
    it 'returns posts' do
      expect(json).not_to be_empty
      expect(json['data'].size).to eq(10)
    end
    
    it 'returns status code 200' do
      expect(response).to have_http_status(200)
    end
    
    context 'with pagination' do
      before do
        get '/api/v1/posts', params: { page: 2, per_page: 5 }, headers: headers
      end
      
      it 'returns paginated results' do
        expect(json['data'].size).to eq(5)
        expect(json['meta']['current_page']).to eq(2)
      end
    end
    
    context 'with filters' do
      let!(:user_posts) { create_list(:post, 3, user: user, published: true) }
      
      before do
        get '/api/v1/posts', params: { user_id: user.id }, headers: headers
      end
      
      it 'returns filtered posts' do
        expect(json['data'].size).to eq(3)
        expect(json['data'].all? { |p| p['user_id'] == user.id }).to be true
      end
    end
  end
  
  describe 'POST /api/v1/posts' do
    let(:valid_attributes) do
      { post: { title: 'Test Post', content: 'Test content', published: true } }
    end
    
    context 'when the request is valid' do
      before { post '/api/v1/posts', params: valid_attributes, headers: headers }
      
      it 'creates a post' do
        expect(json['data']['title']).to eq('Test Post')
      end
      
      it 'returns status code 201' do
        expect(response).to have_http_status(201)
      end
    end
    
    context 'when the request is invalid' do
      let(:invalid_attributes) { { post: { title: '' } } }
      
      before { post '/api/v1/posts', params: invalid_attributes, headers: headers }
      
      it 'returns status code 422' do
        expect(response).to have_http_status(422)
      end
      
      it 'returns a validation failure message' do
        expect(json['errors']).to include("Title can't be blank")
      end
    end
  end
  
  describe 'PUT /api/v1/posts/:id' do
    let(:post_record) { create(:post, user: user) }
    let(:valid_attributes) { { post: { title: 'Updated Title' } } }
    
    before do
      put "/api/v1/posts/#{post_record.id}", 
          params: valid_attributes, 
          headers: headers
    end
    
    context 'when the record exists' do
      it 'updates the record' do
        expect(json['data']['title']).to eq('Updated Title')
      end
      
      it 'returns status code 200' do
        expect(response).to have_http_status(200)
      end
    end
    
    context 'when user is not the owner' do
      let(:other_user) { create(:user) }
      let(:headers) { auth_headers(other_user) }
      
      it 'returns status code 403' do
        expect(response).to have_http_status(403)
      end
    end
  end
  
  describe 'DELETE /api/v1/posts/:id' do
    let!(:post_record) { create(:post, user: user) }
    
    before { delete "/api/v1/posts/#{post_record.id}", headers: headers }
    
    it 'returns status code 204' do
      expect(response).to have_http_status(204)
    end
    
    it 'deletes the record' do
      expect(Post.find_by(id: post_record.id)).to be_nil
    end
  end
end

# spec/integration/api_integration_spec.rb
RSpec.describe 'API Integration', type: :request do
  describe 'complete user flow' do
    it 'allows user registration, login, and resource creation' do
      # ユーザー登録
      post '/api/v1/auth/register', params: {
        email: 'test@example.com',
        password: 'password123',
        name: 'Test User'
      }
      
      expect(response).to have_http_status(201)
      token = json['token']
      
      # ログイン
      post '/api/v1/auth/login', params: {
        email: 'test@example.com',
        password: 'password123'
      }
      
      expect(response).to have_http_status(200)
      expect(json['token']).to be_present
      
      # リソース作成
      post '/api/v1/posts', 
           params: { post: { title: 'Test', content: 'Content' } },
           headers: { 'Authorization' => "Bearer #{token}" }
      
      expect(response).to have_http_status(201)
      expect(json['data']['title']).to eq('Test')
    end
  end
end
</code></pre>
<h2 id="セキュリティ対策">セキュリティ対策</h2>
<h3 id="api-セキュリティベストプラクティス">API セキュリティベストプラクティス</h3>
<pre><code class="language-ruby"># config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins ENV.fetch('ALLOWED_ORIGINS', '*').split(',')
    
    resource '*',
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete, :options, :head],
      credentials: true,
      max_age: 86400
  end
end

# app/controllers/application_controller.rb
class ApplicationController &#x3C; ActionController::API
  # Rate limiting
  include Rack::Attack
  
  # SQL Injection対策は標準のActive Recordメソッドを使用
  # XSS対策はAPIモードでは基本的に不要（JSONレスポンスのため）
  
  # CSRF対策（APIでは通常不要だが、Cookie認証の場合は必要）
  # protect_from_forgery with: :null_session
  
  # Strong Parameters
  before_action :configure_permitted_parameters, if: :devise_controller?
  
  # APIキー認証（オプション）
  before_action :authenticate_api_key!, if: :api_key_required?
  
  private
  
  def authenticate_api_key!
    api_key = request.headers['X-API-Key']
    
    unless api_key &#x26;&#x26; ApiKey.active.exists?(key: api_key)
      render json: { error: 'Invalid API key' }, status: :unauthorized
    end
  end
  
  def api_key_required?
    # 特定のエンドポイントでAPIキーを要求
    request.path.start_with?('/api/admin')
  end
end

# config/initializers/rack_attack.rb
class Rack::Attack
  # Rate limiting
  throttle('api/ip', limit: 100, period: 5.minutes) do |req|
    req.ip if req.path.start_with?('/api')
  end
  
  # ログイン試行の制限
  throttle('logins/ip', limit: 5, period: 20.seconds) do |req|
    if req.path == '/api/v1/auth/login' &#x26;&#x26; req.post?
      req.ip
    end
  end
  
  # ユーザーごとの制限
  throttle('api/user', limit: 1000, period: 1.hour) do |req|
    if req.env['HTTP_AUTHORIZATION']
      token = req.env['HTTP_AUTHORIZATION'].split(' ').last
      decoded = JsonWebToken.decode(token) rescue nil
      decoded[:user_id] if decoded
    end
  end
  
  # Blockルール
  blocklist('block suspicious requests') do |req|
    # SQLインジェクションのパターンを検出
    Rack::Attack::Fail2Ban.filter("pentesters-#{req.ip}", maxretry: 3, findtime: 10.minutes, bantime: 30.minutes) do
      CGI.unescape(req.query_string) =~ /(%27|')|(%3B|;)|(&#x3C;|%3C)|(>|%3E)/i
    end
  end
end

# app/services/security_audit_service.rb
class SecurityAuditService
  def self.audit_request(request, user = nil)
    AuditLog.create!(
      user: user,
      action: "#{request.method} #{request.path}",
      ip_address: request.remote_ip,
      user_agent: request.user_agent,
      parameters: filter_sensitive_params(request.params),
      performed_at: Time.current
    )
  end
  
  private
  
  def self.filter_sensitive_params(params)
    Rails.application.config.filter_parameters.each do |param|
      params = params.deep_transform_values do |value|
        value.to_s.include?(param.to_s) ? '[FILTERED]' : value
      end
    end
    params
  end
end
</code></pre>
<h2 id="バージョニングとデプロイ">バージョニングとデプロイ</h2>
<h3 id="apiバージョニング戦略">APIバージョニング戦略</h3>
<pre><code class="language-ruby"># URLパスベースのバージョニング
Rails.application.routes.draw do
  namespace :api do
    namespace :v1 do
      resources :posts
    end
    
    namespace :v2 do
      resources :posts do
        member do
          post :react
        end
      end
    end
  end
  
  # デフォルトバージョンへのリダイレクト
  get 'api/posts', to: redirect('/api/v1/posts')
end

# ヘッダーベースのバージョニング
class ApplicationController &#x3C; ActionController::API
  before_action :set_api_version
  
  private
  
  def set_api_version
    @api_version = request.headers['Accept-Version'] || 'v1'
    
    unless %w[v1 v2].include?(@api_version)
      render json: { error: 'Invalid API version' }, status: :bad_request
    end
  end
end

# app/controllers/api/posts_controller.rb
module Api
  class PostsController &#x3C; BaseController
    def index
      case @api_version
      when 'v1'
        render json: posts_v1
      when 'v2'
        render json: posts_v2
      end
    end
    
    private
    
    def posts_v1
      Post.all.as_json(only: [:id, :title, :content])
    end
    
    def posts_v2
      Post.all.as_json(
        only: [:id, :title, :content],
        methods: [:reactions_count, :views_count]
      )
    end
  end
end
</code></pre>
<h3 id="デプロイ設定">デプロイ設定</h3>
<pre><code class="language-ruby"># config/deploy.rb (Capistrano)
lock '~> 3.17.0'

set :application, 'my_api'
set :repo_url, 'git@github.com:username/my_api.git'
set :deploy_to, '/var/www/my_api'
set :rbenv_ruby, '3.2.0'

append :linked_files, 'config/database.yml', 'config/master.key'
append :linked_dirs, 'log', 'tmp/pids', 'tmp/cache', 'tmp/sockets', 'public/system'

namespace :deploy do
  desc 'Restart application'
  task :restart do
    on roles(:app), in: :sequence, wait: 5 do
      execute :touch, release_path.join('tmp/restart.txt')
    end
  end
  
  after :publishing, :restart
end

# docker-compose.yml
version: '3.8'
services:
  db:
    image: postgres:14
    environment:
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    command: redis-server
    volumes:
      - redis_data:/data
  
  web:
    build: .
    command: bundle exec puma -C config/puma.rb
    volumes:
      - .:/app
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
    environment:
      DATABASE_URL: postgresql://postgres:password@db/my_api_production
      REDIS_URL: redis://redis:6379/0
  
  sidekiq:
    build: .
    command: bundle exec sidekiq
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    environment:
      DATABASE_URL: postgresql://postgres:password@db/my_api_production
      REDIS_URL: redis://redis:6379/0

volumes:
  postgres_data:
  redis_data:

# Dockerfile
FROM ruby:3.2.0
RUN apt-get update -qq &#x26;&#x26; apt-get install -y postgresql-client
WORKDIR /app
COPY Gemfile* ./
RUN bundle install
COPY . .
EXPOSE 3000
CMD ["rails", "server", "-b", "0.0.0.0"]
</code></pre>
<h2 id="まとめ">まとめ</h2>
<h3 id="rails-api開発チェックリスト">Rails API開発チェックリスト</h3>
<p><strong>設計</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> RESTful原則に従ったURL設計</li>
<li class="task-list-item"><input type="checkbox" disabled> 適切なHTTPステータスコードの使用</li>
<li class="task-list-item"><input type="checkbox" disabled> 一貫性のあるレスポンスフォーマット</li>
<li class="task-list-item"><input type="checkbox" disabled> エラーハンドリングの実装</li>
</ul>
<p><strong>パフォーマンス</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> N+1問題の解決（includes, eager_load）</li>
<li class="task-list-item"><input type="checkbox" disabled> 適切なインデックスの設定</li>
<li class="task-list-item"><input type="checkbox" disabled> キャッシング戦略の実装</li>
<li class="task-list-item"><input type="checkbox" disabled> バックグラウンドジョブの活用</li>
</ul>
<p><strong>セキュリティ</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> 認証・認可の実装</li>
<li class="task-list-item"><input type="checkbox" disabled> Rate limitingの設定</li>
<li class="task-list-item"><input type="checkbox" disabled> CORS設定</li>
<li class="task-list-item"><input type="checkbox" disabled> SQLインジェクション対策</li>
</ul>
<p><strong>テスト</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> Request specの作成</li>
<li class="task-list-item"><input type="checkbox" disabled> 統合テストの実装</li>
<li class="task-list-item"><input type="checkbox" disabled> パフォーマンステスト</li>
<li class="task-list-item"><input type="checkbox" disabled> セキュリティテスト</li>
</ul>
<h3 id="面接での回答例">面接での回答例</h3>
<p><strong>Q: Rails APIモードの利点は？</strong></p>
<pre><code>A: Rails APIモードは通常のRailsから不要な機能を削除し、
API開発に最適化されています。

主な利点：
1. 軽量化：ビュー層やアセットパイプラインを除外
2. パフォーマンス：メモリ使用量削減、レスポンス速度向上
3. ミドルウェア最適化：API用に最適化された構成

実装面では、ApplicationControllerがActionController::APIを
継承し、JSONレンダリングに特化した設定になっています。
</code></pre>
<p><strong>Q: N+1問題をどう解決しますか？</strong></p>
<pre><code>A: N+1問題は主に3つの方法で解決します：

1. includes：関連データを事前読み込み
   Post.includes(:comments, :user)

2. eager_load：LEFT JOINで一度に取得
   Post.eager_load(:comments).where(comments: { approved: true })

3. カウンターキャッシュ：集計値をカラムに保存
   has_many :comments, counter_cache: true

開発環境ではBullet gemで検出し、
本番環境ではNew RelicやDatadogでモニタリングします。
</code></pre>
<h3 id="継続的な学習のために">継続的な学習のために</h3>
<ol>
<li><strong>実践プロジェクト</strong>: 実際のAPIを構築</li>
<li><strong>パフォーマンス測定</strong>: Apache Bench、JMeterでの負荷テスト</li>
<li><strong>最新動向</strong>: Rails 7.1の新機能、Hotwire Turbo</li>
<li><strong>他言語との比較</strong>: Go、Node.jsのAPI開発も学習</li>
</ol>
<h2 id="参考リンク">参考リンク</h2>
<ul>
<li><a href="https://guides.rubyonrails.org/api_app.html">Ruby on Rails Guides</a></li>
<li><a href="https://jsonapi.org/">JSON:API Specification</a></li>
<li><a href="https://graphql-ruby.org/">GraphQL Ruby</a></li>
<li><a href="https://www.speedshop.co/">Rails Performance</a></li>
<li><a href="https://guides.rubyonrails.org/security.html">Rails Security Guide</a></li>
</ul>
<hr>
<p><em>この記事は、Ruby on Rails API開発における3年以上の実務経験で必要な知識を網羅的にまとめました。</em></p></article><nav class="mt-8 pt-4 border-t border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-aa7deb192a774533.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[87555,[],\"\"]\n3:I[31295,[],\"\"]\n5:I[59665,[],\"MetadataBoundary\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[26614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/19bdf9af4d1ae4d4.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"JSnVZeqt76ScGbbxQqRWu\",\"p\":\"\",\"c\":[\"\",\"blog\",\"rails-api-development-complete-guide\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"rails-api-development-complete-guide\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/19bdf9af4d1ae4d4.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png\",\"type\":\"image/png\"}]}],[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"rails-api-development-complete-guide\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[\"$\",\"$L5\",null,{\"children\":\"$L6\"}],null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"I6gu-AUKXMbbRq77GYUhV\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:\"$Sreact.suspense\"\n10:I[74911,[],\"AsyncMetadata\"]\n6:[\"$\",\"$f\",null,{\"fallback\":null,\"children\":[\"$\",\"$L10\",null,{\"promise\":\"$@11\"}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"12:I[6874,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"\"]\n14:I[31203,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"default\"]\n15:I[4197,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"default\"]\n13:Td8eb,"])</script><script>self.__next_f.push([1,"\u003cp\u003eRuby on Rails開発経験3年以上を求める求人で「API開発経験」は必須要件です。しかし、単に「Rails APIモードを使える」だけでは不十分です。本記事では、RESTful API設計の原則から、認証・認可、パフォーマンス最適化、GraphQL実装まで、実務で必要な知識を網羅的に解説します。\u003c/p\u003e\n\u003ch2 id=\"-初心者向け解説\"\u003e💡 初心者向け解説\u003c/h2\u003e\n\u003ch3 id=\"apiとは\"\u003eAPIとは？\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e簡単に言うと\u003c/strong\u003e: アプリケーション同士が会話するための窓口です。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e例：レストランの注文システム\nWebサイト/アプリ：お客様（フロントエンド）\nAPI：ウェイター（通信の仲介）\nRails：厨房（バックエンド）\nデータベース：食材庫\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"なぜrails-apiが選ばれるのか\"\u003eなぜRails APIが選ばれるのか？\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e開発速度\u003c/strong\u003e: 規約重視で高速開発が可能\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e成熟度\u003c/strong\u003e: 豊富なGemエコシステム\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eスケーラビリティ\u003c/strong\u003e: 大規模サービスでの実績\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eメンテナンス性\u003c/strong\u003e: Railsの規約による統一性\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"-目次\"\u003e📚 目次\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#rails-api%E5%9F%BA%E7%A4%8E\"\u003eRails API基礎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#restful-api%E8%A8%AD%E8%A8%88\"\u003eRESTful API設計\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AA%8D%E8%A8%BC%E8%AA%8D%E5%8F%AF%E3%81%AE%E5%AE%9F%E8%A3%85\"\u003e認証・認可の実装\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B9%E8%A8%AD%E8%A8%88\"\u003eエラーハンドリングとレスポンス設計\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%9C%80%E9%81%A9%E5%8C%96\"\u003eパフォーマンス最適化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#graphql%E5%AE%9F%E8%A3%85\"\u003eGraphQL実装\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%86%E3%82%B9%E3%83%88%E6%88%A6%E7%95%A5\"\u003eテスト戦略\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E5%AF%BE%E7%AD%96\"\u003eセキュリティ対策\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4\"\u003eバージョニングとデプロイ\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"rails-api基礎\"\u003eRails API基礎\u003c/h2\u003e\n\u003ch3 id=\"rails-apiモードのセットアップ\"\u003eRails APIモードのセットアップ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# APIモードでRailsアプリケーション作成\nrails new my_api --api --database=postgresql\n\n# 主な違い：\n# - ApplicationControllerがActionController::APIを継承\n# - ビュー層、アセットパイプライン、セッション関連が除外\n# - CORSやJSONレンダリングに最適化\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"基本的なapiコントローラー\"\u003e基本的なAPIコントローラー\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/api/v1/base_controller.rb\nmodule Api\n  module V1\n    class BaseController \u0026#x3C; ApplicationController\n      # 共通のエラーハンドリング\n      rescue_from ActiveRecord::RecordNotFound, with: :not_found\n      rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity\n      rescue_from ActionController::ParameterMissing, with: :bad_request\n\n      private\n\n      def not_found(exception)\n        render json: { \n          error: {\n            message: exception.message,\n            type: 'ResourceNotFound'\n          }\n        }, status: :not_found\n      end\n\n      def unprocessable_entity(exception)\n        render json: { \n          error: {\n            message: exception.record.errors.full_messages.join(', '),\n            type: 'ValidationError',\n            details: exception.record.errors.details\n          }\n        }, status: :unprocessable_entity\n      end\n\n      def bad_request(exception)\n        render json: { \n          error: {\n            message: exception.message,\n            type: 'BadRequest'\n          }\n        }, status: :bad_request\n      end\n\n      # ページネーション用メソッド\n      def paginate(resource)\n        resource.page(params[:page] || 1).per(params[:per_page] || 20)\n      end\n\n      # メタ情報の追加\n      def render_with_meta(resource, options = {})\n        if resource.respond_to?(:current_page)\n          options[:meta] = pagination_meta(resource)\n        end\n        render json: resource, **options\n      end\n\n      def pagination_meta(resource)\n        {\n          current_page: resource.current_page,\n          total_pages: resource.total_pages,\n          total_count: resource.total_count,\n          per_page: resource.limit_value\n        }\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"serializerの実装activemodelserializers\"\u003eSerializerの実装（ActiveModel::Serializers）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'active_model_serializers', '~\u003e 0.10.0'\n\n# app/serializers/api/v1/user_serializer.rb\nmodule Api\n  module V1\n    class UserSerializer \u0026#x3C; ActiveModel::Serializer\n      attributes :id, :email, :name, :avatar_url, :created_at\n      \n      # 関連の定義\n      has_many :posts\n      has_one :profile\n      \n      # カスタム属性\n      attribute :full_name do\n        \"#{object.first_name} #{object.last_name}\"\n      end\n      \n      # 条件付き属性\n      attribute :admin_info, if: :is_admin?\n      \n      def admin_info\n        {\n          last_login: object.last_login_at,\n          permissions: object.permissions\n        }\n      end\n      \n      def is_admin?\n        scope \u0026#x26;\u0026#x26; scope.admin?\n      end\n      \n      # URLヘルパーの使用\n      link(:self) { api_v1_user_url(object) }\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"restful-api設計\"\u003eRESTful API設計\u003c/h2\u003e\n\u003ch3 id=\"リソースベースのurl設計\"\u003eリソースベースのURL設計\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/routes.rb\nRails.application.routes.draw do\n  namespace :api do\n    namespace :v1 do\n      # リソースフルなルーティング\n      resources :users do\n        member do\n          post :activate\n          post :deactivate\n        end\n        \n        collection do\n          get :search\n          get :export\n        end\n        \n        # ネストしたリソース\n        resources :posts, shallow: true do\n          resources :comments\n          resources :likes, only: [:create, :destroy]\n        end\n      end\n      \n      # カスタムルート\n      post 'auth/login', to: 'authentication#login'\n      post 'auth/logout', to: 'authentication#logout'\n      post 'auth/refresh', to: 'authentication#refresh'\n      \n      # 検索エンドポイント\n      namespace :search do\n        get 'users', to: 'users#index'\n        get 'posts', to: 'posts#index'\n        get 'global', to: 'global#index'\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"httpステータスコードの適切な使用\"\u003eHTTPステータスコードの適切な使用\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/api/v1/posts_controller.rb\nmodule Api\n  module V1\n    class PostsController \u0026#x3C; BaseController\n      before_action :authenticate_user!\n      before_action :set_post, only: [:show, :update, :destroy]\n      before_action :authorize_user!, only: [:update, :destroy]\n\n      # GET /api/v1/posts\n      def index\n        posts = Post.published\n                   .includes(:user, :tags, :comments)\n                   .search(params[:q])\n                   .filter_by_tags(params[:tags])\n                   .order(created_at: :desc)\n        \n        posts = paginate(posts)\n        \n        render_with_meta(\n          posts,\n          each_serializer: PostSerializer,\n          include: ['user', 'tags']\n        )\n      end\n\n      # GET /api/v1/posts/:id\n      def show\n        render json: @post, \n               serializer: PostDetailSerializer,\n               include: ['user', 'comments', 'comments.user']\n      end\n\n      # POST /api/v1/posts\n      def create\n        post = current_user.posts.build(post_params)\n        \n        if post.save\n          # 201 Created\n          render json: post, \n                 serializer: PostSerializer,\n                 status: :created,\n                 location: api_v1_post_url(post)\n        else\n          # 422 Unprocessable Entity\n          render json: { \n            errors: post.errors.full_messages,\n            details: post.errors.details \n          }, status: :unprocessable_entity\n        end\n      end\n\n      # PATCH/PUT /api/v1/posts/:id\n      def update\n        if @post.update(post_params)\n          # 200 OK\n          render json: @post, serializer: PostSerializer\n        else\n          # 422 Unprocessable Entity\n          render json: { \n            errors: @post.errors.full_messages \n          }, status: :unprocessable_entity\n        end\n      end\n\n      # DELETE /api/v1/posts/:id\n      def destroy\n        @post.destroy\n        # 204 No Content\n        head :no_content\n      end\n\n      private\n\n      def set_post\n        @post = Post.find(params[:id])\n      end\n\n      def authorize_user!\n        # 403 Forbidden\n        unless @post.user == current_user || current_user.admin?\n          render json: { \n            error: 'You are not authorized to perform this action' \n          }, status: :forbidden\n        end\n      end\n\n      def post_params\n        params.require(:post).permit(\n          :title, \n          :content, \n          :published, \n          tag_ids: [],\n          images_attributes: [:id, :url, :caption, :_destroy]\n        )\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"フィルタリングとソート\"\u003eフィルタリングとソート\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/models/concerns/filterable.rb\nmodule Filterable\n  extend ActiveSupport::Concern\n\n  module ClassMethods\n    def filter(filtering_params)\n      results = self.where(nil)\n      filtering_params.each do |key, value|\n        results = results.public_send(\"filter_by_#{key}\", value) if value.present?\n      end\n      results\n    end\n  end\nend\n\n# app/models/post.rb\nclass Post \u0026#x3C; ApplicationRecord\n  include Filterable\n  \n  belongs_to :user\n  has_many :comments, dependent: :destroy\n  has_and_belongs_to_many :tags\n  \n  # スコープ定義\n  scope :published, -\u003e { where(published: true) }\n  scope :draft, -\u003e { where(published: false) }\n  scope :recent, -\u003e { where('created_at \u003e ?', 1.week.ago) }\n  \n  # フィルタリング用スコープ\n  scope :filter_by_status, -\u003e(status) { \n    case status\n    when 'published' then published\n    when 'draft' then draft\n    else all\n    end\n  }\n  \n  scope :filter_by_user_id, -\u003e(user_id) { where(user_id: user_id) }\n  \n  scope :filter_by_tags, -\u003e(tag_names) {\n    joins(:tags).where(tags: { name: tag_names })\n  }\n  \n  scope :filter_by_date_range, -\u003e(from, to) {\n    where(created_at: from..to)\n  }\n  \n  # 全文検索\n  scope :search, -\u003e(query) {\n    return all if query.blank?\n    \n    where('title ILIKE :q OR content ILIKE :q', q: \"%#{query}%\")\n  }\n  \n  # ソート\n  scope :sort_by_field, -\u003e(field, direction = 'asc') {\n    safe_fields = %w[created_at updated_at title views_count]\n    safe_directions = %w[asc desc]\n    \n    field = 'created_at' unless safe_fields.include?(field)\n    direction = 'desc' unless safe_directions.include?(direction)\n    \n    order(field =\u003e direction)\n  }\nend\n\n# コントローラーでの使用\ndef index\n  posts = Post.filter(\n    status: params[:status],\n    user_id: params[:user_id],\n    tags: params[:tags]\n  ).sort_by_field(params[:sort], params[:direction])\n  \n  render json: paginate(posts)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"認証認可の実装\"\u003e認証・認可の実装\u003c/h2\u003e\n\u003ch3 id=\"jwt認証の実装\"\u003eJWT認証の実装\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'jwt'\ngem 'bcrypt'\n\n# app/lib/json_web_token.rb\nclass JsonWebToken\n  SECRET_KEY = Rails.application.credentials.secret_key_base || Rails.application.secrets.secret_key_base\n  \n  def self.encode(payload, exp = 24.hours.from_now)\n    payload[:exp] = exp.to_i\n    JWT.encode(payload, SECRET_KEY, 'HS256')\n  end\n  \n  def self.decode(token)\n    decoded = JWT.decode(token, SECRET_KEY, true, algorithm: 'HS256')[0]\n    HashWithIndifferentAccess.new(decoded)\n  rescue JWT::DecodeError =\u003e e\n    raise ExceptionHandler::InvalidToken, e.message\n  end\nend\n\n# app/controllers/concerns/exception_handler.rb\nmodule ExceptionHandler\n  extend ActiveSupport::Concern\n  \n  class AuthenticationError \u0026#x3C; StandardError; end\n  class InvalidToken \u0026#x3C; StandardError; end\n  class MissingToken \u0026#x3C; StandardError; end\n  class ExpiredToken \u0026#x3C; StandardError; end\n  \n  included do\n    rescue_from ExceptionHandler::AuthenticationError, with: :unauthorized_request\n    rescue_from ExceptionHandler::InvalidToken, with: :unauthorized_request\n    rescue_from ExceptionHandler::MissingToken, with: :unauthorized_request\n    rescue_from ExceptionHandler::ExpiredToken, with: :unauthorized_request\n  end\n  \n  private\n  \n  def unauthorized_request(e)\n    render json: { error: e.message }, status: :unauthorized\n  end\nend\n\n# app/controllers/concerns/authenticable.rb\nmodule Authenticable\n  extend ActiveSupport::Concern\n  \n  included do\n    before_action :authenticate_request\n    attr_reader :current_user\n  end\n  \n  private\n  \n  def authenticate_request\n    @current_user = AuthorizeApiRequest.new(request.headers).call\n  rescue StandardError =\u003e e\n    render json: { error: e.message }, status: :unauthorized\n  end\n  \n  def authenticate_user!\n    authenticate_request\n  end\nend\n\n# app/services/authorize_api_request.rb\nclass AuthorizeApiRequest\n  def initialize(headers = {})\n    @headers = headers\n  end\n  \n  def call\n    user\n  end\n  \n  private\n  \n  attr_reader :headers\n  \n  def user\n    @user ||= User.find(decoded_auth_token[:user_id]) if decoded_auth_token\n  rescue ActiveRecord::RecordNotFound =\u003e e\n    raise ExceptionHandler::InvalidToken, \"Invalid token: #{e.message}\"\n  end\n  \n  def decoded_auth_token\n    @decoded_auth_token ||= JsonWebToken.decode(http_auth_header)\n  end\n  \n  def http_auth_header\n    if headers['Authorization'].present?\n      return headers['Authorization'].split(' ').last\n    end\n    raise ExceptionHandler::MissingToken, 'Missing token'\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"認証コントローラー\"\u003e認証コントローラー\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/api/v1/authentication_controller.rb\nmodule Api\n  module V1\n    class AuthenticationController \u0026#x3C; BaseController\n      skip_before_action :authenticate_user!, only: [:login, :register]\n      \n      # POST /api/v1/auth/register\n      def register\n        user = User.new(user_params)\n        \n        if user.save\n          token = generate_token(user)\n          render json: {\n            user: UserSerializer.new(user),\n            token: token,\n            expires_at: 24.hours.from_now\n          }, status: :created\n        else\n          render json: { \n            errors: user.errors.full_messages \n          }, status: :unprocessable_entity\n        end\n      end\n      \n      # POST /api/v1/auth/login\n      def login\n        user = User.find_by(email: params[:email])\n        \n        if user\u0026#x26;.authenticate(params[:password])\n          token = generate_token(user)\n          \n          # ログイン履歴の記録\n          user.update(\n            last_login_at: Time.current,\n            last_login_ip: request.remote_ip\n          )\n          \n          render json: {\n            user: UserSerializer.new(user),\n            token: token,\n            expires_at: 24.hours.from_now\n          }\n        else\n          render json: { \n            error: 'Invalid email or password' \n          }, status: :unauthorized\n        end\n      end\n      \n      # POST /api/v1/auth/logout\n      def logout\n        # JWTの場合、クライアント側でトークンを削除\n        # オプション：トークンをブラックリストに追加\n        token = request.headers['Authorization']\u0026#x26;.split(' ')\u0026#x26;.last\n        BlacklistedToken.create(token: token, expires_at: 24.hours.from_now) if token\n        \n        head :no_content\n      end\n      \n      # POST /api/v1/auth/refresh\n      def refresh\n        # リフレッシュトークンの実装\n        refresh_token = params[:refresh_token]\n        \n        if valid_refresh_token?(refresh_token)\n          user = User.find_by(refresh_token: refresh_token)\n          new_token = generate_token(user)\n          \n          render json: {\n            token: new_token,\n            expires_at: 24.hours.from_now\n          }\n        else\n          render json: { \n            error: 'Invalid refresh token' \n          }, status: :unauthorized\n        end\n      end\n      \n      private\n      \n      def user_params\n        params.permit(:email, :password, :password_confirmation, :name)\n      end\n      \n      def generate_token(user)\n        JsonWebToken.encode(user_id: user.id)\n      end\n      \n      def valid_refresh_token?(token)\n        # リフレッシュトークンの検証ロジック\n        return false if token.blank?\n        \n        user = User.find_by(refresh_token: token)\n        user \u0026#x26;\u0026#x26; user.refresh_token_expires_at \u003e Time.current\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"認可pundit使用\"\u003e認可（Pundit使用）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'pundit'\n\n# app/policies/application_policy.rb\nclass ApplicationPolicy\n  attr_reader :user, :record\n\n  def initialize(user, record)\n    @user = user\n    @record = record\n  end\n\n  def index?\n    true\n  end\n\n  def show?\n    true\n  end\n\n  def create?\n    user.present?\n  end\n\n  def update?\n    user.present? \u0026#x26;\u0026#x26; (record.user == user || user.admin?)\n  end\n\n  def destroy?\n    update?\n  end\n\n  class Scope\n    attr_reader :user, :scope\n\n    def initialize(user, scope)\n      @user = user\n      @scope = scope\n    end\n\n    def resolve\n      scope.all\n    end\n  end\nend\n\n# app/policies/post_policy.rb\nclass PostPolicy \u0026#x3C; ApplicationPolicy\n  def index?\n    true\n  end\n  \n  def show?\n    record.published? || record.user == user || user\u0026#x26;.admin?\n  end\n  \n  def create?\n    user.present?\n  end\n  \n  def update?\n    record.user == user || user\u0026#x26;.admin?\n  end\n  \n  def destroy?\n    record.user == user || user\u0026#x26;.admin?\n  end\n  \n  def publish?\n    record.user == user || user\u0026#x26;.admin?\n  end\n  \n  class Scope \u0026#x3C; Scope\n    def resolve\n      if user\u0026#x26;.admin?\n        scope.all\n      elsif user\n        scope.where('published = ? OR user_id = ?', true, user.id)\n      else\n        scope.published\n      end\n    end\n  end\nend\n\n# コントローラーでの使用\nclass PostsController \u0026#x3C; BaseController\n  include Pundit\n  \n  def index\n    posts = policy_scope(Post)\n    render json: posts\n  end\n  \n  def show\n    post = Post.find(params[:id])\n    authorize post\n    render json: post\n  end\n  \n  def update\n    post = Post.find(params[:id])\n    authorize post\n    \n    if post.update(post_params)\n      render json: post\n    else\n      render json: { errors: post.errors }, status: :unprocessable_entity\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"エラーハンドリングとレスポンス設計\"\u003eエラーハンドリングとレスポンス設計\u003c/h2\u003e\n\u003ch3 id=\"統一的なエラーレスポンス\"\u003e統一的なエラーレスポンス\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/controllers/concerns/error_handler.rb\nmodule ErrorHandler\n  extend ActiveSupport::Concern\n  \n  included do\n    rescue_from StandardError, with: :handle_internal_server_error\n    rescue_from ActiveRecord::RecordNotFound, with: :handle_not_found\n    rescue_from ActiveRecord::RecordInvalid, with: :handle_unprocessable_entity\n    rescue_from ActionController::ParameterMissing, with: :handle_bad_request\n    rescue_from Pundit::NotAuthorizedError, with: :handle_forbidden\n    \n    # カスタムエラー\n    rescue_from CustomErrors::ValidationError, with: :handle_validation_error\n    rescue_from CustomErrors::AuthenticationError, with: :handle_authentication_error\n    rescue_from CustomErrors::RateLimitError, with: :handle_rate_limit\n  end\n  \n  private\n  \n  def handle_internal_server_error(exception)\n    logger.error exception.message\n    logger.error exception.backtrace.join(\"\\n\")\n    \n    if Rails.env.production?\n      render_error(500, 'Internal Server Error', 'An error occurred')\n    else\n      render_error(500, 'Internal Server Error', exception.message)\n    end\n  end\n  \n  def handle_not_found(exception)\n    render_error(404, 'Not Found', exception.message)\n  end\n  \n  def handle_unprocessable_entity(exception)\n    render_error(\n      422, \n      'Unprocessable Entity', \n      exception.record.errors.full_messages.join(', '),\n      exception.record.errors.details\n    )\n  end\n  \n  def handle_bad_request(exception)\n    render_error(400, 'Bad Request', exception.message)\n  end\n  \n  def handle_forbidden(exception)\n    render_error(403, 'Forbidden', 'You are not authorized to perform this action')\n  end\n  \n  def handle_validation_error(exception)\n    render_error(422, 'Validation Error', exception.message, exception.errors)\n  end\n  \n  def handle_authentication_error(exception)\n    render_error(401, 'Authentication Error', exception.message)\n  end\n  \n  def handle_rate_limit(exception)\n    response.headers['X-RateLimit-Limit'] = exception.limit.to_s\n    response.headers['X-RateLimit-Remaining'] = '0'\n    response.headers['X-RateLimit-Reset'] = exception.reset_at.to_i.to_s\n    \n    render_error(429, 'Too Many Requests', 'Rate limit exceeded')\n  end\n  \n  def render_error(status, error_type, message, details = nil)\n    error_response = {\n      error: {\n        status: status,\n        type: error_type,\n        message: message,\n        timestamp: Time.current.iso8601\n      }\n    }\n    \n    error_response[:error][:details] = details if details.present?\n    \n    render json: error_response, status: status\n  end\nend\n\n# app/lib/custom_errors.rb\nmodule CustomErrors\n  class BaseError \u0026#x3C; StandardError\n    attr_reader :status, :error_type, :details\n    \n    def initialize(message = nil, status = nil, error_type = nil, details = nil)\n      @status = status\n      @error_type = error_type\n      @details = details\n      super(message)\n    end\n  end\n  \n  class ValidationError \u0026#x3C; BaseError\n    def initialize(message = 'Validation failed', details = nil)\n      super(message, 422, 'ValidationError', details)\n    end\n  end\n  \n  class AuthenticationError \u0026#x3C; BaseError\n    def initialize(message = 'Authentication failed')\n      super(message, 401, 'AuthenticationError')\n    end\n  end\n  \n  class RateLimitError \u0026#x3C; BaseError\n    attr_reader :limit, :reset_at\n    \n    def initialize(limit, reset_at)\n      @limit = limit\n      @reset_at = reset_at\n      super('Rate limit exceeded', 429, 'RateLimitError')\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"レスポンスフォーマット標準化\"\u003eレスポンスフォーマット標準化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/services/response_builder.rb\nclass ResponseBuilder\n  def self.success(data = nil, message = nil, meta = {})\n    response = {\n      success: true,\n      timestamp: Time.current.iso8601\n    }\n    \n    response[:data] = data if data.present?\n    response[:message] = message if message.present?\n    response[:meta] = meta if meta.present?\n    \n    response\n  end\n  \n  def self.error(status, error_type, message, details = nil)\n    {\n      success: false,\n      error: {\n        status: status,\n        type: error_type,\n        message: message,\n        details: details\n      }.compact,\n      timestamp: Time.current.iso8601\n    }\n  end\n  \n  def self.paginated(collection, serializer, options = {})\n    {\n      success: true,\n      data: ActiveModelSerializers::SerializableResource.new(\n        collection,\n        each_serializer: serializer,\n        **options\n      ),\n      meta: {\n        pagination: {\n          current_page: collection.current_page,\n          total_pages: collection.total_pages,\n          total_count: collection.total_count,\n          per_page: collection.limit_value,\n          next_page: collection.next_page,\n          prev_page: collection.prev_page\n        }\n      },\n      timestamp: Time.current.iso8601\n    }\n  end\nend\n\n# コントローラーでの使用\ndef index\n  posts = Post.published.page(params[:page])\n  render json: ResponseBuilder.paginated(posts, PostSerializer)\nend\n\ndef create\n  post = current_user.posts.build(post_params)\n  \n  if post.save\n    render json: ResponseBuilder.success(\n      PostSerializer.new(post),\n      'Post created successfully'\n    ), status: :created\n  else\n    render json: ResponseBuilder.error(\n      422,\n      'ValidationError',\n      'Validation failed',\n      post.errors.details\n    ), status: :unprocessable_entity\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"パフォーマンス最適化\"\u003eパフォーマンス最適化\u003c/h2\u003e\n\u003ch3 id=\"n1問題の解決\"\u003eN+1問題の解決\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/models/post.rb\nclass Post \u0026#x3C; ApplicationRecord\n  belongs_to :user\n  has_many :comments\n  has_many :likes\n  has_and_belongs_to_many :tags\n  \n  # Bullet gemによる検出\n  # Gemfile\n  # gem 'bullet', group: :development\n  \n  # スコープでのincludes\n  scope :with_associations, -\u003e {\n    includes(:user, :tags, comments: :user)\n  }\n  \n  # カウンターキャッシュの使用\n  # comments_count, likes_count カラムを追加\n  has_many :comments, counter_cache: true\n  has_many :likes, counter_cache: true\nend\n\n# app/controllers/api/v1/posts_controller.rb\ndef index\n  # ❌ N+1問題が発生\n  posts = Post.all\n  \n  # ✅ includesで解決\n  posts = Post.includes(:user, :tags, :comments)\n  \n  # ✅ より詳細な最適化\n  posts = Post\n    .includes(:user, :tags)\n    .includes(comments: [:user, :likes])\n    .references(:comments)\n    .where('comments.created_at \u003e ?', 1.week.ago)\n  \n  render json: posts\nend\n\n# app/serializers/post_serializer.rb\nclass PostSerializer \u0026#x3C; ActiveModel::Serializer\n  attributes :id, :title, :content, :comments_count, :likes_count\n  \n  belongs_to :user\n  has_many :tags\n  \n  # カウンターキャッシュを活用\n  def comments_count\n    object.comments_count # N+1を避ける\n  end\n  \n  def likes_count\n    object.likes_count # N+1を避ける\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"キャッシング戦略\"\u003eキャッシング戦略\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/environments/production.rb\nconfig.cache_store = :redis_cache_store, {\n  url: ENV['REDIS_URL'],\n  expires_in: 1.hour\n}\n\n# app/controllers/api/v1/posts_controller.rb\nclass PostsController \u0026#x3C; BaseController\n  def index\n    posts = Rails.cache.fetch(cache_key_for_posts, expires_in: 30.minutes) do\n      Post.published\n          .includes(:user, :tags)\n          .order(created_at: :desc)\n          .limit(100)\n          .to_a # 配列に変換してキャッシュ\n    end\n    \n    render json: posts\n  end\n  \n  def show\n    post = Rails.cache.fetch(\"post/#{params[:id]}\", expires_in: 1.hour) do\n      Post.includes(:user, :tags, comments: :user)\n          .find(params[:id])\n    end\n    \n    # ETags使用\n    if stale?(post)\n      render json: post, serializer: PostDetailSerializer\n    end\n  end\n  \n  private\n  \n  def cache_key_for_posts\n    \"posts/#{params[:page]}/#{params[:per_page]}/#{Post.maximum(:updated_at)}\"\n  end\nend\n\n# app/models/post.rb\nclass Post \u0026#x3C; ApplicationRecord\n  # キャッシュの自動無効化\n  after_commit :clear_cache\n  \n  private\n  \n  def clear_cache\n    Rails.cache.delete(\"post/#{id}\")\n    Rails.cache.delete_matched(\"posts/*\")\n  end\nend\n\n# Fragment Caching in Serializers\nclass PostSerializer \u0026#x3C; ActiveModel::Serializer\n  cache key: 'post', expires_in: 3.hours\n  \n  attributes :id, :title, :content\n  has_many :comments\n  \n  def cache_key\n    \"#{object.cache_key}/#{object.comments.maximum(:updated_at)}\"\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"データベース最適化\"\u003eデータベース最適化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/models/concerns/searchable.rb\nmodule Searchable\n  extend ActiveSupport::Concern\n  \n  included do\n    # PostgreSQL全文検索\n    scope :search, -\u003e(query) {\n      return all if query.blank?\n      \n      # tsvectorカラムを使用（マイグレーションで追加）\n      where(\"search_vector @@ plainto_tsquery('english', ?)\", query)\n    }\n  end\nend\n\n# db/migrate/add_search_vector_to_posts.rb\nclass AddSearchVectorToPosts \u0026#x3C; ActiveRecord::Migration[7.0]\n  def up\n    # tsvectorカラムを追加\n    add_column :posts, :search_vector, :tsvector\n    \n    # インデックスを追加\n    add_index :posts, :search_vector, using: :gin\n    \n    # トリガーを作成\n    execute \u0026#x3C;\u0026#x3C;-SQL\n      CREATE TRIGGER posts_search_vector_update\n      BEFORE INSERT OR UPDATE ON posts\n      FOR EACH ROW EXECUTE FUNCTION\n      tsvector_update_trigger(search_vector, 'pg_catalog.english', title, content);\n    SQL\n  end\n  \n  def down\n    remove_column :posts, :search_vector\n  end\nend\n\n# 複合インデックスの活用\nclass AddCompoundIndexes \u0026#x3C; ActiveRecord::Migration[7.0]\n  def change\n    # よく一緒に検索される条件\n    add_index :posts, [:user_id, :published, :created_at]\n    add_index :posts, [:published, :created_at]\n    \n    # 部分インデックス（条件付きインデックス）\n    add_index :posts, :created_at, where: \"published = true\", name: 'index_published_posts_on_created_at'\n  end\nend\n\n# クエリ最適化\nclass Post \u0026#x3C; ApplicationRecord\n  # バッチ処理\n  def self.process_all\n    find_each(batch_size: 1000) do |post|\n      post.process\n    end\n  end\n  \n  # SELECT句の最適化\n  scope :minimal, -\u003e {\n    select(:id, :title, :created_at)\n  }\n  \n  # EXISTS使用\n  scope :with_comments, -\u003e {\n    where('EXISTS (SELECT 1 FROM comments WHERE comments.post_id = posts.id)')\n  }\n  \n  # Window関数の活用\n  scope :ranked_by_likes, -\u003e {\n    select('posts.*, RANK() OVER (ORDER BY likes_count DESC) as rank')\n  }\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"バックグラウンドジョブ\"\u003eバックグラウンドジョブ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'sidekiq'\ngem 'redis'\n\n# app/jobs/notification_job.rb\nclass NotificationJob \u0026#x3C; ApplicationJob\n  queue_as :default\n  \n  def perform(user_id, notification_type, data = {})\n    user = User.find(user_id)\n    \n    case notification_type\n    when 'new_comment'\n      NotificationService.send_new_comment_notification(user, data)\n    when 'new_like'\n      NotificationService.send_new_like_notification(user, data)\n    end\n  end\nend\n\n# app/controllers/api/v1/comments_controller.rb\ndef create\n  comment = @post.comments.build(comment_params)\n  comment.user = current_user\n  \n  if comment.save\n    # 非同期で通知を送信\n    NotificationJob.perform_later(\n      @post.user_id,\n      'new_comment',\n      { comment_id: comment.id }\n    )\n    \n    render json: comment, status: :created\n  else\n    render json: { errors: comment.errors }, status: :unprocessable_entity\n  end\nend\n\n# app/services/heavy_operation_service.rb\nclass HeavyOperationService\n  def self.process_async(data)\n    # Sidekiqで非同期実行\n    ProcessingWorker.perform_async(data)\n    \n    # ジョブIDを返す\n    { job_id: SecureRandom.uuid, status: 'processing' }\n  end\nend\n\n# app/workers/processing_worker.rb\nclass ProcessingWorker\n  include Sidekiq::Worker\n  \n  sidekiq_options retry: 3, dead: false\n  \n  def perform(data)\n    # 重い処理\n    result = ComplexCalculation.new(data).execute\n    \n    # 結果をRedisに保存\n    Rails.cache.write(\"processing_result_#{data['id']}\", result, expires_in: 1.day)\n    \n    # WebSocketで通知（Action Cable使用）\n    ActionCable.server.broadcast(\n      \"processing_#{data['user_id']}\",\n      { status: 'completed', result: result }\n    )\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"graphql実装\"\u003eGraphQL実装\u003c/h2\u003e\n\u003ch3 id=\"graphql基本セットアップ\"\u003eGraphQL基本セットアップ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# Gemfile\ngem 'graphql'\ngem 'graphiql-rails', group: :development\n\n# app/graphql/types/base_object.rb\nmodule Types\n  class BaseObject \u0026#x3C; GraphQL::Schema::Object\n    edge_type_class(Types::BaseEdge)\n    connection_type_class(Types::BaseConnection)\n    field_class Types::BaseField\n  end\nend\n\n# app/graphql/types/user_type.rb\nmodule Types\n  class UserType \u0026#x3C; Types::BaseObject\n    field :id, ID, null: false\n    field :email, String, null: false\n    field :name, String, null: true\n    field :posts, [Types::PostType], null: true\n    field :created_at, GraphQL::Types::ISO8601DateTime, null: false\n    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false\n    \n    # カスタムフィールド\n    field :post_count, Integer, null: false\n    \n    def post_count\n      object.posts.count\n    end\n    \n    # 認証が必要なフィールド\n    field :private_info, String, null: true\n    \n    def private_info\n      return nil unless context[:current_user] == object\n      object.private_info\n    end\n  end\nend\n\n# app/graphql/types/post_type.rb\nmodule Types\n  class PostType \u0026#x3C; Types::BaseObject\n    field :id, ID, null: false\n    field :title, String, null: false\n    field :content, String, null: false\n    field :published, Boolean, null: false\n    field :user, Types::UserType, null: false\n    field :comments, [Types::CommentType], null: true\n    field :tags, [Types::TagType], null: true\n    field :created_at, GraphQL::Types::ISO8601DateTime, null: false\n  end\nend\n\n# app/graphql/types/query_type.rb\nmodule Types\n  class QueryType \u0026#x3C; Types::BaseObject\n    # ユーザー一覧\n    field :users, [Types::UserType], null: false do\n      argument :limit, Integer, required: false, default_value: 20\n      argument :offset, Integer, required: false, default_value: 0\n    end\n    \n    def users(limit:, offset:)\n      User.limit(limit).offset(offset)\n    end\n    \n    # 単一ユーザー\n    field :user, Types::UserType, null: true do\n      argument :id, ID, required: true\n    end\n    \n    def user(id:)\n      User.find_by(id: id)\n    end\n    \n    # 投稿検索\n    field :posts, Types::PostType.connection_type, null: false do\n      argument :filter, Types::PostFilterType, required: false\n      argument :order_by, Types::PostOrderType, required: false\n    end\n    \n    def posts(filter: nil, order_by: nil)\n      scope = Post.published\n      scope = apply_filter(scope, filter) if filter\n      scope = apply_order(scope, order_by) if order_by\n      scope\n    end\n    \n    private\n    \n    def apply_filter(scope, filter)\n      scope = scope.where(user_id: filter.user_id) if filter.user_id\n      scope = scope.search(filter.search) if filter.search\n      scope = scope.where('created_at \u003e= ?', filter.from_date) if filter.from_date\n      scope = scope.where('created_at \u0026#x3C;= ?', filter.to_date) if filter.to_date\n      scope\n    end\n    \n    def apply_order(scope, order_by)\n      case order_by\n      when 'CREATED_AT_ASC'\n        scope.order(created_at: :asc)\n      when 'CREATED_AT_DESC'\n        scope.order(created_at: :desc)\n      when 'TITLE_ASC'\n        scope.order(title: :asc)\n      else\n        scope\n      end\n    end\n  end\nend\n\n# app/graphql/types/mutation_type.rb\nmodule Types\n  class MutationType \u0026#x3C; Types::BaseObject\n    field :create_post, mutation: Mutations::CreatePost\n    field :update_post, mutation: Mutations::UpdatePost\n    field :delete_post, mutation: Mutations::DeletePost\n    field :login, mutation: Mutations::Login\n    field :register, mutation: Mutations::Register\n  end\nend\n\n# app/graphql/mutations/create_post.rb\nmodule Mutations\n  class CreatePost \u0026#x3C; BaseMutation\n    # 引数の定義\n    argument :title, String, required: true\n    argument :content, String, required: true\n    argument :published, Boolean, required: false, default_value: false\n    argument :tag_ids, [ID], required: false\n    \n    # 戻り値の定義\n    field :post, Types::PostType, null: true\n    field :errors, [String], null: false\n    \n    def resolve(title:, content:, published:, tag_ids: [])\n      # 認証チェック\n      return { post: nil, errors: ['Not authenticated'] } unless context[:current_user]\n      \n      post = context[:current_user].posts.build(\n        title: title,\n        content: content,\n        published: published\n      )\n      \n      post.tag_ids = tag_ids if tag_ids.present?\n      \n      if post.save\n        { post: post, errors: [] }\n      else\n        { post: nil, errors: post.errors.full_messages }\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"graphql認証とn1対策\"\u003eGraphQL認証とN+1対策\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# app/graphql/my_api_schema.rb\nclass MyApiSchema \u0026#x3C; GraphQL::Schema\n  mutation(Types::MutationType)\n  query(Types::QueryType)\n  \n  # GraphQL-Batch for N+1 prevention\n  use GraphQL::Batch\n  \n  # Query complexity prevention\n  max_complexity 300\n  max_depth 10\n  \n  def self.unauthorized_object(error)\n    raise GraphQL::ExecutionError, \"You don't have permission to access #{error.object}\"\n  end\nend\n\n# app/graphql/loaders/association_loader.rb\nclass Loaders::AssociationLoader \u0026#x3C; GraphQL::Batch::Loader\n  def initialize(model, association_name)\n    @model = model\n    @association_name = association_name\n  end\n  \n  def perform(records)\n    preload_association(records)\n    records.each { |record| fulfill(record, read_association(record)) }\n  end\n  \n  private\n  \n  def preload_association(records)\n    ActiveRecord::Associations::Preloader.new(\n      records: records,\n      associations: @association_name\n    ).call\n  end\n  \n  def read_association(record)\n    record.public_send(@association_name)\n  end\nend\n\n# app/graphql/types/post_type.rb\nmodule Types\n  class PostType \u0026#x3C; Types::BaseObject\n    field :comments, [Types::CommentType], null: true\n    \n    # N+1を防ぐためのDataLoader使用\n    def comments\n      Loaders::AssociationLoader.for(Post, :comments).load(object)\n    end\n    \n    field :user, Types::UserType, null: false\n    \n    def user\n      Loaders::RecordLoader.for(User).load(object.user_id)\n    end\n  end\nend\n\n# app/controllers/graphql_controller.rb\nclass GraphqlController \u0026#x3C; ApplicationController\n  skip_before_action :verify_authenticity_token\n  \n  def execute\n    variables = prepare_variables(params[:variables])\n    query = params[:query]\n    operation_name = params[:operationName]\n    \n    context = {\n      current_user: current_user,\n      request: request\n    }\n    \n    result = MyApiSchema.execute(\n      query,\n      variables: variables,\n      context: context,\n      operation_name: operation_name\n    )\n    \n    render json: result\n  rescue StandardError =\u003e e\n    raise e unless Rails.env.development?\n    handle_error_in_development(e)\n  end\n  \n  private\n  \n  def current_user\n    token = request.headers['Authorization']\u0026#x26;.split(' ')\u0026#x26;.last\n    return nil unless token\n    \n    decoded = JsonWebToken.decode(token)\n    User.find(decoded[:user_id])\n  rescue StandardError\n    nil\n  end\n  \n  def prepare_variables(variables_param)\n    case variables_param\n    when String\n      variables_param.present? ? JSON.parse(variables_param) || {} : {}\n    when Hash\n      variables_param\n    when ActionController::Parameters\n      variables_param.to_unsafe_hash\n    when nil\n      {}\n    else\n      raise ArgumentError, \"Unexpected parameter: #{variables_param}\"\n    end\n  end\n  \n  def handle_error_in_development(e)\n    logger.error e.message\n    logger.error e.backtrace.join(\"\\n\")\n    \n    render json: {\n      errors: [{ message: e.message, backtrace: e.backtrace }],\n      data: {}\n    }, status: 500\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"テスト戦略\"\u003eテスト戦略\u003c/h2\u003e\n\u003ch3 id=\"rspecでのapi-テスト\"\u003eRSpecでのAPI テスト\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# spec/rails_helper.rb\nrequire 'spec_helper'\nENV['RAILS_ENV'] ||= 'test'\nrequire_relative '../config/environment'\n\nRSpec.configure do |config|\n  config.include FactoryBot::Syntax::Methods\n  config.include RequestSpecHelper, type: :request\n  \n  config.before(:suite) do\n    DatabaseCleaner.strategy = :transaction\n    DatabaseCleaner.clean_with(:truncation)\n  end\nend\n\n# spec/support/request_spec_helper.rb\nmodule RequestSpecHelper\n  def json\n    JSON.parse(response.body)\n  end\n  \n  def auth_headers(user)\n    token = JsonWebToken.encode(user_id: user.id)\n    { 'Authorization' =\u003e \"Bearer #{token}\" }\n  end\nend\n\n# spec/requests/api/v1/posts_spec.rb\nrequire 'rails_helper'\n\nRSpec.describe 'Posts API', type: :request do\n  let(:user) { create(:user) }\n  let(:headers) { auth_headers(user) }\n  \n  describe 'GET /api/v1/posts' do\n    let!(:posts) { create_list(:post, 10, published: true) }\n    \n    before { get '/api/v1/posts', params: {}, headers: headers }\n    \n    it 'returns posts' do\n      expect(json).not_to be_empty\n      expect(json['data'].size).to eq(10)\n    end\n    \n    it 'returns status code 200' do\n      expect(response).to have_http_status(200)\n    end\n    \n    context 'with pagination' do\n      before do\n        get '/api/v1/posts', params: { page: 2, per_page: 5 }, headers: headers\n      end\n      \n      it 'returns paginated results' do\n        expect(json['data'].size).to eq(5)\n        expect(json['meta']['current_page']).to eq(2)\n      end\n    end\n    \n    context 'with filters' do\n      let!(:user_posts) { create_list(:post, 3, user: user, published: true) }\n      \n      before do\n        get '/api/v1/posts', params: { user_id: user.id }, headers: headers\n      end\n      \n      it 'returns filtered posts' do\n        expect(json['data'].size).to eq(3)\n        expect(json['data'].all? { |p| p['user_id'] == user.id }).to be true\n      end\n    end\n  end\n  \n  describe 'POST /api/v1/posts' do\n    let(:valid_attributes) do\n      { post: { title: 'Test Post', content: 'Test content', published: true } }\n    end\n    \n    context 'when the request is valid' do\n      before { post '/api/v1/posts', params: valid_attributes, headers: headers }\n      \n      it 'creates a post' do\n        expect(json['data']['title']).to eq('Test Post')\n      end\n      \n      it 'returns status code 201' do\n        expect(response).to have_http_status(201)\n      end\n    end\n    \n    context 'when the request is invalid' do\n      let(:invalid_attributes) { { post: { title: '' } } }\n      \n      before { post '/api/v1/posts', params: invalid_attributes, headers: headers }\n      \n      it 'returns status code 422' do\n        expect(response).to have_http_status(422)\n      end\n      \n      it 'returns a validation failure message' do\n        expect(json['errors']).to include(\"Title can't be blank\")\n      end\n    end\n  end\n  \n  describe 'PUT /api/v1/posts/:id' do\n    let(:post_record) { create(:post, user: user) }\n    let(:valid_attributes) { { post: { title: 'Updated Title' } } }\n    \n    before do\n      put \"/api/v1/posts/#{post_record.id}\", \n          params: valid_attributes, \n          headers: headers\n    end\n    \n    context 'when the record exists' do\n      it 'updates the record' do\n        expect(json['data']['title']).to eq('Updated Title')\n      end\n      \n      it 'returns status code 200' do\n        expect(response).to have_http_status(200)\n      end\n    end\n    \n    context 'when user is not the owner' do\n      let(:other_user) { create(:user) }\n      let(:headers) { auth_headers(other_user) }\n      \n      it 'returns status code 403' do\n        expect(response).to have_http_status(403)\n      end\n    end\n  end\n  \n  describe 'DELETE /api/v1/posts/:id' do\n    let!(:post_record) { create(:post, user: user) }\n    \n    before { delete \"/api/v1/posts/#{post_record.id}\", headers: headers }\n    \n    it 'returns status code 204' do\n      expect(response).to have_http_status(204)\n    end\n    \n    it 'deletes the record' do\n      expect(Post.find_by(id: post_record.id)).to be_nil\n    end\n  end\nend\n\n# spec/integration/api_integration_spec.rb\nRSpec.describe 'API Integration', type: :request do\n  describe 'complete user flow' do\n    it 'allows user registration, login, and resource creation' do\n      # ユーザー登録\n      post '/api/v1/auth/register', params: {\n        email: 'test@example.com',\n        password: 'password123',\n        name: 'Test User'\n      }\n      \n      expect(response).to have_http_status(201)\n      token = json['token']\n      \n      # ログイン\n      post '/api/v1/auth/login', params: {\n        email: 'test@example.com',\n        password: 'password123'\n      }\n      \n      expect(response).to have_http_status(200)\n      expect(json['token']).to be_present\n      \n      # リソース作成\n      post '/api/v1/posts', \n           params: { post: { title: 'Test', content: 'Content' } },\n           headers: { 'Authorization' =\u003e \"Bearer #{token}\" }\n      \n      expect(response).to have_http_status(201)\n      expect(json['data']['title']).to eq('Test')\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"セキュリティ対策\"\u003eセキュリティ対策\u003c/h2\u003e\n\u003ch3 id=\"api-セキュリティベストプラクティス\"\u003eAPI セキュリティベストプラクティス\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/initializers/cors.rb\nRails.application.config.middleware.insert_before 0, Rack::Cors do\n  allow do\n    origins ENV.fetch('ALLOWED_ORIGINS', '*').split(',')\n    \n    resource '*',\n      headers: :any,\n      methods: [:get, :post, :put, :patch, :delete, :options, :head],\n      credentials: true,\n      max_age: 86400\n  end\nend\n\n# app/controllers/application_controller.rb\nclass ApplicationController \u0026#x3C; ActionController::API\n  # Rate limiting\n  include Rack::Attack\n  \n  # SQL Injection対策は標準のActive Recordメソッドを使用\n  # XSS対策はAPIモードでは基本的に不要（JSONレスポンスのため）\n  \n  # CSRF対策（APIでは通常不要だが、Cookie認証の場合は必要）\n  # protect_from_forgery with: :null_session\n  \n  # Strong Parameters\n  before_action :configure_permitted_parameters, if: :devise_controller?\n  \n  # APIキー認証（オプション）\n  before_action :authenticate_api_key!, if: :api_key_required?\n  \n  private\n  \n  def authenticate_api_key!\n    api_key = request.headers['X-API-Key']\n    \n    unless api_key \u0026#x26;\u0026#x26; ApiKey.active.exists?(key: api_key)\n      render json: { error: 'Invalid API key' }, status: :unauthorized\n    end\n  end\n  \n  def api_key_required?\n    # 特定のエンドポイントでAPIキーを要求\n    request.path.start_with?('/api/admin')\n  end\nend\n\n# config/initializers/rack_attack.rb\nclass Rack::Attack\n  # Rate limiting\n  throttle('api/ip', limit: 100, period: 5.minutes) do |req|\n    req.ip if req.path.start_with?('/api')\n  end\n  \n  # ログイン試行の制限\n  throttle('logins/ip', limit: 5, period: 20.seconds) do |req|\n    if req.path == '/api/v1/auth/login' \u0026#x26;\u0026#x26; req.post?\n      req.ip\n    end\n  end\n  \n  # ユーザーごとの制限\n  throttle('api/user', limit: 1000, period: 1.hour) do |req|\n    if req.env['HTTP_AUTHORIZATION']\n      token = req.env['HTTP_AUTHORIZATION'].split(' ').last\n      decoded = JsonWebToken.decode(token) rescue nil\n      decoded[:user_id] if decoded\n    end\n  end\n  \n  # Blockルール\n  blocklist('block suspicious requests') do |req|\n    # SQLインジェクションのパターンを検出\n    Rack::Attack::Fail2Ban.filter(\"pentesters-#{req.ip}\", maxretry: 3, findtime: 10.minutes, bantime: 30.minutes) do\n      CGI.unescape(req.query_string) =~ /(%27|')|(%3B|;)|(\u0026#x3C;|%3C)|(\u003e|%3E)/i\n    end\n  end\nend\n\n# app/services/security_audit_service.rb\nclass SecurityAuditService\n  def self.audit_request(request, user = nil)\n    AuditLog.create!(\n      user: user,\n      action: \"#{request.method} #{request.path}\",\n      ip_address: request.remote_ip,\n      user_agent: request.user_agent,\n      parameters: filter_sensitive_params(request.params),\n      performed_at: Time.current\n    )\n  end\n  \n  private\n  \n  def self.filter_sensitive_params(params)\n    Rails.application.config.filter_parameters.each do |param|\n      params = params.deep_transform_values do |value|\n        value.to_s.include?(param.to_s) ? '[FILTERED]' : value\n      end\n    end\n    params\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"バージョニングとデプロイ\"\u003eバージョニングとデプロイ\u003c/h2\u003e\n\u003ch3 id=\"apiバージョニング戦略\"\u003eAPIバージョニング戦略\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# URLパスベースのバージョニング\nRails.application.routes.draw do\n  namespace :api do\n    namespace :v1 do\n      resources :posts\n    end\n    \n    namespace :v2 do\n      resources :posts do\n        member do\n          post :react\n        end\n      end\n    end\n  end\n  \n  # デフォルトバージョンへのリダイレクト\n  get 'api/posts', to: redirect('/api/v1/posts')\nend\n\n# ヘッダーベースのバージョニング\nclass ApplicationController \u0026#x3C; ActionController::API\n  before_action :set_api_version\n  \n  private\n  \n  def set_api_version\n    @api_version = request.headers['Accept-Version'] || 'v1'\n    \n    unless %w[v1 v2].include?(@api_version)\n      render json: { error: 'Invalid API version' }, status: :bad_request\n    end\n  end\nend\n\n# app/controllers/api/posts_controller.rb\nmodule Api\n  class PostsController \u0026#x3C; BaseController\n    def index\n      case @api_version\n      when 'v1'\n        render json: posts_v1\n      when 'v2'\n        render json: posts_v2\n      end\n    end\n    \n    private\n    \n    def posts_v1\n      Post.all.as_json(only: [:id, :title, :content])\n    end\n    \n    def posts_v2\n      Post.all.as_json(\n        only: [:id, :title, :content],\n        methods: [:reactions_count, :views_count]\n      )\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"デプロイ設定\"\u003eデプロイ設定\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e# config/deploy.rb (Capistrano)\nlock '~\u003e 3.17.0'\n\nset :application, 'my_api'\nset :repo_url, 'git@github.com:username/my_api.git'\nset :deploy_to, '/var/www/my_api'\nset :rbenv_ruby, '3.2.0'\n\nappend :linked_files, 'config/database.yml', 'config/master.key'\nappend :linked_dirs, 'log', 'tmp/pids', 'tmp/cache', 'tmp/sockets', 'public/system'\n\nnamespace :deploy do\n  desc 'Restart application'\n  task :restart do\n    on roles(:app), in: :sequence, wait: 5 do\n      execute :touch, release_path.join('tmp/restart.txt')\n    end\n  end\n  \n  after :publishing, :restart\nend\n\n# docker-compose.yml\nversion: '3.8'\nservices:\n  db:\n    image: postgres:14\n    environment:\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n  \n  redis:\n    image: redis:7-alpine\n    command: redis-server\n    volumes:\n      - redis_data:/data\n  \n  web:\n    build: .\n    command: bundle exec puma -C config/puma.rb\n    volumes:\n      - .:/app\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - db\n      - redis\n    environment:\n      DATABASE_URL: postgresql://postgres:password@db/my_api_production\n      REDIS_URL: redis://redis:6379/0\n  \n  sidekiq:\n    build: .\n    command: bundle exec sidekiq\n    volumes:\n      - .:/app\n    depends_on:\n      - db\n      - redis\n    environment:\n      DATABASE_URL: postgresql://postgres:password@db/my_api_production\n      REDIS_URL: redis://redis:6379/0\n\nvolumes:\n  postgres_data:\n  redis_data:\n\n# Dockerfile\nFROM ruby:3.2.0\nRUN apt-get update -qq \u0026#x26;\u0026#x26; apt-get install -y postgresql-client\nWORKDIR /app\nCOPY Gemfile* ./\nRUN bundle install\nCOPY . .\nEXPOSE 3000\nCMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"まとめ\"\u003eまとめ\u003c/h2\u003e\n\u003ch3 id=\"rails-api開発チェックリスト\"\u003eRails API開発チェックリスト\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e設計\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e RESTful原則に従ったURL設計\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e 適切なHTTPステータスコードの使用\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e 一貫性のあるレスポンスフォーマット\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e エラーハンドリングの実装\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eパフォーマンス\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e N+1問題の解決（includes, eager_load）\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e 適切なインデックスの設定\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e キャッシング戦略の実装\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e バックグラウンドジョブの活用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eセキュリティ\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e 認証・認可の実装\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Rate limitingの設定\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e CORS設定\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e SQLインジェクション対策\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eテスト\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Request specの作成\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e 統合テストの実装\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e パフォーマンステスト\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e セキュリティテスト\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"面接での回答例\"\u003e面接での回答例\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eQ: Rails APIモードの利点は？\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: Rails APIモードは通常のRailsから不要な機能を削除し、\nAPI開発に最適化されています。\n\n主な利点：\n1. 軽量化：ビュー層やアセットパイプラインを除外\n2. パフォーマンス：メモリ使用量削減、レスポンス速度向上\n3. ミドルウェア最適化：API用に最適化された構成\n\n実装面では、ApplicationControllerがActionController::APIを\n継承し、JSONレンダリングに特化した設定になっています。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eQ: N+1問題をどう解決しますか？\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: N+1問題は主に3つの方法で解決します：\n\n1. includes：関連データを事前読み込み\n   Post.includes(:comments, :user)\n\n2. eager_load：LEFT JOINで一度に取得\n   Post.eager_load(:comments).where(comments: { approved: true })\n\n3. カウンターキャッシュ：集計値をカラムに保存\n   has_many :comments, counter_cache: true\n\n開発環境ではBullet gemで検出し、\n本番環境ではNew RelicやDatadogでモニタリングします。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"継続的な学習のために\"\u003e継続的な学習のために\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e実践プロジェクト\u003c/strong\u003e: 実際のAPIを構築\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eパフォーマンス測定\u003c/strong\u003e: Apache Bench、JMeterでの負荷テスト\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e最新動向\u003c/strong\u003e: Rails 7.1の新機能、Hotwire Turbo\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e他言語との比較\u003c/strong\u003e: Go、Node.jsのAPI開発も学習\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"参考リンク\"\u003e参考リンク\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://guides.rubyonrails.org/api_app.html\"\u003eRuby on Rails Guides\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://jsonapi.org/\"\u003eJSON:API Specification\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://graphql-ruby.org/\"\u003eGraphQL Ruby\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.speedshop.co/\"\u003eRails Performance\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://guides.rubyonrails.org/security.html\"\u003eRails Security Guide\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cem\u003eこの記事は、Ruby on Rails API開発における3年以上の実務経験で必要な知識を網羅的にまとめました。\u003c/em\u003e\u003c/p\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold mb-2\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-green-600\",\"children\":[\"#\",41]}],\" \",\"Ruby on Rails API開発完全ガイド - RESTful設計からGraphQL、パフォーマンス最適化まで\"]}],[\"$\",\"ul\",null,{\"className\":\"list-none border-b border-gray-600 pb-4 mb-6\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"作成日時: \",\"2025-08-25 01:04\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"更新日時: \",\"2025-08-25 01:04\"]}],[\"$\",\"li\",null,{\"className\":\"flex flex-wrap gap-2 mt-2\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"Ruby on Rails\"}],[\"$\",\"span\",\"1\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"API\"}],[\"$\",\"span\",\"2\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"REST\"}],[\"$\",\"span\",\"3\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"GraphQL\"}],[\"$\",\"span\",\"4\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"JWT\"}],[\"$\",\"span\",\"5\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"パフォーマンス\"}],[\"$\",\"span\",\"6\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"セキュリティ\"}],[\"$\",\"span\",\"7\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"RSpec\"}]]}]]}],[\"$\",\"nav\",null,{\"className\":\"mb-6 pb-4 border-b border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}],[\"$\",\"article\",null,{\"className\":\"prose dark:prose-invert\",\"dangerouslySetInnerHTML\":{\"__html\":\"$13\"}}],[\"$\",\"$L14\",null,{}],[\"$\",\"nav\",null,{\"className\":\"mt-8 pt-4 border-t border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}],[\"$\",\"$L15\",null,{}]]}]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"11:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Maita Tomoya Dev IO\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"米田智哉の技術ブログ。キャッチアップしたことをメモします。\"}]],\"error\":null,\"digest\":\"$undefined\"}\nb:{\"metadata\":\"$11:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>