<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e1e085347ecf8985.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-f029a09104d09cbc.js"/><script src="/_next/static/chunks/4bd1b696-67ee12fb04071d3b.js" async=""></script><script src="/_next/static/chunks/684-bc1e486cc8d76675.js" async=""></script><script src="/_next/static/chunks/main-app-d1c324b32b03123c.js" async=""></script><script src="/_next/static/chunks/874-992333f59fd2c78c.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-22a331a24ce6a1f3.js" async=""></script><meta name="next-size-adjust" content=""/><link rel="icon" href="/favicon.png" type="image/png"/><title>Maita Tomoya Dev IO</title><meta name="description" content="米田智哉の技術ブログ。キャッチアップしたことをメモします。"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 antialiased"><div class="max-w-2xl mx-auto py-10 px-4"><h1 class="text-3xl font-bold mb-2"><span class="text-green-600">#<!-- -->12</span> <!-- -->Next.jsでMarkdown記事の特定セクションにカスタムスタイルを適用する方法</h1><ul class="list-none border-b border-gray-600 pb-4 mb-6"><li class="text-gray-500 text-sm">作成日時: <!-- -->2025-08-02 20:00</li><li class="flex flex-wrap gap-2 mt-2"><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">Next.js</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">Markdown</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">CSS</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">remark</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">正規表現</span></li></ul><nav class="mb-6 pb-4 border-b border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav><article class="prose dark:prose-invert"><h2 class="quiz-title">クイズ：この記事でわかること</h2>
<ol>
<li>Markdownから生成されたHTMLの特定部分にスタイルを適用する基本的なアプローチは何ですか？</li>
<li>remarkでMarkdownを処理した後にHTML変換を行う際、なぜ正規表現による後処理が有効なのですか？</li>
<li>CSSの隣接セレクタ（+）を使うメリットは何ですか？</li>
</ol>
<h2>はじめに</h2>
<p><strong>Markdown</strong>（マークダウン）で書かれたブログ記事を<strong>Next.js</strong>で表示する際、特定のセクション（例：クイズ、注意事項、ヒントなど）だけに独自のスタイルを適用したいケースがあります。</p>
<p>📝 <strong>Markdownとは？</strong> 簡単な記号を使って文書の構造を表現できる軽量マークアップ言語。<code>#</code>で見出し、<code>**</code>で太字などを表現します。</p>
<p>今回は、実際にブログのクイズセクションにカスタムスタイルを適用した実装方法を解説します。</p>
<h2>対応した内容</h2>
<p>ブログ記事内のクイズセクションに以下の機能を実装しました：</p>
<ul>
<li>クイズセクションに背景色と角丸デザインを適用</li>
<li>クイズの答えをドラッグ選択で表示する仕組み</li>
<li>特定の見出しとその次の要素への自動スタイル適用</li>
</ul>
<h2>導入した技術の解説</h2>
<h3>remark（リマーク）</h3>
<p><a href="https://github.com/remarkjs/remark">remark</a>は、Markdownを処理するための<strong>プロセッサー</strong>（処理エンジン）です。</p>
<p>🔧 <strong>プラグインエコシステム</strong>が充実しており、Markdownを様々な形式に変換できます。</p>
<ul>
<li><strong>プラグイン</strong>: 機能を追加するための拡張モジュール</li>
<li><strong>エコシステム</strong>: 関連ツールやライブラリの集合体</li>
</ul>
<p>主な特徴：</p>
<ul>
<li>プラグインによる拡張性</li>
<li>AST（抽象構文木）ベースの処理</li>
<li>高速で安全な変換</li>
</ul>
<h3>remark-html</h3>
<p>remarkの<strong>プラグイン</strong>で、MarkdownをHTMLに変換します。</p>
<p>⚠️ <strong>重要な設定</strong>: <code>sanitize: false</code></p>
<ul>
<li><strong>sanitize（サニタイズ）</strong>: 危険なコードを除去する処理</li>
<li><code>false</code>にすると、カスタムHTMLクラスやスタイルを保持できる</li>
<li>ただし、XSSのリスクが高まるため注意が必要</li>
</ul>
<h3>正規表現による後処理</h3>
<p><strong>正規表現（Regular Expression / RegExp）</strong>: 文字列のパターンを表現する記法。検索や置換に使用されます。</p>
<p>生成されたHTMLに対して正規表現を使用することで、特定のパターンにマッチする要素にカスタムクラスを追加できます。</p>
<pre><code class="language-javascript">// 正規表現の例
/クイズ/gi  // 「クイズ」という文字を検索（大文字小文字区別なし、全体検索）
</code></pre>
<p>📚 <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions">正規表現の基礎（MDN）</a></p>
<h2>用語の解説</h2>
<h3>AST（Abstract Syntax Tree / 抽象構文木）</h3>
<p><strong>簡単に言うと</strong>: プログラムやマークアップの構造を「木」のような形で表現したもの。</p>
<p>例えば、<code># タイトル</code>というMarkdownは以下のようなASTになります：</p>
<pre><code>heading (見出し)
  └── text: "タイトル"
</code></pre>
<p>remarkはMarkdownをASTに変換してから処理を行うため、柔軟な変換が可能になります。</p>
<h3>隣接セレクタ（Adjacent Sibling Selector）</h3>
<p><strong>CSSセレクタ</strong>の一種で、<code>+</code>記号を使用して「特定の要素の直後にある要素」を選択します。</p>
<pre><code class="language-css">/* h2の直後のp要素だけにスタイルを適用 */
h2 + p {
  color: blue;
}
</code></pre>
<p>💡 <strong>使用例</strong>: 見出しの直後の段落だけ文字を大きくしたい、など特定の配置関係にある要素をスタイリングする際に便利です。</p>
<h3>user-select CSSプロパティ</h3>
<p>ユーザーがマウスでテキストを選択（ドラッグ）できるかどうかを制御する<strong>CSS</strong>プロパティ。</p>
<pre><code class="language-css">/* テキストを選択できなくする */
.no-select {
  user-select: none;
  -webkit-user-select: none; /* Safari用 */
  -moz-user-select: none;    /* Firefox用 */
}
</code></pre>
<p>💡 <strong>使い道</strong>: ボタンのテキストや装飾的な要素など、選択されたくないテキストに使用します。</p>
<h2>実装手順と遭遇した問題</h2>
<h3>1. 基本的なMarkdown処理の実装</h3>
<pre><code class="language-typescript">// src/lib/posts.ts
import { remark } from 'remark';
import html from 'remark-html';

export async function getPostData(slug: string) {
  const fullPath = path.join(postsDirectory, `${slug}.md`);
  const fileContents = fs.readFileSync(fullPath, 'utf8');
  
  const matterResult = matter(fileContents);
  const processedContent = await remark()
    .use(html, { sanitize: false })
    .process(matterResult.content);
  let contentHtml = processedContent.toString();
  
  // ここで後処理を追加
  return { contentHtml, ...matterResult.data };
}
</code></pre>
<h3>2. 正規表現によるクラス付与</h3>
<pre><code class="language-typescript">// クイズセクションにカスタムクラスを追加
contentHtml = contentHtml.replace(
  /&#x3C;h2[^>]*>([^&#x3C;]*クイズ[^&#x3C;]*)&#x3C;\/h2>/gi,
  '&#x3C;h2 class="quiz-title">$1&#x3C;/h2>'
);

// クイズの答えセクションに複数の要素を追加
contentHtml = contentHtml.replace(
  /&#x3C;h2[^>]*>クイズの答え&#x3C;\/h2>/gi,
  '&#x3C;h2 class="quiz-answer-title">クイズの答え&#x3C;/h2>' +
  '&#x3C;p class="quiz-answer-hint">（答えはドラッグして選択すると見えます）&#x3C;/p>'
);
</code></pre>
<h3>遭遇した問題点</h3>
<h4>問題1: Tailwind CSSのproseクラスとの競合</h4>
<p><strong>症状</strong>: カスタムスタイルがproseクラスのデフォルトスタイルに上書きされる</p>
<p><strong>原因</strong>: Tailwind Typography プラグインのスタイルが優先度が高い</p>
<p><strong>解決方法</strong>:
より具体的なセレクタを使用：</p>
<pre><code class="language-css">/* 具体的なセレクタで優先度を上げる */
.prose .quiz-title {
  @apply bg-gray-800 text-white px-6 py-4 rounded-lg;
}
</code></pre>
<h4>問題2: 隣接要素への動的なスタイル適用</h4>
<p><strong>症状</strong>: クイズタイトルの次の要素（ul、ol、p）に一貫したスタイルを適用できない</p>
<p><strong>原因</strong>: Markdownの構造が予測できない（リストか段落か不明）</p>
<p><strong>解決方法</strong>:
CSS隣接セレクタで複数パターンに対応：</p>
<pre><code class="language-css">.prose .quiz-title + ul,
.prose .quiz-title + ol,
.prose .quiz-title + p {
  @apply bg-gray-800 px-6 py-3 rounded-lg mb-4;
}
</code></pre>
<h2>実装の詳細解説</h2>
<h3>HTMLの後処理アプローチを選んだ理由</h3>
<ol>
<li><strong>シンプルさ</strong>: remarkプラグインを作成するより実装が簡単</li>
<li><strong>柔軟性</strong>: 複雑な条件分岐や複数要素の挿入が容易</li>
<li><strong>保守性</strong>: 正規表現パターンの変更だけで対応可能</li>
<li><strong>パフォーマンス</strong>: 小規模な処理なら影響は最小限</li>
</ol>
<h3>ドラッグで表示する仕組みの実装</h3>
<pre><code class="language-css">/* 答えのテキストを背景と同色にする */
.prose .quiz-answer-title + .quiz-answer-hint + ul li {
  @apply text-gray-800 selection:text-white selection:bg-blue-500;
  user-select: none;
  -webkit-user-select: none;
}
</code></pre>
<p>この実装により：</p>
<ul>
<li>通常時：テキストが背景と同色で見えない</li>
<li>選択時：選択範囲が青背景に白文字で表示</li>
</ul>
<h2>実務でよくある使用ケース</h2>
<h3>1. 警告・注意事項のスタイリング</h3>
<pre><code class="language-typescript">// ⚠️ や Warning を含む見出しを検出
contentHtml = contentHtml.replace(
  /&#x3C;h[2-6][^>]*>([^&#x3C;]*(?:⚠️|Warning|注意)[^&#x3C;]*)&#x3C;\/h[2-6]>/gi,
  '&#x3C;h$1 class="warning-title">$2&#x3C;/h$1>'
);
</code></pre>
<h3>2. コードブロックのカスタマイズ</h3>
<pre><code class="language-typescript">// 特定言語のコードブロックにクラス追加
contentHtml = contentHtml.replace(
  /&#x3C;pre>&#x3C;code class="language-(\w+)">/g,
  '&#x3C;pre class="code-$1">&#x3C;code class="language-$1">'
);
</code></pre>
<h3>3. 目次の自動生成</h3>
<pre><code class="language-typescript">// h2要素を収集して目次を作成
const headings = contentHtml.match(/&#x3C;h2[^>]*>([^&#x3C;]+)&#x3C;\/h2>/g);
const toc = headings?.map(h => {
  const text = h.replace(/&#x3C;[^>]*>/g, '');
  return `&#x3C;li>&#x3C;a href="#${text}">${text}&#x3C;/a>&#x3C;/li>`;
}).join('');
</code></pre>
<h3>4. 外部リンクのアイコン追加</h3>
<pre><code class="language-typescript">// 外部リンクに自動でアイコンクラスを追加
contentHtml = contentHtml.replace(
  /&#x3C;a href="https?:\/\/[^"]+"/g,
  '$&#x26; class="external-link"'
);
</code></pre>
<h2>ベストプラクティス</h2>
<h3>1. 正規表現の最適化</h3>
<pre><code class="language-typescript">// 効率的なパターン：非貪欲マッチングを使用
const pattern = /&#x3C;h2[^>]*?>([^&#x3C;]*?クイズ[^&#x3C;]*?)&#x3C;\/h2>/gi;

// 非効率なパターン：貪欲マッチング
const badPattern = /&#x3C;h2.*>(.*クイズ.*)&#x3C;\/h2>/gi;
</code></pre>
<h3>2. エスケープ処理の考慮</h3>
<pre><code class="language-typescript">// 特殊文字を含む可能性がある場合
const escapeRegExp = (string: string) => {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&#x26;');
};

const searchTerm = escapeRegExp('クイズ（基礎編）');
const pattern = new RegExp(`&#x3C;h2[^>]*>([^&#x3C;]*${searchTerm}[^&#x3C;]*)&#x3C;/h2>`, 'gi');
</code></pre>
<h3>3. 複数の変換を効率的に実行</h3>
<pre><code class="language-typescript">// 変換ルールを配列で管理
const transformations = [
  {
    pattern: /&#x3C;h2[^>]*>([^&#x3C;]*クイズ[^&#x3C;]*)&#x3C;\/h2>/gi,
    replacement: '&#x3C;h2 class="quiz-title">$1&#x3C;/h2>'
  },
  {
    pattern: /&#x3C;h2[^>]*>ヒント&#x3C;\/h2>/gi,
    replacement: '&#x3C;h2 class="hint-title">ヒント&#x3C;/h2>'
  }
];

// 一括適用
transformations.forEach(({ pattern, replacement }) => {
  contentHtml = contentHtml.replace(pattern, replacement);
});
</code></pre>
<h2>トラブルシューティング</h2>
<h3>スタイルが適用されない場合</h3>
<ol>
<li>
<p><strong>ブラウザの開発者ツールで確認</strong></p>
<ul>
<li>実際に生成されたHTMLを確認</li>
<li>CSSの優先度を確認</li>
</ul>
</li>
<li>
<p><strong>正規表現のテスト</strong></p>
<pre><code class="language-javascript">// コンソールでパターンをテスト
const testHtml = '&#x3C;h2>## クイズ：テスト&#x3C;/h2>';
console.log(testHtml.replace(/&#x3C;h2[^>]*>([^&#x3C;]*クイズ[^&#x3C;]*)&#x3C;\/h2>/gi, '&#x3C;h2 class="quiz-title">$1&#x3C;/h2>'));
</code></pre>
</li>
<li>
<p><strong>CSSの詳細度を上げる</strong></p>
<pre><code class="language-css">/* より詳細なセレクタを使用 */
article.prose .quiz-title {
  /* スタイル */
}
</code></pre>
</li>
</ol>
<h2>セキュリティ上の注意点</h2>
<h3>1. XSS（クロスサイトスクリプティング）対策</h3>
<p><strong>XSSとは？</strong> 悪意のあるスクリプトをWebページに埋め込む攻撃手法。ユーザーの個人情報を盗んだり、なりすましを行ったりする危険があります。</p>
<p>対策：</p>
<ul>
<li><code>sanitize: false</code>を使用する場合は、信頼できるコンテンツのみ処理する</li>
<li>ユーザー入力を含む場合は必ず<strong>サニタイズ</strong>（危険な文字を無害化）する</li>
</ul>
<pre><code class="language-javascript">// 危険な例
const userInput = "&#x3C;script>alert('XSS')&#x3C;/script>";
document.innerHTML = userInput; // 危険！

// 安全な例
const sanitizedInput = DOMPurify.sanitize(userInput);
document.innerHTML = sanitizedInput; // 安全
</code></pre>
<h3>2. ReDoS（正規表現によるサービス拒否攻撃）</h3>
<p><strong>ReDoSとは？</strong> 複雑な正規表現に対して特定の入力を与えることで、処理時間を極端に長くする攻撃。</p>
<p>対策：</p>
<ul>
<li>複雑な正規表現は避ける</li>
<li>大きなコンテンツには処理時間の上限を設ける</li>
</ul>
<h3>3. CSP（Content Security Policy）の考慮</h3>
<p><strong>CSPとは？</strong> Webページで実行可能なスクリプトの出所を制限するセキュリティ機能。XSS攻撃を防ぐのに有効です。</p>
<ul>
<li>インラインスタイルを使用する場合はCSPポリシーを確認</li>
<li>必要に応じて<code>style-src</code>ディレクティブを調整</li>
</ul>
<pre><code class="language-html">&#x3C;!-- CSPの例 -->
&#x3C;meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; style-src 'self' 'unsafe-inline';">
</code></pre>
<p>🔐 <strong>セキュリティの基本原則</strong>: 「信頼しない、検証する」。外部からの入力は常に危険と考え、適切に処理してから使用しましょう。</p>
<h2>まとめ</h2>
<p>Markdownから生成されたHTMLの特定部分にスタイルを適用する方法として、remarkの後処理で正規表現を使用するアプローチを実装しました。この方法により：</p>
<ol>
<li><strong>柔軟なスタイル適用</strong>: 任意のパターンにマッチする要素をカスタマイズ</li>
<li><strong>保守性の高さ</strong>: 正規表現パターンの変更で簡単に調整可能</li>
<li><strong>既存システムへの統合</strong>: remarkの処理フローを大きく変更せずに実装</li>
</ol>
<p>この手法は、ブログシステムやドキュメントサイトなど、Markdownベースのコンテンツ管理システムで広く活用できます。</p>
<h2 class="quiz-answer-title">クイズの回答：ふりかえり</h2>
<div class="quiz-answer-wrapper">
  <button class="quiz-answer-toggle" onclick="this.classList.toggle('open'); this.nextElementSibling.classList.toggle('show');">
    1. Markdownから生成されたHTMLの特定部分にスタイルを適用する基本的なアプローチは何ですか？
  </button>
  <div class="quiz-answer-content">
    <p><p><strong>Markdownから生成されたHTMLの特定部分にスタイルを適用する基本的なアプローチは何ですか？</strong></p>
<ul>
正規表現による後処理でHTMLタグにカスタムクラスを追加し、CSSでスタイリングするアプローチです。</p>
  </div>
</div>
<div class="quiz-answer-wrapper">
  <button class="quiz-answer-toggle" onclick="this.classList.toggle('open'); this.nextElementSibling.classList.toggle('show');">
    2. remarkでMarkdownを処理した後にHTML変換を行う際、なぜ正規表現による後処理が有効なのですか？
  </button>
  <div class="quiz-answer-content">
    <p><p><strong>remarkでMarkdownを処理した後にHTML変換を行う際、なぜ正規表現による後処理が有効なのですか？</strong></p>
<ul>
シンプルで実装が簡単、複雑な条件分岐や複数要素の挿入が容易、カスタムプラグインを作成するより保守性が高いためです。</p>
  </div>
</div>
<div class="quiz-answer-wrapper">
  <button class="quiz-answer-toggle" onclick="this.classList.toggle('open'); this.nextElementSibling.classList.toggle('show');">
    3. CSSの隣接セレクタ（+）を使うメリットは何ですか？
  </button>
  <div class="quiz-answer-content">
    <p><p><strong>CSSの隣接セレクタ（+）を使うメリットは何ですか？</strong></p>
<ul>
特定の要素の直後にある要素を確実に選択でき、Markdownの構造が変わっても（リストか段落かに関わらず）一貫したスタイルを適用できます。</p>
  </div>
</div>
<h2>参考リンク</h2>
<ul>
<li><a href="https://github.com/remarkjs/remark">remark 公式ドキュメント</a></li>
<li><a href="https://github.com/remarkjs/remark-html">remark-html プラグイン</a></li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/CSS/Adjacent_sibling_combinator">MDN: CSS 隣接兄弟結合子</a></li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/CSS/user-select">MDN: user-select CSSプロパティ</a></li>
<li><a href="https://nextjs.org/docs/pages/building-your-application/configuring/mdx">Next.js 公式ドキュメント - Markdown/MDX</a></li>
</ul>
</article><nav class="mt-8 pt-4 border-t border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-f029a09104d09cbc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n5:I[9665,[],\"MetadataBoundary\"]\n7:I[9665,[],\"OutletBoundary\"]\na:I[4911,[],\"AsyncMetadataOutlet\"]\nc:I[9665,[],\"ViewportBoundary\"]\ne:I[6614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/e1e085347ecf8985.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"Op7AamAIw8DQgiBIeh-Ge\",\"p\":\"\",\"c\":[\"\",\"blog\",\"markdown-partial-styling-nextjs\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"markdown-partial-styling-nextjs\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e1e085347ecf8985.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png\",\"type\":\"image/png\"}]}],[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"markdown-partial-styling-nextjs\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[\"$\",\"$L5\",null,{\"children\":\"$L6\"}],null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"ksuHIJCFB_E_cqjMgFhDs\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:\"$Sreact.suspense\"\n10:I[4911,[],\"AsyncMetadata\"]\n6:[\"$\",\"$f\",null,{\"fallback\":null,\"children\":[\"$\",\"$L10\",null,{\"promise\":\"$@11\"}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"12:I[6874,[\"874\",\"static/chunks/874-992333f59fd2c78c.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-22a331a24ce6a1f3.js\"],\"\"]\n13:T4431,"])</script><script>self.__next_f.push([1,"\u003ch2 class=\"quiz-title\"\u003eクイズ：この記事でわかること\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eMarkdownから生成されたHTMLの特定部分にスタイルを適用する基本的なアプローチは何ですか？\u003c/li\u003e\n\u003cli\u003eremarkでMarkdownを処理した後にHTML変換を行う際、なぜ正規表現による後処理が有効なのですか？\u003c/li\u003e\n\u003cli\u003eCSSの隣接セレクタ（+）を使うメリットは何ですか？\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eはじめに\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMarkdown\u003c/strong\u003e（マークダウン）で書かれたブログ記事を\u003cstrong\u003eNext.js\u003c/strong\u003eで表示する際、特定のセクション（例：クイズ、注意事項、ヒントなど）だけに独自のスタイルを適用したいケースがあります。\u003c/p\u003e\n\u003cp\u003e📝 \u003cstrong\u003eMarkdownとは？\u003c/strong\u003e 簡単な記号を使って文書の構造を表現できる軽量マークアップ言語。\u003ccode\u003e#\u003c/code\u003eで見出し、\u003ccode\u003e**\u003c/code\u003eで太字などを表現します。\u003c/p\u003e\n\u003cp\u003e今回は、実際にブログのクイズセクションにカスタムスタイルを適用した実装方法を解説します。\u003c/p\u003e\n\u003ch2\u003e対応した内容\u003c/h2\u003e\n\u003cp\u003eブログ記事内のクイズセクションに以下の機能を実装しました：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eクイズセクションに背景色と角丸デザインを適用\u003c/li\u003e\n\u003cli\u003eクイズの答えをドラッグ選択で表示する仕組み\u003c/li\u003e\n\u003cli\u003e特定の見出しとその次の要素への自動スタイル適用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e導入した技術の解説\u003c/h2\u003e\n\u003ch3\u003eremark（リマーク）\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/remarkjs/remark\"\u003eremark\u003c/a\u003eは、Markdownを処理するための\u003cstrong\u003eプロセッサー\u003c/strong\u003e（処理エンジン）です。\u003c/p\u003e\n\u003cp\u003e🔧 \u003cstrong\u003eプラグインエコシステム\u003c/strong\u003eが充実しており、Markdownを様々な形式に変換できます。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eプラグイン\u003c/strong\u003e: 機能を追加するための拡張モジュール\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eエコシステム\u003c/strong\u003e: 関連ツールやライブラリの集合体\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e主な特徴：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eプラグインによる拡張性\u003c/li\u003e\n\u003cli\u003eAST（抽象構文木）ベースの処理\u003c/li\u003e\n\u003cli\u003e高速で安全な変換\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eremark-html\u003c/h3\u003e\n\u003cp\u003eremarkの\u003cstrong\u003eプラグイン\u003c/strong\u003eで、MarkdownをHTMLに変換します。\u003c/p\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e重要な設定\u003c/strong\u003e: \u003ccode\u003esanitize: false\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003esanitize（サニタイズ）\u003c/strong\u003e: 危険なコードを除去する処理\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efalse\u003c/code\u003eにすると、カスタムHTMLクラスやスタイルを保持できる\u003c/li\u003e\n\u003cli\u003eただし、XSSのリスクが高まるため注意が必要\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e正規表現による後処理\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e正規表現（Regular Expression / RegExp）\u003c/strong\u003e: 文字列のパターンを表現する記法。検索や置換に使用されます。\u003c/p\u003e\n\u003cp\u003e生成されたHTMLに対して正規表現を使用することで、特定のパターンにマッチする要素にカスタムクラスを追加できます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 正規表現の例\n/クイズ/gi  // 「クイズ」という文字を検索（大文字小文字区別なし、全体検索）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e📚 \u003ca href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions\"\u003e正規表現の基礎（MDN）\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e用語の解説\u003c/h2\u003e\n\u003ch3\u003eAST（Abstract Syntax Tree / 抽象構文木）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e簡単に言うと\u003c/strong\u003e: プログラムやマークアップの構造を「木」のような形で表現したもの。\u003c/p\u003e\n\u003cp\u003e例えば、\u003ccode\u003e# タイトル\u003c/code\u003eというMarkdownは以下のようなASTになります：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eheading (見出し)\n  └── text: \"タイトル\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eremarkはMarkdownをASTに変換してから処理を行うため、柔軟な変換が可能になります。\u003c/p\u003e\n\u003ch3\u003e隣接セレクタ（Adjacent Sibling Selector）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCSSセレクタ\u003c/strong\u003eの一種で、\u003ccode\u003e+\u003c/code\u003e記号を使用して「特定の要素の直後にある要素」を選択します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e/* h2の直後のp要素だけにスタイルを適用 */\nh2 + p {\n  color: blue;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e💡 \u003cstrong\u003e使用例\u003c/strong\u003e: 見出しの直後の段落だけ文字を大きくしたい、など特定の配置関係にある要素をスタイリングする際に便利です。\u003c/p\u003e\n\u003ch3\u003euser-select CSSプロパティ\u003c/h3\u003e\n\u003cp\u003eユーザーがマウスでテキストを選択（ドラッグ）できるかどうかを制御する\u003cstrong\u003eCSS\u003c/strong\u003eプロパティ。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e/* テキストを選択できなくする */\n.no-select {\n  user-select: none;\n  -webkit-user-select: none; /* Safari用 */\n  -moz-user-select: none;    /* Firefox用 */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e💡 \u003cstrong\u003e使い道\u003c/strong\u003e: ボタンのテキストや装飾的な要素など、選択されたくないテキストに使用します。\u003c/p\u003e\n\u003ch2\u003e実装手順と遭遇した問題\u003c/h2\u003e\n\u003ch3\u003e1. 基本的なMarkdown処理の実装\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// src/lib/posts.ts\nimport { remark } from 'remark';\nimport html from 'remark-html';\n\nexport async function getPostData(slug: string) {\n  const fullPath = path.join(postsDirectory, `${slug}.md`);\n  const fileContents = fs.readFileSync(fullPath, 'utf8');\n  \n  const matterResult = matter(fileContents);\n  const processedContent = await remark()\n    .use(html, { sanitize: false })\n    .process(matterResult.content);\n  let contentHtml = processedContent.toString();\n  \n  // ここで後処理を追加\n  return { contentHtml, ...matterResult.data };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 正規表現によるクラス付与\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// クイズセクションにカスタムクラスを追加\ncontentHtml = contentHtml.replace(\n  /\u0026#x3C;h2[^\u003e]*\u003e([^\u0026#x3C;]*クイズ[^\u0026#x3C;]*)\u0026#x3C;\\/h2\u003e/gi,\n  '\u0026#x3C;h2 class=\"quiz-title\"\u003e$1\u0026#x3C;/h2\u003e'\n);\n\n// クイズの答えセクションに複数の要素を追加\ncontentHtml = contentHtml.replace(\n  /\u0026#x3C;h2[^\u003e]*\u003eクイズの答え\u0026#x3C;\\/h2\u003e/gi,\n  '\u0026#x3C;h2 class=\"quiz-answer-title\"\u003eクイズの答え\u0026#x3C;/h2\u003e' +\n  '\u0026#x3C;p class=\"quiz-answer-hint\"\u003e（答えはドラッグして選択すると見えます）\u0026#x3C;/p\u003e'\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e遭遇した問題点\u003c/h3\u003e\n\u003ch4\u003e問題1: Tailwind CSSのproseクラスとの競合\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e症状\u003c/strong\u003e: カスタムスタイルがproseクラスのデフォルトスタイルに上書きされる\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原因\u003c/strong\u003e: Tailwind Typography プラグインのスタイルが優先度が高い\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解決方法\u003c/strong\u003e:\nより具体的なセレクタを使用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e/* 具体的なセレクタで優先度を上げる */\n.prose .quiz-title {\n  @apply bg-gray-800 text-white px-6 py-4 rounded-lg;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e問題2: 隣接要素への動的なスタイル適用\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e症状\u003c/strong\u003e: クイズタイトルの次の要素（ul、ol、p）に一貫したスタイルを適用できない\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原因\u003c/strong\u003e: Markdownの構造が予測できない（リストか段落か不明）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解決方法\u003c/strong\u003e:\nCSS隣接セレクタで複数パターンに対応：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e.prose .quiz-title + ul,\n.prose .quiz-title + ol,\n.prose .quiz-title + p {\n  @apply bg-gray-800 px-6 py-3 rounded-lg mb-4;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e実装の詳細解説\u003c/h2\u003e\n\u003ch3\u003eHTMLの後処理アプローチを選んだ理由\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eシンプルさ\u003c/strong\u003e: remarkプラグインを作成するより実装が簡単\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e柔軟性\u003c/strong\u003e: 複雑な条件分岐や複数要素の挿入が容易\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e保守性\u003c/strong\u003e: 正規表現パターンの変更だけで対応可能\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eパフォーマンス\u003c/strong\u003e: 小規模な処理なら影響は最小限\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eドラッグで表示する仕組みの実装\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e/* 答えのテキストを背景と同色にする */\n.prose .quiz-answer-title + .quiz-answer-hint + ul li {\n  @apply text-gray-800 selection:text-white selection:bg-blue-500;\n  user-select: none;\n  -webkit-user-select: none;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこの実装により：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通常時：テキストが背景と同色で見えない\u003c/li\u003e\n\u003cli\u003e選択時：選択範囲が青背景に白文字で表示\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e実務でよくある使用ケース\u003c/h2\u003e\n\u003ch3\u003e1. 警告・注意事項のスタイリング\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// ⚠️ や Warning を含む見出しを検出\ncontentHtml = contentHtml.replace(\n  /\u0026#x3C;h[2-6][^\u003e]*\u003e([^\u0026#x3C;]*(?:⚠️|Warning|注意)[^\u0026#x3C;]*)\u0026#x3C;\\/h[2-6]\u003e/gi,\n  '\u0026#x3C;h$1 class=\"warning-title\"\u003e$2\u0026#x3C;/h$1\u003e'\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. コードブロックのカスタマイズ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// 特定言語のコードブロックにクラス追加\ncontentHtml = contentHtml.replace(\n  /\u0026#x3C;pre\u003e\u0026#x3C;code class=\"language-(\\w+)\"\u003e/g,\n  '\u0026#x3C;pre class=\"code-$1\"\u003e\u0026#x3C;code class=\"language-$1\"\u003e'\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 目次の自動生成\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// h2要素を収集して目次を作成\nconst headings = contentHtml.match(/\u0026#x3C;h2[^\u003e]*\u003e([^\u0026#x3C;]+)\u0026#x3C;\\/h2\u003e/g);\nconst toc = headings?.map(h =\u003e {\n  const text = h.replace(/\u0026#x3C;[^\u003e]*\u003e/g, '');\n  return `\u0026#x3C;li\u003e\u0026#x3C;a href=\"#${text}\"\u003e${text}\u0026#x3C;/a\u003e\u0026#x3C;/li\u003e`;\n}).join('');\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4. 外部リンクのアイコン追加\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// 外部リンクに自動でアイコンクラスを追加\ncontentHtml = contentHtml.replace(\n  /\u0026#x3C;a href=\"https?:\\/\\/[^\"]+\"/g,\n  '$\u0026#x26; class=\"external-link\"'\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eベストプラクティス\u003c/h2\u003e\n\u003ch3\u003e1. 正規表現の最適化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// 効率的なパターン：非貪欲マッチングを使用\nconst pattern = /\u0026#x3C;h2[^\u003e]*?\u003e([^\u0026#x3C;]*?クイズ[^\u0026#x3C;]*?)\u0026#x3C;\\/h2\u003e/gi;\n\n// 非効率なパターン：貪欲マッチング\nconst badPattern = /\u0026#x3C;h2.*\u003e(.*クイズ.*)\u0026#x3C;\\/h2\u003e/gi;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. エスケープ処理の考慮\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// 特殊文字を含む可能性がある場合\nconst escapeRegExp = (string: string) =\u003e {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$\u0026#x26;');\n};\n\nconst searchTerm = escapeRegExp('クイズ（基礎編）');\nconst pattern = new RegExp(`\u0026#x3C;h2[^\u003e]*\u003e([^\u0026#x3C;]*${searchTerm}[^\u0026#x3C;]*)\u0026#x3C;/h2\u003e`, 'gi');\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 複数の変換を効率的に実行\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// 変換ルールを配列で管理\nconst transformations = [\n  {\n    pattern: /\u0026#x3C;h2[^\u003e]*\u003e([^\u0026#x3C;]*クイズ[^\u0026#x3C;]*)\u0026#x3C;\\/h2\u003e/gi,\n    replacement: '\u0026#x3C;h2 class=\"quiz-title\"\u003e$1\u0026#x3C;/h2\u003e'\n  },\n  {\n    pattern: /\u0026#x3C;h2[^\u003e]*\u003eヒント\u0026#x3C;\\/h2\u003e/gi,\n    replacement: '\u0026#x3C;h2 class=\"hint-title\"\u003eヒント\u0026#x3C;/h2\u003e'\n  }\n];\n\n// 一括適用\ntransformations.forEach(({ pattern, replacement }) =\u003e {\n  contentHtml = contentHtml.replace(pattern, replacement);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eトラブルシューティング\u003c/h2\u003e\n\u003ch3\u003eスタイルが適用されない場合\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eブラウザの開発者ツールで確認\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e実際に生成されたHTMLを確認\u003c/li\u003e\n\u003cli\u003eCSSの優先度を確認\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e正規表現のテスト\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// コンソールでパターンをテスト\nconst testHtml = '\u0026#x3C;h2\u003e## クイズ：テスト\u0026#x3C;/h2\u003e';\nconsole.log(testHtml.replace(/\u0026#x3C;h2[^\u003e]*\u003e([^\u0026#x3C;]*クイズ[^\u0026#x3C;]*)\u0026#x3C;\\/h2\u003e/gi, '\u0026#x3C;h2 class=\"quiz-title\"\u003e$1\u0026#x3C;/h2\u003e'));\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCSSの詳細度を上げる\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e/* より詳細なセレクタを使用 */\narticle.prose .quiz-title {\n  /* スタイル */\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eセキュリティ上の注意点\u003c/h2\u003e\n\u003ch3\u003e1. XSS（クロスサイトスクリプティング）対策\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eXSSとは？\u003c/strong\u003e 悪意のあるスクリプトをWebページに埋め込む攻撃手法。ユーザーの個人情報を盗んだり、なりすましを行ったりする危険があります。\u003c/p\u003e\n\u003cp\u003e対策：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esanitize: false\u003c/code\u003eを使用する場合は、信頼できるコンテンツのみ処理する\u003c/li\u003e\n\u003cli\u003eユーザー入力を含む場合は必ず\u003cstrong\u003eサニタイズ\u003c/strong\u003e（危険な文字を無害化）する\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 危険な例\nconst userInput = \"\u0026#x3C;script\u003ealert('XSS')\u0026#x3C;/script\u003e\";\ndocument.innerHTML = userInput; // 危険！\n\n// 安全な例\nconst sanitizedInput = DOMPurify.sanitize(userInput);\ndocument.innerHTML = sanitizedInput; // 安全\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. ReDoS（正規表現によるサービス拒否攻撃）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eReDoSとは？\u003c/strong\u003e 複雑な正規表現に対して特定の入力を与えることで、処理時間を極端に長くする攻撃。\u003c/p\u003e\n\u003cp\u003e対策：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e複雑な正規表現は避ける\u003c/li\u003e\n\u003cli\u003e大きなコンテンツには処理時間の上限を設ける\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3. CSP（Content Security Policy）の考慮\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCSPとは？\u003c/strong\u003e Webページで実行可能なスクリプトの出所を制限するセキュリティ機能。XSS攻撃を防ぐのに有効です。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eインラインスタイルを使用する場合はCSPポリシーを確認\u003c/li\u003e\n\u003cli\u003e必要に応じて\u003ccode\u003estyle-src\u003c/code\u003eディレクティブを調整\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!-- CSPの例 --\u003e\n\u0026#x3C;meta http-equiv=\"Content-Security-Policy\" \n      content=\"default-src 'self'; style-src 'self' 'unsafe-inline';\"\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e🔐 \u003cstrong\u003eセキュリティの基本原則\u003c/strong\u003e: 「信頼しない、検証する」。外部からの入力は常に危険と考え、適切に処理してから使用しましょう。\u003c/p\u003e\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\u003cp\u003eMarkdownから生成されたHTMLの特定部分にスタイルを適用する方法として、remarkの後処理で正規表現を使用するアプローチを実装しました。この方法により：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e柔軟なスタイル適用\u003c/strong\u003e: 任意のパターンにマッチする要素をカスタマイズ\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e保守性の高さ\u003c/strong\u003e: 正規表現パターンの変更で簡単に調整可能\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e既存システムへの統合\u003c/strong\u003e: remarkの処理フローを大きく変更せずに実装\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eこの手法は、ブログシステムやドキュメントサイトなど、Markdownベースのコンテンツ管理システムで広く活用できます。\u003c/p\u003e\n\u003ch2 class=\"quiz-answer-title\"\u003eクイズの回答：ふりかえり\u003c/h2\u003e\n\u003cdiv class=\"quiz-answer-wrapper\"\u003e\n  \u003cbutton class=\"quiz-answer-toggle\" onclick=\"this.classList.toggle('open'); this.nextElementSibling.classList.toggle('show');\"\u003e\n    1. Markdownから生成されたHTMLの特定部分にスタイルを適用する基本的なアプローチは何ですか？\n  \u003c/button\u003e\n  \u003cdiv class=\"quiz-answer-content\"\u003e\n    \u003cp\u003e\u003cp\u003e\u003cstrong\u003eMarkdownから生成されたHTMLの特定部分にスタイルを適用する基本的なアプローチは何ですか？\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n正規表現による後処理でHTMLタグにカスタムクラスを追加し、CSSでスタイリングするアプローチです。\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"quiz-answer-wrapper\"\u003e\n  \u003cbutton class=\"quiz-answer-toggle\" onclick=\"this.classList.toggle('open'); this.nextElementSibling.classList.toggle('show');\"\u003e\n    2. remarkでMarkdownを処理した後にHTML変換を行う際、なぜ正規表現による後処理が有効なのですか？\n  \u003c/button\u003e\n  \u003cdiv class=\"quiz-answer-content\"\u003e\n    \u003cp\u003e\u003cp\u003e\u003cstrong\u003eremarkでMarkdownを処理した後にHTML変換を行う際、なぜ正規表現による後処理が有効なのですか？\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\nシンプルで実装が簡単、複雑な条件分岐や複数要素の挿入が容易、カスタムプラグインを作成するより保守性が高いためです。\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"quiz-answer-wrapper\"\u003e\n  \u003cbutton class=\"quiz-answer-toggle\" onclick=\"this.classList.toggle('open'); this.nextElementSibling.classList.toggle('show');\"\u003e\n    3. CSSの隣接セレクタ（+）を使うメリットは何ですか？\n  \u003c/button\u003e\n  \u003cdiv class=\"quiz-answer-content\"\u003e\n    \u003cp\u003e\u003cp\u003e\u003cstrong\u003eCSSの隣接セレクタ（+）を使うメリットは何ですか？\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n特定の要素の直後にある要素を確実に選択でき、Markdownの構造が変わっても（リストか段落かに関わらず）一貫したスタイルを適用できます。\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003ch2\u003e参考リンク\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/remarkjs/remark\"\u003eremark 公式ドキュメント\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/remarkjs/remark-html\"\u003eremark-html プラグイン\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/ja/docs/Web/CSS/Adjacent_sibling_combinator\"\u003eMDN: CSS 隣接兄弟結合子\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/ja/docs/Web/CSS/user-select\"\u003eMDN: user-select CSSプロパティ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/docs/pages/building-your-application/configuring/mdx\"\u003eNext.js 公式ドキュメント - Markdown/MDX\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold mb-2\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-green-600\",\"children\":[\"#\",12]}],\" \",\"Next.jsでMarkdown記事の特定セクションにカスタムスタイルを適用する方法\"]}],[\"$\",\"ul\",null,{\"className\":\"list-none border-b border-gray-600 pb-4 mb-6\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"作成日時: \",\"2025-08-02 20:00\"]}],\"$undefined\",[\"$\",\"li\",null,{\"className\":\"flex flex-wrap gap-2 mt-2\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"Next.js\"}],[\"$\",\"span\",\"1\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"Markdown\"}],[\"$\",\"span\",\"2\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"CSS\"}],[\"$\",\"span\",\"3\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"remark\"}],[\"$\",\"span\",\"4\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"正規表現\"}]]}]]}],[\"$\",\"nav\",null,{\"className\":\"mb-6 pb-4 border-b border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}],[\"$\",\"article\",null,{\"className\":\"prose dark:prose-invert\",\"dangerouslySetInnerHTML\":{\"__html\":\"$13\"}}],[\"$\",\"nav\",null,{\"className\":\"mt-8 pt-4 border-t border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}]]}]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"11:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Maita Tomoya Dev IO\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"米田智哉の技術ブログ。キャッチアップしたことをメモします。\"}]],\"error\":null,\"digest\":\"$undefined\"}\nb:{\"metadata\":\"$11:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>