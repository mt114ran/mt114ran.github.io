1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1295,[],""]
5:I[9665,[],"MetadataBoundary"]
7:I[9665,[],"OutletBoundary"]
a:I[4911,[],"AsyncMetadataOutlet"]
c:I[9665,[],"ViewportBoundary"]
e:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ce87a0c8fce915ba.css","style"]
0:{"P":null,"b":"c3-THRkVeQg09qgmhNUB9","p":"","c":["","blog","nextjs-pagination-state-management",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","nextjs-pagination-state-management","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ce87a0c8fce915ba.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":["$","link",null,{"rel":"icon","href":"/favicon.png","type":"image/png"}]}],["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","nextjs-pagination-state-management","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",["$","$L5",null,{"children":"$L6"}],null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","zfL_7q3SzijqS8AaDuxme",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$e","$undefined"],"s":false,"S":true}
f:"$Sreact.suspense"
10:I[4911,[],"AsyncMetadata"]
6:["$","$f",null,{"fallback":null,"children":["$","$L10",null,{"promise":"$@11"}]}]
9:null
12:I[6874,["874","static/chunks/874-8d3839f72fd80c3c.js","953","static/chunks/app/blog/%5Bslug%5D/page-677ab5ce4505fca7.js"],""]
13:T373e,<h1>Next.jsでページネーション実装とWebアプリケーションの状態管理を完全理解</h1>
<h2>はじめに</h2>
<p>技術ブログの記事が16本を超えて、一覧ページが長くなりすぎる問題に直面しました。今回はNext.js App Routerでページネーション機能を実装しながら、<strong>Webアプリケーションの状態管理</strong>について深く理解していきます。</p>
<p>「なぜHTMLとCSS/JavaScriptで状態を管理できるのか？」「内部ストレージに保持しているの？」といった疑問も解決していきます。</p>
<h2>現在の問題点</h2>
<pre><code class="language-typescript">// 現在の実装：全記事を一度に表示
export default function BlogIndex() {
  const posts = getSortedPostsData() // 全16記事を取得
  
  return (
    &#x3C;ul>
      {posts.map((post) => ( // 全記事を表示
        &#x3C;li key={post.slug}>{post.title}&#x3C;/li>
      ))}
    &#x3C;/ul>
  )
}
</code></pre>
<h3>問題点の整理</h3>
<ol>
<li>
<p><strong>パフォーマンス問題</strong></p>
<ul>
<li>記事数が増えるとHTMLサイズが肥大化</li>
<li>ブラウザのレンダリング負荷が増大</li>
<li>初期表示時間が遅くなる</li>
</ul>
</li>
<li>
<p><strong>ユーザビリティ問題</strong></p>
<ul>
<li>スクロールが長すぎて目的の記事を見つけにくい</li>
<li>古い記事にアクセスしづらい</li>
</ul>
</li>
</ol>
<h2>Webアプリケーションの状態管理とは</h2>
<h3>状態（State）とは何か</h3>
<p><strong>状態</strong>とは、アプリケーションが「今どのような状態にあるか」を表す情報です。</p>
<p>例えば：</p>
<ul>
<li>現在表示しているページ番号</li>
<li>ユーザーがログインしているか</li>
<li>フォームに入力された値</li>
<li>選択されたタブ</li>
</ul>
<h3>状態を管理する3つの場所</h3>
<h4>1. クライアントサイド（ブラウザ）の状態管理</h4>
<pre><code class="language-javascript">// 1. JavaScriptのメモリ（変数）
let currentPage = 1;

// 2. LocalStorage（永続的）
localStorage.setItem('currentPage', '1');
// ブラウザを閉じても保持される

// 3. SessionStorage（一時的）
sessionStorage.setItem('currentPage', '1');
// タブを閉じると消える

// 4. Cookie
document.cookie = 'currentPage=1; path=/';
// サーバーにも送信される
</code></pre>
<p><strong>特徴</strong>：</p>
<ul>
<li><strong>メモリ</strong>：ページをリロードすると消える</li>
<li><strong>LocalStorage</strong>：最大5MB程度、永続的に保存</li>
<li><strong>SessionStorage</strong>：タブごとに独立、タブを閉じると消える</li>
<li><strong>Cookie</strong>：最大4KB、サーバーとの通信時に自動送信</li>
</ul>
<h4>2. URL（アドレスバー）による状態管理</h4>
<pre><code>https://example.com/blog/page/2/
                          ↑
                    この部分が状態を表す
</code></pre>
<p><strong>なぜURLで状態管理ができるのか</strong>：</p>
<ol>
<li>
<p><strong>ブラウザの仕組み</strong></p>
<ul>
<li>URLはブラウザが管理する「現在地」情報</li>
<li>履歴API（History API）でURLを操作可能</li>
<li>ブックマーク可能、共有可能</li>
</ul>
</li>
<li>
<p><strong>HTTPプロトコルの特性</strong></p>
<ul>
<li>URLは<strong>リソースの識別子</strong></li>
<li><code>/blog/page/2/</code>は「2ページ目」というリソースを指す</li>
</ul>
</li>
</ol>
<pre><code class="language-javascript">// ブラウザの履歴APIを使った例
window.history.pushState({page: 2}, '', '/blog/page/2/');
// URLが変わるが、ページはリロードされない
</code></pre>
<h4>3. サーバーサイドの状態管理</h4>
<pre><code class="language-typescript">// データベース
const user = await db.user.findUnique({
  where: { id: userId }
});

// セッション（サーバー側）
req.session.currentPage = 2;

// キャッシュ
redis.set('user:123:page', '2');
</code></pre>
<h2>Next.jsの静的サイト生成（SSG）での状態管理</h2>
<h3>SSGの仕組み</h3>
<p>Next.jsの<code>output: 'export'</code>設定では、<strong>ビルド時</strong>にすべてのページを静的HTMLとして生成します。</p>
<pre><code class="language-typescript">// next.config.ts
const nextConfig = {
  output: 'export', // 静的サイト生成モード
}
</code></pre>
<h3>ビルド時の処理フロー</h3>
<pre><code>1. ビルド開始
   ↓
2. generateStaticParams()を実行
   - 必要なページ数を計算
   - [1, 2, 3...]のパスを生成
   ↓
3. 各ページのHTMLを生成
   - /blog/page/1/index.html
   - /blog/page/2/index.html
   ↓
4. 静的ファイルとして出力
</code></pre>
<h3>なぜ内部ストレージは不要なのか</h3>
<p><strong>静的サイトでは、各ページが独立したHTMLファイル</strong>として存在します。</p>
<pre><code>out/
├── blog/
│   ├── page/
│   │   ├── 1/
│   │   │   └── index.html  ← 1ページ目の完全なHTML
│   │   └── 2/
│   │       └── index.html  ← 2ページ目の完全なHTML
</code></pre>
<p><strong>状態はURLそのものが表現</strong>：</p>
<ul>
<li><code>/blog/page/1/</code> → 1ページ目を表示</li>
<li><code>/blog/page/2/</code> → 2ページ目を表示</li>
</ul>
<p>内部ストレージは不要で、URLとファイルシステムの対応だけで状態管理が完結します。</p>
<h2>実装手順</h2>
<h3>1. ページネーション用の関数を追加</h3>
<pre><code class="language-typescript">// src/lib/posts.ts
export const POSTS_PER_PAGE = 10;

export function getPostsWithPagination(page: number) {
  const allPosts = getSortedPostsData();
  const totalPosts = allPosts.length;
  const totalPages = Math.ceil(totalPosts / POSTS_PER_PAGE);
  
  // ページ番号の検証
  if (page &#x3C; 1 || page > totalPages) {
    return {
      posts: [],
      currentPage: page,
      totalPages,
      hasNextPage: false,
      hasPrevPage: false,
    };
  }
  
  // 該当ページのデータを切り出し
  const startIndex = (page - 1) * POSTS_PER_PAGE;
  const endIndex = startIndex + POSTS_PER_PAGE;
  const posts = allPosts.slice(startIndex, endIndex);
  
  return {
    posts,
    currentPage: page,
    totalPages,
    hasNextPage: page &#x3C; totalPages,
    hasPrevPage: page > 1,
  };
}
</code></pre>
<h3>2. 動的ルートの実装</h3>
<pre><code class="language-typescript">// src/app/blog/page/[pageNum]/page.tsx

// ビルド時に全ページ分のパスを生成
export async function generateStaticParams() {
  const totalPages = getTotalPages();
  const pages = [];
  
  for (let i = 1; i &#x3C;= totalPages; i++) {
    pages.push({ pageNum: i.toString() });
  }
  
  return pages;
  // これにより以下のHTMLが生成される：
  // /blog/page/1/index.html
  // /blog/page/2/index.html
}

export default async function BlogPage({ params }: PageProps) {
  const pageNumber = parseInt(params.pageNum, 10);
  const { posts, currentPage, totalPages } = getPostsWithPagination(pageNumber);
  
  return (
    &#x3C;div>
      &#x3C;h1>記事一覧&#x3C;/h1>
      &#x3C;p>ページ {currentPage} / {totalPages}&#x3C;/p>
      
      &#x3C;ul>
        {posts.map((post) => (
          &#x3C;li key={post.slug}>{post.title}&#x3C;/li>
        ))}
      &#x3C;/ul>
      
      &#x3C;Pagination 
        currentPage={currentPage} 
        totalPages={totalPages} 
      />
    &#x3C;/div>
  );
}
</code></pre>
<h3>3. Paginationコンポーネント</h3>
<pre><code class="language-typescript">// src/components/Pagination.tsx
export default function Pagination({ currentPage, totalPages }: Props) {
  // ページ番号の配列を生成（例：[1, 2, '...', 5, 6, 7, '...', 10]）
  const getPageNumbers = () => {
    const delta = 2; // 現在のページの前後に表示するページ数
    const range: number[] = [];
    const rangeWithDots: (number | string)[] = [];
    
    for (let i = 1; i &#x3C;= totalPages; i++) {
      if (i === 1 || i === totalPages || 
          (i >= currentPage - delta &#x26;&#x26; i &#x3C;= currentPage + delta)) {
        range.push(i);
      }
    }
    
    // 省略記号（...）を追加
    let l: number | undefined;
    range.forEach((i) => {
      if (l) {
        if (i - l === 2) {
          rangeWithDots.push(l + 1);
        } else if (i - l !== 1) {
          rangeWithDots.push('...');
        }
      }
      rangeWithDots.push(i);
      l = i;
    });
    
    return rangeWithDots;
  };
  
  return (
    &#x3C;nav aria-label="ページネーション">
      {/* 前へボタン */}
      {currentPage > 1 ? (
        &#x3C;Link href={`/blog/page/${currentPage - 1}/`}>
          ← 前へ
        &#x3C;/Link>
      ) : (
        &#x3C;span className="disabled">← 前へ&#x3C;/span>
      )}
      
      {/* ページ番号 */}
      {getPageNumbers().map((pageNum, index) => {
        if (pageNum === '...') {
          return &#x3C;span key={`dots-${index}`}>…&#x3C;/span>;
        }
        
        const page = pageNum as number;
        if (page === currentPage) {
          return &#x3C;span key={page} aria-current="page">{page}&#x3C;/span>;
        }
        
        return (
          &#x3C;Link key={page} href={`/blog/page/${page}/`}>
            {page}
          &#x3C;/Link>
        );
      })}
      
      {/* 次へボタン */}
      {currentPage &#x3C; totalPages ? (
        &#x3C;Link href={`/blog/page/${currentPage + 1}/`}>
          次へ →
        &#x3C;/Link>
      ) : (
        &#x3C;span className="disabled">次へ →&#x3C;/span>
      )}
    &#x3C;/nav>
  );
}
</code></pre>
<h2>状態管理パターンの比較</h2>
<h3>1. URLベース（今回採用）</h3>
<pre><code>/blog/page/2/
</code></pre>
<p><strong>メリット</strong>：</p>
<ul>
<li>ブックマーク可能</li>
<li>共有可能（URLを送れば同じページが見れる）</li>
<li>SEOに有利</li>
<li>ブラウザの戻る/進むボタンが機能</li>
</ul>
<p><strong>デメリット</strong>：</p>
<ul>
<li>URLが変わるとページ全体がリロード（SPAでない場合）</li>
</ul>
<h3>2. クエリパラメータベース</h3>
<pre><code>/blog?page=2
</code></pre>
<p><strong>メリット</strong>：</p>
<ul>
<li>実装が簡単</li>
<li>動的に変更しやすい</li>
</ul>
<p><strong>デメリット</strong>：</p>
<ul>
<li>URLが美しくない</li>
<li>静的生成には向かない</li>
</ul>
<h3>3. JavaScriptの状態管理</h3>
<pre><code class="language-javascript">const [currentPage, setCurrentPage] = useState(1);
</code></pre>
<p><strong>メリット</strong>：</p>
<ul>
<li>高速（ページリロードなし）</li>
<li>複雑な状態も管理可能</li>
</ul>
<p><strong>デメリット</strong>：</p>
<ul>
<li>リロードで状態が消える</li>
<li>共有不可</li>
<li>SEOに不利</li>
</ul>
<h2>パフォーマンスの改善効果</h2>
<h3>Before（全記事表示）</h3>
<pre><code>- HTML サイズ: 約50KB（16記事）
- DOM ノード数: 約500個
- 初期レンダリング: 約200ms
</code></pre>
<h3>After（10記事ずつ）</h3>
<pre><code>- HTML サイズ: 約30KB（10記事）
- DOM ノード数: 約300個
- 初期レンダリング: 約120ms
- 改善率: 約40%
</code></pre>
<h2>トラブルシューティング</h2>
<h3>遭遇したエラーと解決方法</h3>
<h4>1. 動的パスの競合エラー</h4>
<pre><code>Error: You cannot use different slug names for the same dynamic path
</code></pre>
<p><strong>原因</strong>：同じ階層に<code>[slug]</code>と<code>[page]</code>があった</p>
<p><strong>解決</strong>：ディレクトリ構造を変更</p>
<pre><code>blog/
├── [slug]/     # 記事詳細
└── page/       # ページネーション用
    └── [pageNum]/
</code></pre>
<h4>2. TypeScriptの型エラー</h4>
<pre><code class="language-typescript">// エラー：rangeWithDots has implicit type 'any[]'
const rangeWithDots = [];

// 解決：明示的な型定義
const rangeWithDots: (number | string)[] = [];
</code></pre>
<h2>まとめ</h2>
<h3>学んだこと</h3>
<ol>
<li>
<p><strong>状態管理の本質</strong></p>
<ul>
<li>状態は「情報をどこに保存するか」の問題</li>
<li>URL、メモリ、ストレージ、サーバーなど選択肢は多様</li>
</ul>
</li>
<li>
<p><strong>静的サイトでの状態管理</strong></p>
<ul>
<li>URLとファイルシステムの対応で実現</li>
<li>内部ストレージは不要</li>
<li>ビルド時にすべてのパターンを生成</li>
</ul>
</li>
<li>
<p><strong>Next.jsの強み</strong></p>
<ul>
<li>generateStaticParamsで静的ページを量産</li>
<li>URLベースの美しい状態管理</li>
<li>SEOとパフォーマンスの両立</li>
</ul>
</li>
</ol>
<h3>今後の拡張案</h3>
<ol>
<li>
<p><strong>検索機能の追加</strong></p>
<ul>
<li>タグによるフィルタリング</li>
<li>全文検索の実装</li>
</ul>
</li>
<li>
<p><strong>無限スクロール</strong></p>
<ul>
<li>Intersection Observer APIの活用</li>
<li>段階的な記事読み込み</li>
</ul>
</li>
<li>
<p><strong>ユーザー設定の保存</strong></p>
<ul>
<li>1ページあたりの表示件数をLocalStorageに保存</li>
<li>ダークモード設定の永続化</li>
</ul>
</li>
</ol>
<h2>参考資料</h2>
<ul>
<li><a href="https://nextjs.org/docs/app">Next.js App Router Documentation</a></li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/History_API">MDN Web Docs - History API</a></li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/Web_Storage_API">MDN Web Docs - Web Storage API</a></li>
<li><a href="https://react.dev/learn/managing-state">Understanding State Management in React</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic">静的サイト生成（SSG）とは</a></li>
</ul>
4:["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","h1",null,{"className":"text-3xl font-bold mb-2","children":[["$","span",null,{"className":"text-green-600","children":["#",17]}]," ","Next.jsでページネーション実装とWebアプリケーションの状態管理を完全理解"]}],["$","ul",null,{"className":"list-none border-b border-gray-600 pb-4 mb-6","children":[["$","li",null,{"className":"text-gray-500 text-sm","children":["作成日時: ","2025-01-08 23:55"]}],"$undefined",["$","li",null,{"className":"flex flex-wrap gap-2 mt-2","children":[["$","span","0",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"Next.js"}],["$","span","1",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"React"}],["$","span","2",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"TypeScript"}],["$","span","3",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"状態管理"}],["$","span","4",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"ページネーション"}],["$","span","5",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"SSG"}],["$","span","6",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"Web開発"}]]}]]}],["$","nav",null,{"className":"mb-6 pb-4 border-b border-gray-700 flex justify-between","children":[["$","$L12",null,{"href":"/","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"← ホームへ"}],["$","$L12",null,{"href":"/blog","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"記事一覧へ →"}]]}],["$","article",null,{"className":"prose dark:prose-invert","dangerouslySetInnerHTML":{"__html":"$13"}}],["$","nav",null,{"className":"mt-8 pt-4 border-t border-gray-700 flex justify-between","children":[["$","$L12",null,{"href":"/","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"← ホームへ"}],["$","$L12",null,{"href":"/blog","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"記事一覧へ →"}]]}]]}]
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
11:{"metadata":[["$","title","0",{"children":"Maita Tomoya Dev IO"}],["$","meta","1",{"name":"description","content":"米田智哉の技術ブログ。キャッチアップしたことをメモします。"}]],"error":null,"digest":"$undefined"}
b:{"metadata":"$11:metadata","error":null,"digest":"$undefined"}
