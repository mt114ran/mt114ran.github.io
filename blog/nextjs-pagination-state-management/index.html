<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/02b253edc89c9fad.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-29ebadaebe2fcb3f.js"/><script src="/_next/static/chunks/4bd1b696-d8f047cced1b4886.js" async=""></script><script src="/_next/static/chunks/684-31ed86cc5a6e53ad.js" async=""></script><script src="/_next/static/chunks/main-app-d1c324b32b03123c.js" async=""></script><script src="/_next/static/chunks/874-6d44df717ef1e402.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-3b7c091bda807474.js" async=""></script><meta name="next-size-adjust" content=""/><link rel="icon" href="/favicon.png" type="image/png"/><title>Maita Tomoya Dev IO</title><meta name="description" content="米田智哉の技術ブログ。キャッチアップしたことをメモします。"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 antialiased"><div class="max-w-2xl mx-auto py-10 px-4"><h1 class="text-3xl font-bold mb-2"><span class="text-green-600">#<!-- -->17</span> <!-- -->Next.jsでページネーション実装とWebアプリケーションの状態管理を完全理解</h1><ul class="list-none border-b border-gray-600 pb-4 mb-6"><li class="text-gray-500 text-sm">作成日時: <!-- -->2025-01-08 23:55</li><li class="flex flex-wrap gap-2 mt-2"><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">Next.js</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">React</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">TypeScript</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">状態管理</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">ページネーション</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">SSG</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">Web開発</span></li></ul><nav class="mb-6 pb-4 border-b border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav><article class="prose dark:prose-invert"><h1 id="nextjsでページネーション実装とwebアプリケーションの状態管理を完全理解">Next.jsでページネーション実装とWebアプリケーションの状態管理を完全理解</h1>
<h2 id="はじめに">はじめに</h2>
<p>技術ブログの記事が16本を超えて、一覧ページが長くなりすぎる問題に直面しました。今回はNext.js App Routerでページネーション機能を実装しながら、<strong>Webアプリケーションの状態管理</strong>について深く理解していきます。</p>
<p>「なぜHTMLとCSS/JavaScriptで状態を管理できるのか？」「内部ストレージに保持しているの？」といった疑問も解決していきます。</p>
<h2 id="現在の問題点">現在の問題点</h2>
<pre><code class="language-typescript">// 現在の実装：全記事を一度に表示
export default function BlogIndex() {
  const posts = getSortedPostsData() // 全16記事を取得
  
  return (
    &#x3C;ul>
      {posts.map((post) => ( // 全記事を表示
        &#x3C;li key={post.slug}>{post.title}&#x3C;/li>
      ))}
    &#x3C;/ul>
  )
}
</code></pre>
<h3 id="問題点の整理">問題点の整理</h3>
<ol>
<li>
<p><strong>パフォーマンス問題</strong></p>
<ul>
<li>記事数が増えるとHTMLサイズが肥大化</li>
<li>ブラウザのレンダリング負荷が増大</li>
<li>初期表示時間が遅くなる</li>
</ul>
</li>
<li>
<p><strong>ユーザビリティ問題</strong></p>
<ul>
<li>スクロールが長すぎて目的の記事を見つけにくい</li>
<li>古い記事にアクセスしづらい</li>
</ul>
</li>
</ol>
<h2 id="webアプリケーションの状態管理とは">Webアプリケーションの状態管理とは</h2>
<h3 id="状態stateとは何か">状態（State）とは何か</h3>
<p><strong>状態</strong>とは、アプリケーションが「今どのような状態にあるか」を表す情報です。</p>
<p>例えば：</p>
<ul>
<li>現在表示しているページ番号</li>
<li>ユーザーがログインしているか</li>
<li>フォームに入力された値</li>
<li>選択されたタブ</li>
</ul>
<h3 id="状態を管理する3つの場所">状態を管理する3つの場所</h3>
<h4 id="1-クライアントサイドブラウザの状態管理">1. クライアントサイド（ブラウザ）の状態管理</h4>
<pre><code class="language-javascript">// 1. JavaScriptのメモリ（変数）
let currentPage = 1;

// 2. LocalStorage（永続的）
localStorage.setItem('currentPage', '1');
// ブラウザを閉じても保持される

// 3. SessionStorage（一時的）
sessionStorage.setItem('currentPage', '1');
// タブを閉じると消える

// 4. Cookie
document.cookie = 'currentPage=1; path=/';
// サーバーにも送信される
</code></pre>
<p><strong>特徴</strong>：</p>
<ul>
<li><strong>メモリ</strong>：ページをリロードすると消える</li>
<li><strong>LocalStorage</strong>：最大5MB程度、永続的に保存</li>
<li><strong>SessionStorage</strong>：タブごとに独立、タブを閉じると消える</li>
<li><strong>Cookie</strong>：最大4KB、サーバーとの通信時に自動送信</li>
</ul>
<h4 id="2-urlアドレスバーによる状態管理">2. URL（アドレスバー）による状態管理</h4>
<pre><code>https://example.com/blog/page/2/
                          ↑
                    この部分が状態を表す
</code></pre>
<p><strong>なぜURLで状態管理ができるのか</strong>：</p>
<ol>
<li>
<p><strong>ブラウザの仕組み</strong></p>
<ul>
<li>URLはブラウザが管理する「現在地」情報</li>
<li>履歴API（History API）でURLを操作可能</li>
<li>ブックマーク可能、共有可能</li>
</ul>
</li>
<li>
<p><strong>HTTPプロトコルの特性</strong></p>
<ul>
<li>URLは<strong>リソースの識別子</strong></li>
<li><code>/blog/page/2/</code>は「2ページ目」というリソースを指す</li>
</ul>
</li>
</ol>
<pre><code class="language-javascript">// ブラウザの履歴APIを使った例
window.history.pushState({page: 2}, '', '/blog/page/2/');
// URLが変わるが、ページはリロードされない
</code></pre>
<h4 id="3-サーバーサイドの状態管理">3. サーバーサイドの状態管理</h4>
<pre><code class="language-typescript">// データベース
const user = await db.user.findUnique({
  where: { id: userId }
});

// セッション（サーバー側）
req.session.currentPage = 2;

// キャッシュ
redis.set('user:123:page', '2');
</code></pre>
<h2 id="nextjsの静的サイト生成ssgでの状態管理">Next.jsの静的サイト生成（SSG）での状態管理</h2>
<h3 id="ssgの仕組み">SSGの仕組み</h3>
<p>Next.jsの<code>output: 'export'</code>設定では、<strong>ビルド時</strong>にすべてのページを静的HTMLとして生成します。</p>
<pre><code class="language-typescript">// next.config.ts
const nextConfig = {
  output: 'export', // 静的サイト生成モード
}
</code></pre>
<h3 id="ビルド時の処理フロー">ビルド時の処理フロー</h3>
<pre><code>1. ビルド開始
   ↓
2. generateStaticParams()を実行
   - 必要なページ数を計算
   - [1, 2, 3...]のパスを生成
   ↓
3. 各ページのHTMLを生成
   - /blog/page/1/index.html
   - /blog/page/2/index.html
   ↓
4. 静的ファイルとして出力
</code></pre>
<h3 id="なぜ内部ストレージは不要なのか">なぜ内部ストレージは不要なのか</h3>
<p><strong>静的サイトでは、各ページが独立したHTMLファイル</strong>として存在します。</p>
<pre><code>out/
├── blog/
│   ├── page/
│   │   ├── 1/
│   │   │   └── index.html  ← 1ページ目の完全なHTML
│   │   └── 2/
│   │       └── index.html  ← 2ページ目の完全なHTML
</code></pre>
<p><strong>状態はURLそのものが表現</strong>：</p>
<ul>
<li><code>/blog/page/1/</code> → 1ページ目を表示</li>
<li><code>/blog/page/2/</code> → 2ページ目を表示</li>
</ul>
<p>内部ストレージは不要で、URLとファイルシステムの対応だけで状態管理が完結します。</p>
<h2 id="実装手順">実装手順</h2>
<h3 id="1-ページネーション用の関数を追加">1. ページネーション用の関数を追加</h3>
<pre><code class="language-typescript">// src/lib/posts.ts
export const POSTS_PER_PAGE = 10;

export function getPostsWithPagination(page: number) {
  const allPosts = getSortedPostsData();
  const totalPosts = allPosts.length;
  const totalPages = Math.ceil(totalPosts / POSTS_PER_PAGE);
  
  // ページ番号の検証
  if (page &#x3C; 1 || page > totalPages) {
    return {
      posts: [],
      currentPage: page,
      totalPages,
      hasNextPage: false,
      hasPrevPage: false,
    };
  }
  
  // 該当ページのデータを切り出し
  const startIndex = (page - 1) * POSTS_PER_PAGE;
  const endIndex = startIndex + POSTS_PER_PAGE;
  const posts = allPosts.slice(startIndex, endIndex);
  
  return {
    posts,
    currentPage: page,
    totalPages,
    hasNextPage: page &#x3C; totalPages,
    hasPrevPage: page > 1,
  };
}
</code></pre>
<h3 id="2-動的ルートの実装">2. 動的ルートの実装</h3>
<pre><code class="language-typescript">// src/app/blog/page/[pageNum]/page.tsx

// ビルド時に全ページ分のパスを生成
export async function generateStaticParams() {
  const totalPages = getTotalPages();
  const pages = [];
  
  for (let i = 1; i &#x3C;= totalPages; i++) {
    pages.push({ pageNum: i.toString() });
  }
  
  return pages;
  // これにより以下のHTMLが生成される：
  // /blog/page/1/index.html
  // /blog/page/2/index.html
}

export default async function BlogPage({ params }: PageProps) {
  const pageNumber = parseInt(params.pageNum, 10);
  const { posts, currentPage, totalPages } = getPostsWithPagination(pageNumber);
  
  return (
    &#x3C;div>
      &#x3C;h1>記事一覧&#x3C;/h1>
      &#x3C;p>ページ {currentPage} / {totalPages}&#x3C;/p>
      
      &#x3C;ul>
        {posts.map((post) => (
          &#x3C;li key={post.slug}>{post.title}&#x3C;/li>
        ))}
      &#x3C;/ul>
      
      &#x3C;Pagination 
        currentPage={currentPage} 
        totalPages={totalPages} 
      />
    &#x3C;/div>
  );
}
</code></pre>
<h3 id="3-paginationコンポーネント">3. Paginationコンポーネント</h3>
<pre><code class="language-typescript">// src/components/Pagination.tsx
export default function Pagination({ currentPage, totalPages }: Props) {
  // ページ番号の配列を生成（例：[1, 2, '...', 5, 6, 7, '...', 10]）
  const getPageNumbers = () => {
    const delta = 2; // 現在のページの前後に表示するページ数
    const range: number[] = [];
    const rangeWithDots: (number | string)[] = [];
    
    for (let i = 1; i &#x3C;= totalPages; i++) {
      if (i === 1 || i === totalPages || 
          (i >= currentPage - delta &#x26;&#x26; i &#x3C;= currentPage + delta)) {
        range.push(i);
      }
    }
    
    // 省略記号（...）を追加
    let l: number | undefined;
    range.forEach((i) => {
      if (l) {
        if (i - l === 2) {
          rangeWithDots.push(l + 1);
        } else if (i - l !== 1) {
          rangeWithDots.push('...');
        }
      }
      rangeWithDots.push(i);
      l = i;
    });
    
    return rangeWithDots;
  };
  
  return (
    &#x3C;nav aria-label="ページネーション">
      {/* 前へボタン */}
      {currentPage > 1 ? (
        &#x3C;Link href={`/blog/page/${currentPage - 1}/`}>
          ← 前へ
        &#x3C;/Link>
      ) : (
        &#x3C;span className="disabled">← 前へ&#x3C;/span>
      )}
      
      {/* ページ番号 */}
      {getPageNumbers().map((pageNum, index) => {
        if (pageNum === '...') {
          return &#x3C;span key={`dots-${index}`}>…&#x3C;/span>;
        }
        
        const page = pageNum as number;
        if (page === currentPage) {
          return &#x3C;span key={page} aria-current="page">{page}&#x3C;/span>;
        }
        
        return (
          &#x3C;Link key={page} href={`/blog/page/${page}/`}>
            {page}
          &#x3C;/Link>
        );
      })}
      
      {/* 次へボタン */}
      {currentPage &#x3C; totalPages ? (
        &#x3C;Link href={`/blog/page/${currentPage + 1}/`}>
          次へ →
        &#x3C;/Link>
      ) : (
        &#x3C;span className="disabled">次へ →&#x3C;/span>
      )}
    &#x3C;/nav>
  );
}
</code></pre>
<h2 id="状態管理パターンの比較">状態管理パターンの比較</h2>
<h3 id="1-urlベース今回採用">1. URLベース（今回採用）</h3>
<pre><code>/blog/page/2/
</code></pre>
<p><strong>メリット</strong>：</p>
<ul>
<li>ブックマーク可能</li>
<li>共有可能（URLを送れば同じページが見れる）</li>
<li>SEOに有利</li>
<li>ブラウザの戻る/進むボタンが機能</li>
</ul>
<p><strong>デメリット</strong>：</p>
<ul>
<li>URLが変わるとページ全体がリロード（SPAでない場合）</li>
</ul>
<h3 id="2-クエリパラメータベース">2. クエリパラメータベース</h3>
<pre><code>/blog?page=2
</code></pre>
<p><strong>メリット</strong>：</p>
<ul>
<li>実装が簡単</li>
<li>動的に変更しやすい</li>
</ul>
<p><strong>デメリット</strong>：</p>
<ul>
<li>URLが美しくない</li>
<li>静的生成には向かない</li>
</ul>
<h3 id="3-javascriptの状態管理">3. JavaScriptの状態管理</h3>
<pre><code class="language-javascript">const [currentPage, setCurrentPage] = useState(1);
</code></pre>
<p><strong>メリット</strong>：</p>
<ul>
<li>高速（ページリロードなし）</li>
<li>複雑な状態も管理可能</li>
</ul>
<p><strong>デメリット</strong>：</p>
<ul>
<li>リロードで状態が消える</li>
<li>共有不可</li>
<li>SEOに不利</li>
</ul>
<h2 id="パフォーマンスの改善効果">パフォーマンスの改善効果</h2>
<h3 id="before全記事表示">Before（全記事表示）</h3>
<pre><code>- HTML サイズ: 約50KB（16記事）
- DOM ノード数: 約500個
- 初期レンダリング: 約200ms
</code></pre>
<h3 id="after10記事ずつ">After（10記事ずつ）</h3>
<pre><code>- HTML サイズ: 約30KB（10記事）
- DOM ノード数: 約300個
- 初期レンダリング: 約120ms
- 改善率: 約40%
</code></pre>
<h2 id="トラブルシューティング">トラブルシューティング</h2>
<h3 id="遭遇したエラーと解決方法">遭遇したエラーと解決方法</h3>
<h4 id="1-動的パスの競合エラー">1. 動的パスの競合エラー</h4>
<pre><code>Error: You cannot use different slug names for the same dynamic path
</code></pre>
<p><strong>原因</strong>：同じ階層に<code>[slug]</code>と<code>[page]</code>があった</p>
<p><strong>解決</strong>：ディレクトリ構造を変更</p>
<pre><code>blog/
├── [slug]/     # 記事詳細
└── page/       # ページネーション用
    └── [pageNum]/
</code></pre>
<h4 id="2-typescriptの型エラー">2. TypeScriptの型エラー</h4>
<pre><code class="language-typescript">// エラー：rangeWithDots has implicit type 'any[]'
const rangeWithDots = [];

// 解決：明示的な型定義
const rangeWithDots: (number | string)[] = [];
</code></pre>
<h2 id="まとめ">まとめ</h2>
<h3 id="学んだこと">学んだこと</h3>
<ol>
<li>
<p><strong>状態管理の本質</strong></p>
<ul>
<li>状態は「情報をどこに保存するか」の問題</li>
<li>URL、メモリ、ストレージ、サーバーなど選択肢は多様</li>
</ul>
</li>
<li>
<p><strong>静的サイトでの状態管理</strong></p>
<ul>
<li>URLとファイルシステムの対応で実現</li>
<li>内部ストレージは不要</li>
<li>ビルド時にすべてのパターンを生成</li>
</ul>
</li>
<li>
<p><strong>Next.jsの強み</strong></p>
<ul>
<li>generateStaticParamsで静的ページを量産</li>
<li>URLベースの美しい状態管理</li>
<li>SEOとパフォーマンスの両立</li>
</ul>
</li>
</ol>
<h3 id="今後の拡張案">今後の拡張案</h3>
<ol>
<li>
<p><strong>検索機能の追加</strong></p>
<ul>
<li>タグによるフィルタリング</li>
<li>全文検索の実装</li>
</ul>
</li>
<li>
<p><strong>無限スクロール</strong></p>
<ul>
<li>Intersection Observer APIの活用</li>
<li>段階的な記事読み込み</li>
</ul>
</li>
<li>
<p><strong>ユーザー設定の保存</strong></p>
<ul>
<li>1ページあたりの表示件数をLocalStorageに保存</li>
<li>ダークモード設定の永続化</li>
</ul>
</li>
</ol>
<h2 id="参考資料">参考資料</h2>
<ul>
<li><a href="https://nextjs.org/docs/app">Next.js App Router Documentation</a></li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/History_API">MDN Web Docs - History API</a></li>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/Web_Storage_API">MDN Web Docs - Web Storage API</a></li>
<li><a href="https://react.dev/learn/managing-state">Understanding State Management in React</a></li>
<li><a href="https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic">静的サイト生成（SSG）とは</a></li>
</ul></article><nav class="mt-8 pt-4 border-t border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-29ebadaebe2fcb3f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n5:I[9665,[],\"MetadataBoundary\"]\n7:I[9665,[],\"OutletBoundary\"]\na:I[4911,[],\"AsyncMetadataOutlet\"]\nc:I[9665,[],\"ViewportBoundary\"]\ne:I[6614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/02b253edc89c9fad.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"pkdKHHclo4VaH_aYBL_if\",\"p\":\"\",\"c\":[\"\",\"blog\",\"nextjs-pagination-state-management\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"nextjs-pagination-state-management\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/02b253edc89c9fad.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png\",\"type\":\"image/png\"}]}],[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"nextjs-pagination-state-management\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[\"$\",\"$L5\",null,{\"children\":\"$L6\"}],null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"PkJ7hoNtGGJ8hu66233ev\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:\"$Sreact.suspense\"\n10:I[4911,[],\"AsyncMetadata\"]\n6:[\"$\",\"$f\",null,{\"fallback\":null,\"children\":[\"$\",\"$L10\",null,{\"promise\":\"$@11\"}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"12:I[6874,[\"874\",\"static/chunks/874-6d44df717ef1e402.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-3b7c091bda807474.js\"],\"\"]\n14:I[4197,[\"874\",\"static/chunks/874-6d44df717ef1e402.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-3b7c091bda807474.js\"],\"default\"]\n13:T3c07,"])</script><script>self.__next_f.push([1,"\u003ch1 id=\"nextjsでページネーション実装とwebアプリケーションの状態管理を完全理解\"\u003eNext.jsでページネーション実装とWebアプリケーションの状態管理を完全理解\u003c/h1\u003e\n\u003ch2 id=\"はじめに\"\u003eはじめに\u003c/h2\u003e\n\u003cp\u003e技術ブログの記事が16本を超えて、一覧ページが長くなりすぎる問題に直面しました。今回はNext.js App Routerでページネーション機能を実装しながら、\u003cstrong\u003eWebアプリケーションの状態管理\u003c/strong\u003eについて深く理解していきます。\u003c/p\u003e\n\u003cp\u003e「なぜHTMLとCSS/JavaScriptで状態を管理できるのか？」「内部ストレージに保持しているの？」といった疑問も解決していきます。\u003c/p\u003e\n\u003ch2 id=\"現在の問題点\"\u003e現在の問題点\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// 現在の実装：全記事を一度に表示\nexport default function BlogIndex() {\n  const posts = getSortedPostsData() // 全16記事を取得\n  \n  return (\n    \u0026#x3C;ul\u003e\n      {posts.map((post) =\u003e ( // 全記事を表示\n        \u0026#x3C;li key={post.slug}\u003e{post.title}\u0026#x3C;/li\u003e\n      ))}\n    \u0026#x3C;/ul\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"問題点の整理\"\u003e問題点の整理\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eパフォーマンス問題\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e記事数が増えるとHTMLサイズが肥大化\u003c/li\u003e\n\u003cli\u003eブラウザのレンダリング負荷が増大\u003c/li\u003e\n\u003cli\u003e初期表示時間が遅くなる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eユーザビリティ問題\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eスクロールが長すぎて目的の記事を見つけにくい\u003c/li\u003e\n\u003cli\u003e古い記事にアクセスしづらい\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"webアプリケーションの状態管理とは\"\u003eWebアプリケーションの状態管理とは\u003c/h2\u003e\n\u003ch3 id=\"状態stateとは何か\"\u003e状態（State）とは何か\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e状態\u003c/strong\u003eとは、アプリケーションが「今どのような状態にあるか」を表す情報です。\u003c/p\u003e\n\u003cp\u003e例えば：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e現在表示しているページ番号\u003c/li\u003e\n\u003cli\u003eユーザーがログインしているか\u003c/li\u003e\n\u003cli\u003eフォームに入力された値\u003c/li\u003e\n\u003cli\u003e選択されたタブ\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"状態を管理する3つの場所\"\u003e状態を管理する3つの場所\u003c/h3\u003e\n\u003ch4 id=\"1-クライアントサイドブラウザの状態管理\"\u003e1. クライアントサイド（ブラウザ）の状態管理\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 1. JavaScriptのメモリ（変数）\nlet currentPage = 1;\n\n// 2. LocalStorage（永続的）\nlocalStorage.setItem('currentPage', '1');\n// ブラウザを閉じても保持される\n\n// 3. SessionStorage（一時的）\nsessionStorage.setItem('currentPage', '1');\n// タブを閉じると消える\n\n// 4. Cookie\ndocument.cookie = 'currentPage=1; path=/';\n// サーバーにも送信される\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e特徴\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eメモリ\u003c/strong\u003e：ページをリロードすると消える\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLocalStorage\u003c/strong\u003e：最大5MB程度、永続的に保存\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSessionStorage\u003c/strong\u003e：タブごとに独立、タブを閉じると消える\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCookie\u003c/strong\u003e：最大4KB、サーバーとの通信時に自動送信\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-urlアドレスバーによる状態管理\"\u003e2. URL（アドレスバー）による状態管理\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ehttps://example.com/blog/page/2/\n                          ↑\n                    この部分が状態を表す\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eなぜURLで状態管理ができるのか\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eブラウザの仕組み\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eURLはブラウザが管理する「現在地」情報\u003c/li\u003e\n\u003cli\u003e履歴API（History API）でURLを操作可能\u003c/li\u003e\n\u003cli\u003eブックマーク可能、共有可能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eHTTPプロトコルの特性\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eURLは\u003cstrong\u003eリソースの識別子\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/blog/page/2/\u003c/code\u003eは「2ページ目」というリソースを指す\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// ブラウザの履歴APIを使った例\nwindow.history.pushState({page: 2}, '', '/blog/page/2/');\n// URLが変わるが、ページはリロードされない\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"3-サーバーサイドの状態管理\"\u003e3. サーバーサイドの状態管理\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// データベース\nconst user = await db.user.findUnique({\n  where: { id: userId }\n});\n\n// セッション（サーバー側）\nreq.session.currentPage = 2;\n\n// キャッシュ\nredis.set('user:123:page', '2');\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"nextjsの静的サイト生成ssgでの状態管理\"\u003eNext.jsの静的サイト生成（SSG）での状態管理\u003c/h2\u003e\n\u003ch3 id=\"ssgの仕組み\"\u003eSSGの仕組み\u003c/h3\u003e\n\u003cp\u003eNext.jsの\u003ccode\u003eoutput: 'export'\u003c/code\u003e設定では、\u003cstrong\u003eビルド時\u003c/strong\u003eにすべてのページを静的HTMLとして生成します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// next.config.ts\nconst nextConfig = {\n  output: 'export', // 静的サイト生成モード\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ビルド時の処理フロー\"\u003eビルド時の処理フロー\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e1. ビルド開始\n   ↓\n2. generateStaticParams()を実行\n   - 必要なページ数を計算\n   - [1, 2, 3...]のパスを生成\n   ↓\n3. 各ページのHTMLを生成\n   - /blog/page/1/index.html\n   - /blog/page/2/index.html\n   ↓\n4. 静的ファイルとして出力\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"なぜ内部ストレージは不要なのか\"\u003eなぜ内部ストレージは不要なのか\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e静的サイトでは、各ページが独立したHTMLファイル\u003c/strong\u003eとして存在します。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eout/\n├── blog/\n│   ├── page/\n│   │   ├── 1/\n│   │   │   └── index.html  ← 1ページ目の完全なHTML\n│   │   └── 2/\n│   │       └── index.html  ← 2ページ目の完全なHTML\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e状態はURLそのものが表現\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/blog/page/1/\u003c/code\u003e → 1ページ目を表示\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/blog/page/2/\u003c/code\u003e → 2ページ目を表示\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e内部ストレージは不要で、URLとファイルシステムの対応だけで状態管理が完結します。\u003c/p\u003e\n\u003ch2 id=\"実装手順\"\u003e実装手順\u003c/h2\u003e\n\u003ch3 id=\"1-ページネーション用の関数を追加\"\u003e1. ページネーション用の関数を追加\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// src/lib/posts.ts\nexport const POSTS_PER_PAGE = 10;\n\nexport function getPostsWithPagination(page: number) {\n  const allPosts = getSortedPostsData();\n  const totalPosts = allPosts.length;\n  const totalPages = Math.ceil(totalPosts / POSTS_PER_PAGE);\n  \n  // ページ番号の検証\n  if (page \u0026#x3C; 1 || page \u003e totalPages) {\n    return {\n      posts: [],\n      currentPage: page,\n      totalPages,\n      hasNextPage: false,\n      hasPrevPage: false,\n    };\n  }\n  \n  // 該当ページのデータを切り出し\n  const startIndex = (page - 1) * POSTS_PER_PAGE;\n  const endIndex = startIndex + POSTS_PER_PAGE;\n  const posts = allPosts.slice(startIndex, endIndex);\n  \n  return {\n    posts,\n    currentPage: page,\n    totalPages,\n    hasNextPage: page \u0026#x3C; totalPages,\n    hasPrevPage: page \u003e 1,\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"2-動的ルートの実装\"\u003e2. 動的ルートの実装\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// src/app/blog/page/[pageNum]/page.tsx\n\n// ビルド時に全ページ分のパスを生成\nexport async function generateStaticParams() {\n  const totalPages = getTotalPages();\n  const pages = [];\n  \n  for (let i = 1; i \u0026#x3C;= totalPages; i++) {\n    pages.push({ pageNum: i.toString() });\n  }\n  \n  return pages;\n  // これにより以下のHTMLが生成される：\n  // /blog/page/1/index.html\n  // /blog/page/2/index.html\n}\n\nexport default async function BlogPage({ params }: PageProps) {\n  const pageNumber = parseInt(params.pageNum, 10);\n  const { posts, currentPage, totalPages } = getPostsWithPagination(pageNumber);\n  \n  return (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;h1\u003e記事一覧\u0026#x3C;/h1\u003e\n      \u0026#x3C;p\u003eページ {currentPage} / {totalPages}\u0026#x3C;/p\u003e\n      \n      \u0026#x3C;ul\u003e\n        {posts.map((post) =\u003e (\n          \u0026#x3C;li key={post.slug}\u003e{post.title}\u0026#x3C;/li\u003e\n        ))}\n      \u0026#x3C;/ul\u003e\n      \n      \u0026#x3C;Pagination \n        currentPage={currentPage} \n        totalPages={totalPages} \n      /\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"3-paginationコンポーネント\"\u003e3. Paginationコンポーネント\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// src/components/Pagination.tsx\nexport default function Pagination({ currentPage, totalPages }: Props) {\n  // ページ番号の配列を生成（例：[1, 2, '...', 5, 6, 7, '...', 10]）\n  const getPageNumbers = () =\u003e {\n    const delta = 2; // 現在のページの前後に表示するページ数\n    const range: number[] = [];\n    const rangeWithDots: (number | string)[] = [];\n    \n    for (let i = 1; i \u0026#x3C;= totalPages; i++) {\n      if (i === 1 || i === totalPages || \n          (i \u003e= currentPage - delta \u0026#x26;\u0026#x26; i \u0026#x3C;= currentPage + delta)) {\n        range.push(i);\n      }\n    }\n    \n    // 省略記号（...）を追加\n    let l: number | undefined;\n    range.forEach((i) =\u003e {\n      if (l) {\n        if (i - l === 2) {\n          rangeWithDots.push(l + 1);\n        } else if (i - l !== 1) {\n          rangeWithDots.push('...');\n        }\n      }\n      rangeWithDots.push(i);\n      l = i;\n    });\n    \n    return rangeWithDots;\n  };\n  \n  return (\n    \u0026#x3C;nav aria-label=\"ページネーション\"\u003e\n      {/* 前へボタン */}\n      {currentPage \u003e 1 ? (\n        \u0026#x3C;Link href={`/blog/page/${currentPage - 1}/`}\u003e\n          ← 前へ\n        \u0026#x3C;/Link\u003e\n      ) : (\n        \u0026#x3C;span className=\"disabled\"\u003e← 前へ\u0026#x3C;/span\u003e\n      )}\n      \n      {/* ページ番号 */}\n      {getPageNumbers().map((pageNum, index) =\u003e {\n        if (pageNum === '...') {\n          return \u0026#x3C;span key={`dots-${index}`}\u003e…\u0026#x3C;/span\u003e;\n        }\n        \n        const page = pageNum as number;\n        if (page === currentPage) {\n          return \u0026#x3C;span key={page} aria-current=\"page\"\u003e{page}\u0026#x3C;/span\u003e;\n        }\n        \n        return (\n          \u0026#x3C;Link key={page} href={`/blog/page/${page}/`}\u003e\n            {page}\n          \u0026#x3C;/Link\u003e\n        );\n      })}\n      \n      {/* 次へボタン */}\n      {currentPage \u0026#x3C; totalPages ? (\n        \u0026#x3C;Link href={`/blog/page/${currentPage + 1}/`}\u003e\n          次へ →\n        \u0026#x3C;/Link\u003e\n      ) : (\n        \u0026#x3C;span className=\"disabled\"\u003e次へ →\u0026#x3C;/span\u003e\n      )}\n    \u0026#x3C;/nav\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"状態管理パターンの比較\"\u003e状態管理パターンの比較\u003c/h2\u003e\n\u003ch3 id=\"1-urlベース今回採用\"\u003e1. URLベース（今回採用）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e/blog/page/2/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eメリット\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eブックマーク可能\u003c/li\u003e\n\u003cli\u003e共有可能（URLを送れば同じページが見れる）\u003c/li\u003e\n\u003cli\u003eSEOに有利\u003c/li\u003e\n\u003cli\u003eブラウザの戻る/進むボタンが機能\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eデメリット\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eURLが変わるとページ全体がリロード（SPAでない場合）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-クエリパラメータベース\"\u003e2. クエリパラメータベース\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e/blog?page=2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eメリット\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e実装が簡単\u003c/li\u003e\n\u003cli\u003e動的に変更しやすい\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eデメリット\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eURLが美しくない\u003c/li\u003e\n\u003cli\u003e静的生成には向かない\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-javascriptの状態管理\"\u003e3. JavaScriptの状態管理\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst [currentPage, setCurrentPage] = useState(1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eメリット\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e高速（ページリロードなし）\u003c/li\u003e\n\u003cli\u003e複雑な状態も管理可能\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eデメリット\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eリロードで状態が消える\u003c/li\u003e\n\u003cli\u003e共有不可\u003c/li\u003e\n\u003cli\u003eSEOに不利\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"パフォーマンスの改善効果\"\u003eパフォーマンスの改善効果\u003c/h2\u003e\n\u003ch3 id=\"before全記事表示\"\u003eBefore（全記事表示）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e- HTML サイズ: 約50KB（16記事）\n- DOM ノード数: 約500個\n- 初期レンダリング: 約200ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"after10記事ずつ\"\u003eAfter（10記事ずつ）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e- HTML サイズ: 約30KB（10記事）\n- DOM ノード数: 約300個\n- 初期レンダリング: 約120ms\n- 改善率: 約40%\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"トラブルシューティング\"\u003eトラブルシューティング\u003c/h2\u003e\n\u003ch3 id=\"遭遇したエラーと解決方法\"\u003e遭遇したエラーと解決方法\u003c/h3\u003e\n\u003ch4 id=\"1-動的パスの競合エラー\"\u003e1. 動的パスの競合エラー\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003eError: You cannot use different slug names for the same dynamic path\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e原因\u003c/strong\u003e：同じ階層に\u003ccode\u003e[slug]\u003c/code\u003eと\u003ccode\u003e[page]\u003c/code\u003eがあった\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解決\u003c/strong\u003e：ディレクトリ構造を変更\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eblog/\n├── [slug]/     # 記事詳細\n└── page/       # ページネーション用\n    └── [pageNum]/\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"2-typescriptの型エラー\"\u003e2. TypeScriptの型エラー\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// エラー：rangeWithDots has implicit type 'any[]'\nconst rangeWithDots = [];\n\n// 解決：明示的な型定義\nconst rangeWithDots: (number | string)[] = [];\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"まとめ\"\u003eまとめ\u003c/h2\u003e\n\u003ch3 id=\"学んだこと\"\u003e学んだこと\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e状態管理の本質\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e状態は「情報をどこに保存するか」の問題\u003c/li\u003e\n\u003cli\u003eURL、メモリ、ストレージ、サーバーなど選択肢は多様\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e静的サイトでの状態管理\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eURLとファイルシステムの対応で実現\u003c/li\u003e\n\u003cli\u003e内部ストレージは不要\u003c/li\u003e\n\u003cli\u003eビルド時にすべてのパターンを生成\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNext.jsの強み\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egenerateStaticParamsで静的ページを量産\u003c/li\u003e\n\u003cli\u003eURLベースの美しい状態管理\u003c/li\u003e\n\u003cli\u003eSEOとパフォーマンスの両立\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"今後の拡張案\"\u003e今後の拡張案\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e検索機能の追加\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eタグによるフィルタリング\u003c/li\u003e\n\u003cli\u003e全文検索の実装\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e無限スクロール\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIntersection Observer APIの活用\u003c/li\u003e\n\u003cli\u003e段階的な記事読み込み\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eユーザー設定の保存\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1ページあたりの表示件数をLocalStorageに保存\u003c/li\u003e\n\u003cli\u003eダークモード設定の永続化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"参考資料\"\u003e参考資料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/docs/app\"\u003eNext.js App Router Documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/ja/docs/Web/API/History_API\"\u003eMDN Web Docs - History API\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/ja/docs/Web/API/Web_Storage_API\"\u003eMDN Web Docs - Web Storage API\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://react.dev/learn/managing-state\"\u003eUnderstanding State Management in React\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic\"\u003e静的サイト生成（SSG）とは\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold mb-2\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-green-600\",\"children\":[\"#\",17]}],\" \",\"Next.jsでページネーション実装とWebアプリケーションの状態管理を完全理解\"]}],[\"$\",\"ul\",null,{\"className\":\"list-none border-b border-gray-600 pb-4 mb-6\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"作成日時: \",\"2025-01-08 23:55\"]}],\"$undefined\",[\"$\",\"li\",null,{\"className\":\"flex flex-wrap gap-2 mt-2\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"Next.js\"}],[\"$\",\"span\",\"1\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"React\"}],[\"$\",\"span\",\"2\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"TypeScript\"}],[\"$\",\"span\",\"3\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"状態管理\"}],[\"$\",\"span\",\"4\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"ページネーション\"}],[\"$\",\"span\",\"5\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"SSG\"}],[\"$\",\"span\",\"6\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"Web開発\"}]]}]]}],[\"$\",\"nav\",null,{\"className\":\"mb-6 pb-4 border-b border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}],[\"$\",\"article\",null,{\"className\":\"prose dark:prose-invert\",\"dangerouslySetInnerHTML\":{\"__html\":\"$13\"}}],[\"$\",\"nav\",null,{\"className\":\"mt-8 pt-4 border-t border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}],[\"$\",\"$L14\",null,{}]]}]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"11:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Maita Tomoya Dev IO\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"米田智哉の技術ブログ。キャッチアップしたことをメモします。\"}]],\"error\":null,\"digest\":\"$undefined\"}\nb:{\"metadata\":\"$11:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>