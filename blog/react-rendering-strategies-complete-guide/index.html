<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/19bdf9af4d1ae4d4.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-aa7deb192a774533.js"/><script src="/_next/static/chunks/4bd1b696-bc089769d60af88b.js" async=""></script><script src="/_next/static/chunks/1684-b369840b16e4c44b.js" async=""></script><script src="/_next/static/chunks/main-app-2ed07751e45c2a2f.js" async=""></script><script src="/_next/static/chunks/6874-6c1ddde525f3893c.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js" async=""></script><meta name="next-size-adjust" content=""/><link rel="icon" href="/favicon.png" type="image/png"/><title>Maita Tomoya Dev IO</title><meta name="description" content="米田智哉の技術ブログ。キャッチアップしたことをメモします。"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 antialiased"><div class="max-w-2xl mx-auto py-10 px-4"><h1 class="text-3xl font-bold mb-2"><span class="text-green-600">#<!-- -->40</span> <!-- -->React レンダリング戦略完全ガイド - CSR/SSR/SSG/ISRを本質から理解する</h1><ul class="list-none border-b border-gray-600 pb-4 mb-6"><li class="text-gray-500 text-sm">作成日時: <!-- -->2025-08-25 00:45</li><li class="text-gray-500 text-sm">更新日時: <!-- -->2025-08-25 00:54</li><li class="flex flex-wrap gap-2 mt-2"><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">React</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">Next.js</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">CSR</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">SSR</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">SSG</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">ISR</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">レンダリング</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">パフォーマンス</span><span class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs">SEO</span></li></ul><nav class="mb-6 pb-4 border-b border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav><article class="prose dark:prose-invert"><p>React開発において「CSRとSSRの違いを説明してください」という質問は、面接で必ず聞かれる定番の質問です。しかし、単に「クライアントサイドレンダリング」「サーバーサイドレンダリング」と答えるだけでは、3年以上の経験を持つエンジニアとしては不十分です。本記事では、各レンダリング戦略の本質的な理解から、実装の詳細、パフォーマンス最適化まで、実務で必要な知識を網羅的に解説します。</p>
<h2 id="-初心者向け解説">💡 初心者向け解説</h2>
<h3 id="レンダリングとは">レンダリングとは？</h3>
<p><strong>簡単に言うと</strong>: ブラウザに表示されるHTMLを生成するプロセスです。</p>
<pre><code>例：レストランの料理提供
CSR：お客様のテーブルで調理（ブラウザで生成）
SSR：厨房で調理して配膳（サーバーで生成）
SSG：作り置き料理（事前に生成）
ISR：人気メニューは作り置き、注文があれば新しく作る（ハイブリッド）
</code></pre>
<h2 id="-目次">📚 目次</h2>
<ul>
<li><a href="#%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E6%88%A6%E7%95%A5%E3%81%AE%E5%9F%BA%E7%A4%8E">レンダリング戦略の基礎</a></li>
<li><a href="#csrclient-side-rendering%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A">CSR（Client-Side Rendering）の深掘り</a></li>
<li><a href="#ssrserver-side-rendering%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A">SSR（Server-Side Rendering）の深掘り</a></li>
<li><a href="#ssgstatic-site-generation%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A">SSG（Static Site Generation）の深掘り</a></li>
<li><a href="#isrincremental-static-regeneration%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A">ISR（Incremental Static Regeneration）の深掘り</a></li>
<li><a href="#%E5%AE%9F%E8%A3%85%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E6%9C%80%E9%81%A9%E5%8C%96%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF">実装パターンと最適化テクニック</a></li>
<li><a href="#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%B8%AC%E5%AE%9A%E3%81%A8%E6%94%B9%E5%96%84">パフォーマンス測定と改善</a></li>
<li><a href="#%E5%AE%9F%E8%B7%B5%E7%9A%84%E3%81%AA%E9%81%B8%E6%8A%9E%E5%9F%BA%E6%BA%96">実践的な選択基準</a></li>
<li><a href="#%E9%AB%98%E5%BA%A6%E3%81%AA%E3%83%88%E3%83%94%E3%83%83%E3%82%AF">高度なトピック</a></li>
</ul>
<h2 id="レンダリング戦略の基礎">レンダリング戦略の基礎</h2>
<h3 id="各戦略の概要と特徴">各戦略の概要と特徴</h3>


















































<table><thead><tr><th>戦略</th><th>HTML生成場所</th><th>データ取得タイミング</th><th>SEO</th><th>初期表示速度</th><th>インタラクティブ性</th><th>適用場面</th></tr></thead><tbody><tr><td><strong>CSR</strong></td><td>ブラウザ</td><td>ランタイム</td><td>△</td><td>遅い</td><td>高い</td><td>管理画面、SPA</td></tr><tr><td><strong>SSR</strong></td><td>サーバー</td><td>リクエスト時</td><td>◎</td><td>中間</td><td>中間</td><td>ECサイト、ニュース</td></tr><tr><td><strong>SSG</strong></td><td>ビルド時</td><td>ビルド時</td><td>◎</td><td>速い</td><td>中間</td><td>ブログ、LP</td></tr><tr><td><strong>ISR</strong></td><td>ビルド時+α</td><td>ビルド時+再検証時</td><td>◎</td><td>速い</td><td>中間</td><td>大規模ECサイト</td></tr></tbody></table>
<h3 id="webパフォーマンスメトリクス">Webパフォーマンスメトリクス</h3>
<p>理解すべき重要な指標：</p>
<pre><code class="language-typescript">// Core Web Vitals
interface WebVitals {
  LCP: number;  // Largest Contentful Paint（最大コンテンツの描画）
  FID: number;  // First Input Delay（初回入力遅延） ※INPに置き換わりつつある
  CLS: number;  // Cumulative Layout Shift（累積レイアウトシフト）
  FCP: number;  // First Contentful Paint（初回コンテンツ描画）
  TTFB: number; // Time to First Byte（最初のバイトまでの時間）
  TTI: number;  // Time to Interactive（インタラクティブになるまでの時間）
  INP: number;  // Interaction to Next Paint（2024年3月からFIDに代わる新指標）
}
</code></pre>
<h2 id="csrclient-side-renderingの深掘り">CSR（Client-Side Rendering）の深掘り</h2>
<h3 id="csrの仕組み">CSRの仕組み</h3>
<div class="mermaid">sequenceDiagram
    participant User
    participant Browser
    participant Server
    participant API
    
    User-&gt;&gt;Browser: URLアクセス
    Browser-&gt;&gt;Server: HTMLリクエスト
    Server--&gt;&gt;Browser: 空のHTML + JSバンドル
    Browser-&gt;&gt;Browser: JSダウンロード・パース
    Browser-&gt;&gt;Browser: React App初期化
    Browser-&gt;&gt;API: データフェッチ
    API--&gt;&gt;Browser: JSONデータ
    Browser-&gt;&gt;Browser: Virtual DOM生成
    Browser-&gt;&gt;Browser: DOM更新
    Browser--&gt;&gt;User: 画面表示</div>
<h3 id="csrの実装例">CSRの実装例</h3>
<pre><code class="language-tsx">// pages/products.tsx (CSR実装)
import { useState, useEffect } from 'react';
import { Product } from '@/types';

export default function ProductsPage() {
  const [products, setProducts] = useState&#x3C;Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&#x3C;string | null>(null);

  useEffect(() => {
    fetchProducts();
  }, []);

  const fetchProducts = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/products');
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      setProducts(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'エラーが発生しました');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      &#x3C;div className="skeleton-container">
        {/* スケルトンスクリーン実装 */}
        {[...Array(6)].map((_, i) => (
          &#x3C;div key={i} className="skeleton-card">
            &#x3C;div className="skeleton-image" />
            &#x3C;div className="skeleton-text" />
            &#x3C;div className="skeleton-text short" />
          &#x3C;/div>
        ))}
      &#x3C;/div>
    );
  }

  if (error) {
    return (
      &#x3C;div className="error-container">
        &#x3C;h2>エラーが発生しました&#x3C;/h2>
        &#x3C;p>{error}&#x3C;/p>
        &#x3C;button onClick={fetchProducts}>再試行&#x3C;/button>
      &#x3C;/div>
    );
  }

  return (
    &#x3C;div className="products-grid">
      {products.map((product) => (
        &#x3C;ProductCard key={product.id} product={product} />
      ))}
    &#x3C;/div>
  );
}
</code></pre>
<h3 id="csrの最適化テクニック">CSRの最適化テクニック</h3>
<h4 id="1-code-splittingコード分割">1. Code Splitting（コード分割）</h4>
<pre><code class="language-tsx">// 動的インポートによるコード分割
import dynamic from 'next/dynamic';
import { Suspense } from 'react';

// 重いコンポーネントを遅延ロード
const HeavyChart = dynamic(
  () => import('@/components/HeavyChart'),
  {
    loading: () => &#x3C;div>グラフを読み込み中...&#x3C;/div>,
    ssr: false // CSRのみで動作
  }
);

export default function Dashboard() {
  return (
    &#x3C;div>
      &#x3C;h1>ダッシュボード&#x3C;/h1>
      &#x3C;Suspense fallback={&#x3C;div>Loading...&#x3C;/div>}>
        &#x3C;HeavyChart />
      &#x3C;/Suspense>
    &#x3C;/div>
  );
}
</code></pre>
<h4 id="2-データフェッチの最適化">2. データフェッチの最適化</h4>
<pre><code class="language-tsx">// React Query (TanStack Query)を使用した高度なデータ管理
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

interface Product {
  id: string;
  name: string;
  price: number;
}

// カスタムフックでデータフェッチロジックを抽象化
export function useProducts(options?: { 
  enabled?: boolean; 
  staleTime?: number; 
}) {
  return useQuery&#x3C;Product[]>({
    queryKey: ['products'],
    queryFn: async () => {
      const response = await fetch('/api/products');
      if (!response.ok) throw new Error('Network response was not ok');
      return response.json();
    },
    staleTime: options?.staleTime ?? 5 * 60 * 1000, // 5分間キャッシュ
    enabled: options?.enabled ?? true,
    retry: 3, // 3回までリトライ
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

// Optimistic Update実装
export function useUpdateProduct() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (product: Product) => {
      const response = await fetch(`/api/products/${product.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(product),
      });
      if (!response.ok) throw new Error('Update failed');
      return response.json();
    },
    onMutate: async (newProduct) => {
      // 楽観的更新
      await queryClient.cancelQueries({ queryKey: ['products'] });
      const previousProducts = queryClient.getQueryData(['products']);
      
      queryClient.setQueryData(['products'], (old: Product[]) => 
        old.map(p => p.id === newProduct.id ? newProduct : p)
      );
      
      return { previousProducts };
    },
    onError: (err, newProduct, context) => {
      // エラー時はロールバック
      queryClient.setQueryData(['products'], context?.previousProducts);
    },
    onSettled: () => {
      // 最終的にサーバーと同期
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
  });
}
</code></pre>
<h3 id="csrのメリットデメリット">CSRのメリット・デメリット</h3>
<p><strong>メリット</strong>:</p>
<ul>
<li>🚀 高いインタラクティブ性</li>
<li>💾 サーバー負荷が低い</li>
<li>📱 SPAとして動作可能</li>
<li>🔄 リアルタイム更新が容易</li>
</ul>
<p><strong>デメリット</strong>:</p>
<ul>
<li>🐌 初期表示が遅い</li>
<li>🔍 SEOに不利</li>
<li>📦 大きなJSバンドルサイズ</li>
<li>📱 低スペックデバイスで性能問題</li>
</ul>
<h2 id="ssrserver-side-renderingの深掘り">SSR（Server-Side Rendering）の深掘り</h2>
<h3 id="ssrの仕組み">SSRの仕組み</h3>
<div class="mermaid">sequenceDiagram
    participant User
    participant Browser
    participant Server
    participant API
    
    User-&gt;&gt;Browser: URLアクセス
    Browser-&gt;&gt;Server: ページリクエスト
    Server-&gt;&gt;API: データフェッチ
    API--&gt;&gt;Server: データ
    Server-&gt;&gt;Server: React コンポーネントをレンダリング
    Server-&gt;&gt;Server: HTMLを生成
    Server--&gt;&gt;Browser: 完全なHTML + JSバンドル
    Browser-&gt;&gt;Browser: HTMLパース・表示
    Browser-&gt;&gt;Browser: JSダウンロード・実行（Hydration）
    Browser--&gt;&gt;User: インタラクティブな画面</div>
<h3 id="ssrの実装例nextjs-app-router">SSRの実装例（Next.js App Router）</h3>
<pre><code class="language-tsx">// app/products/page.tsx (SSR with App Router)
import { Suspense } from 'react';
import { headers } from 'next/headers';

// データフェッチング関数
async function getProducts() {
  const host = headers().get('host');
  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';
  
  const res = await fetch(`${protocol}://${host}/api/products`, {
    cache: 'no-store', // SSRを強制
    headers: {
      'Content-Type': 'application/json',
    },
  });

  if (!res.ok) {
    throw new Error('Failed to fetch products');
  }

  return res.json();
}

// Server Component
export default async function ProductsPage() {
  const products = await getProducts();

  return (
    &#x3C;div className="container mx-auto px-4">
      &#x3C;h1 className="text-3xl font-bold mb-8">商品一覧&#x3C;/h1>
      
      &#x3C;Suspense fallback={&#x3C;ProductsSkeleton />}>
        &#x3C;ProductGrid products={products} />
      &#x3C;/Suspense>
    &#x3C;/div>
  );
}

// Client Component for interactivity
'use client';

import { useState } from 'react';

function ProductGrid({ products }: { products: Product[] }) {
  const [filter, setFilter] = useState('all');
  
  const filteredProducts = products.filter(product => {
    if (filter === 'all') return true;
    return product.category === filter;
  });

  return (
    &#x3C;>
      &#x3C;FilterBar onFilterChange={setFilter} />
      &#x3C;div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {filteredProducts.map((product) => (
          &#x3C;ProductCard key={product.id} product={product} />
        ))}
      &#x3C;/div>
    &#x3C;/>
  );
}
</code></pre>
<h3 id="streaming-ssrストリーミングssr">Streaming SSR（ストリーミングSSR）</h3>
<pre><code class="language-tsx">// app/dashboard/page.tsx
import { Suspense } from 'react';

// 遅いデータフェッチ
async function getAnalytics() {
  const res = await fetch('/api/analytics', {
    cache: 'no-store'
  });
  // 意図的に遅延を追加（実際のAPIが遅い場合を想定）
  await new Promise(resolve => setTimeout(resolve, 3000));
  return res.json();
}

// 速いデータフェッチ
async function getQuickStats() {
  const res = await fetch('/api/quick-stats', {
    cache: 'no-store'
  });
  return res.json();
}

// メインコンポーネント
export default async function Dashboard() {
  const quickStats = await getQuickStats();

  return (
    &#x3C;div className="dashboard">
      &#x3C;h1>ダッシュボード&#x3C;/h1>
      
      {/* すぐに表示される部分 */}
      &#x3C;QuickStats data={quickStats} />
      
      {/* ストリーミングで後から表示される部分 */}
      &#x3C;Suspense fallback={&#x3C;AnalyticsSkeleton />}>
        &#x3C;AnalyticsSection />
      &#x3C;/Suspense>
    &#x3C;/div>
  );
}

// 遅延ロードされるコンポーネント
async function AnalyticsSection() {
  const analytics = await getAnalytics();
  return &#x3C;Analytics data={analytics} />;
}
</code></pre>
<h3 id="ssrのエッジケース処理">SSRのエッジケース処理</h3>
<pre><code class="language-tsx">// SSRでの条件付きレンダリング
'use client';

import { useEffect, useState } from 'react';

export function ClientOnlyComponent() {
  const [isClient, setIsClient] = useState(false);
  
  useEffect(() => {
    setIsClient(true);
  }, []);

  // サーバーサイドでは何も表示しない
  if (!isClient) {
    return null;
  }

  // クライアントサイドのみで動作するコード
  return (
    &#x3C;div>
      &#x3C;p>ブラウザの幅: {window.innerWidth}px&#x3C;/p>
      &#x3C;p>現在のURL: {window.location.href}&#x3C;/p>
    &#x3C;/div>
  );
}
</code></pre>
<h2 id="ssgstatic-site-generationの深掘り">SSG（Static Site Generation）の深掘り</h2>
<h3 id="ssgの仕組み">SSGの仕組み</h3>
<div class="mermaid">sequenceDiagram
    participant Developer
    participant BuildProcess
    participant API
    participant CDN
    participant User
    participant Browser
    
    Developer-&gt;&gt;BuildProcess: ビルド実行
    BuildProcess-&gt;&gt;API: データフェッチ
    API--&gt;&gt;BuildProcess: データ
    BuildProcess-&gt;&gt;BuildProcess: HTMLファイル生成
    BuildProcess-&gt;&gt;CDN: 静的ファイルをデプロイ
    User-&gt;&gt;Browser: URLアクセス
    Browser-&gt;&gt;CDN: HTMLリクエスト
    CDN--&gt;&gt;Browser: キャッシュされたHTML
    Browser--&gt;&gt;User: 即座に表示</div>
<h3 id="ssgの実装例">SSGの実装例</h3>
<pre><code class="language-tsx">// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';
import { getBlogPost, getAllBlogSlugs } from '@/lib/blog';
import { MDXRemote } from 'next-mdx-remote/rsc';

// 動的ルートパラメータの型定義
interface PageProps {
  params: {
    slug: string;
  };
}

// ビルド時に生成するパスを定義
export async function generateStaticParams() {
  const slugs = await getAllBlogSlugs();
  
  return slugs.map((slug) => ({
    slug: slug,
  }));
}

// メタデータの生成
export async function generateMetadata({ params }: PageProps) {
  const post = await getBlogPost(params.slug);
  
  if (!post) {
    return {};
  }

  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.ogImage],
      type: 'article',
      publishedTime: post.publishedAt,
      authors: [post.author],
    },
    twitter: {
      card: 'summary_large_image',
      title: post.title,
      description: post.excerpt,
      images: [post.ogImage],
    },
  };
}

// ページコンポーネント
export default async function BlogPostPage({ params }: PageProps) {
  const post = await getBlogPost(params.slug);
  
  if (!post) {
    notFound();
  }

  return (
    &#x3C;article className="prose prose-lg mx-auto">
      &#x3C;header>
        &#x3C;h1>{post.title}&#x3C;/h1>
        &#x3C;div className="meta">
          &#x3C;time dateTime={post.publishedAt}>
            {new Date(post.publishedAt).toLocaleDateString('ja-JP')}
          &#x3C;/time>
          &#x3C;span className="author">by {post.author}&#x3C;/span>
        &#x3C;/div>
      &#x3C;/header>
      
      &#x3C;MDXRemote source={post.content} />
      
      &#x3C;footer>
        &#x3C;RelatedPosts currentSlug={params.slug} />
      &#x3C;/footer>
    &#x3C;/article>
  );
}
</code></pre>
<h3 id="ssgの最適化">SSGの最適化</h3>
<pre><code class="language-tsx">// lib/blog.ts - 効率的なデータフェッチング
import { cache } from 'react';
import { unstable_cache } from 'next/cache';

// React cacheでリクエスト中のメモ化
export const getBlogPost = cache(async (slug: string) => {
  const post = await db.post.findUnique({
    where: { slug },
    include: {
      author: true,
      tags: true,
    },
  });
  
  return post;
});

// Next.js cacheでビルド間のキャッシュ
export const getPopularPosts = unstable_cache(
  async () => {
    const posts = await db.post.findMany({
      where: { published: true },
      orderBy: { views: 'desc' },
      take: 10,
      select: {
        id: true,
        title: true,
        slug: true,
        excerpt: true,
        views: true,
      },
    });
    
    return posts;
  },
  ['popular-posts'],
  {
    revalidate: 3600, // 1時間キャッシュ
    tags: ['posts'],
  }
);
</code></pre>
<h2 id="isrincremental-static-regenerationの深掘り">ISR（Incremental Static Regeneration）の深掘り</h2>
<h3 id="isrの仕組み">ISRの仕組み</h3>
<div class="mermaid">sequenceDiagram
    participant User1
    participant User2
    participant CDN
    participant Server
    participant API
    
    Note over CDN: 初回リクエスト
    User1-&gt;&gt;CDN: ページリクエスト
    CDN-&gt;&gt;Server: キャッシュミス
    Server-&gt;&gt;API: データフェッチ
    API--&gt;&gt;Server: データ
    Server-&gt;&gt;Server: HTML生成
    Server--&gt;&gt;CDN: HTML（キャッシュ）
    CDN--&gt;&gt;User1: HTML配信
    
    Note over CDN: 再検証前
    User2-&gt;&gt;CDN: ページリクエスト
    CDN--&gt;&gt;User2: キャッシュされたHTML（高速）
    
    Note over CDN: 再検証期間経過後
    User1-&gt;&gt;CDN: ページリクエスト
    CDN--&gt;&gt;User1: 古いHTML（即座に返す）
    CDN-&gt;&gt;Server: バックグラウンドで再生成
    Server-&gt;&gt;API: 最新データフェッチ
    API--&gt;&gt;Server: データ
    Server-&gt;&gt;Server: HTML再生成
    Server--&gt;&gt;CDN: 新しいHTML（キャッシュ更新）</div>
<h3 id="isrの実装例">ISRの実装例</h3>
<pre><code class="language-tsx">// app/products/[id]/page.tsx
import { Metadata } from 'next';

interface PageProps {
  params: { id: string };
}

// ISRの設定
export const revalidate = 60; // 60秒ごとに再検証

// または動的な再検証
export const dynamicParams = true; // 事前生成されていないパスを許可

export async function generateStaticParams() {
  // ビルド時に人気商品のみ事前生成
  const popularProducts = await fetch('https://api.example.com/products/popular')
    .then(res => res.json());
  
  return popularProducts.map((product: any) => ({
    id: product.id.toString(),
  }));
}

export async function generateMetadata({ params }: PageProps): Promise&#x3C;Metadata> {
  const product = await getProduct(params.id);
  
  return {
    title: product.name,
    description: product.description,
  };
}

async function getProduct(id: string) {
  const res = await fetch(`https://api.example.com/products/${id}`, {
    next: { revalidate: 60 } // フェッチレベルでの再検証
  });
  
  if (!res.ok) {
    throw new Error('Failed to fetch product');
  }
  
  return res.json();
}

export default async function ProductPage({ params }: PageProps) {
  const product = await getProduct(params.id);
  
  return (
    &#x3C;div className="product-detail">
      &#x3C;h1>{product.name}&#x3C;/h1>
      &#x3C;p className="price">¥{product.price.toLocaleString()}&#x3C;/p>
      &#x3C;div className="description">{product.description}&#x3C;/div>
      
      {/* Client Component for dynamic features */}
      &#x3C;ProductActions productId={product.id} />
    &#x3C;/div>
  );
}
</code></pre>
<h3 id="on-demand-isrオンデマンド再検証">On-Demand ISR（オンデマンド再検証）</h3>
<pre><code class="language-tsx">// app/api/revalidate/route.ts
import { revalidatePath, revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  const secret = request.nextUrl.searchParams.get('secret');
  const path = request.nextUrl.searchParams.get('path');
  const tag = request.nextUrl.searchParams.get('tag');

  // シークレットトークンの検証
  if (secret !== process.env.REVALIDATION_SECRET) {
    return NextResponse.json({ message: 'Invalid secret' }, { status: 401 });
  }

  try {
    if (path) {
      // 特定のパスを再検証
      revalidatePath(path);
      return NextResponse.json({ revalidated: true, path, now: Date.now() });
    }
    
    if (tag) {
      // タグベースの再検証
      revalidateTag(tag);
      return NextResponse.json({ revalidated: true, tag, now: Date.now() });
    }
    
    return NextResponse.json({ message: 'Missing path or tag' }, { status: 400 });
  } catch (err) {
    return NextResponse.json({ message: 'Error revalidating' }, { status: 500 });
  }
}

// Webhookからの呼び出し例（CMSの更新時など）
async function handleCMSUpdate(updatedContent: any) {
  await fetch('https://your-app.com/api/revalidate', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      secret: process.env.REVALIDATION_SECRET,
      path: `/blog/${updatedContent.slug}`,
    }),
  });
}
</code></pre>
<h2 id="実装パターンと最適化テクニック">実装パターンと最適化テクニック</h2>
<h3 id="ハイブリッドレンダリング">ハイブリッドレンダリング</h3>
<pre><code class="language-tsx">// app/dashboard/page.tsx - 複数の戦略を組み合わせる
import { Suspense } from 'react';
import { headers } from 'next/headers';

// 静的な部分（SSG）
export default function DashboardLayout() {
  return (
    &#x3C;div className="dashboard">
      &#x3C;StaticHeader />
      
      &#x3C;div className="dashboard-content">
        {/* 動的な部分（SSR） */}
        &#x3C;Suspense fallback={&#x3C;UserInfoSkeleton />}>
          &#x3C;UserInfo />
        &#x3C;/Suspense>
        
        {/* クライアントサイドの部分（CSR） */}
        &#x3C;RealtimeMetrics />
      &#x3C;/div>
      
      &#x3C;StaticFooter />
    &#x3C;/div>
  );
}

// SSR部分
async function UserInfo() {
  const session = await getServerSession();
  const user = await getUserData(session.userId);
  
  return (
    &#x3C;div className="user-info">
      &#x3C;h2>こんにちは、{user.name}さん&#x3C;/h2>
      &#x3C;p>最終ログイン: {user.lastLogin}&#x3C;/p>
    &#x3C;/div>
  );
}

// CSR部分
'use client';

import { useEffect, useState } from 'react';
import { io } from 'socket.io-client';

function RealtimeMetrics() {
  const [metrics, setMetrics] = useState(null);
  
  useEffect(() => {
    const socket = io('/metrics');
    
    socket.on('update', (data) => {
      setMetrics(data);
    });
    
    return () => socket.disconnect();
  }, []);
  
  if (!metrics) return &#x3C;div>メトリクスを読み込み中...&#x3C;/div>;
  
  return (
    &#x3C;div className="metrics">
      &#x3C;MetricCard title="オンラインユーザー" value={metrics.onlineUsers} />
      &#x3C;MetricCard title="今日の売上" value={metrics.todaySales} />
      &#x3C;MetricCard title="処理中の注文" value={metrics.pendingOrders} />
    &#x3C;/div>
  );
}
</code></pre>
<h3 id="progressive-enhancement段階的強化">Progressive Enhancement（段階的強化）</h3>
<pre><code class="language-tsx">// components/SearchForm.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useTransition } from 'react';

export function SearchForm() {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  
  // JavaScript無効時でも動作するフォーム
  return (
    &#x3C;form 
      action="/search" 
      method="GET"
      onSubmit={(e) => {
        e.preventDefault();
        const formData = new FormData(e.currentTarget);
        const query = formData.get('q');
        
        startTransition(() => {
          router.push(`/search?q=${encodeURIComponent(query)}`);
        });
      }}
    >
      &#x3C;input
        type="search"
        name="q"
        placeholder="検索..."
        required
        disabled={isPending}
      />
      &#x3C;button type="submit" disabled={isPending}>
        {isPending ? '検索中...' : '検索'}
      &#x3C;/button>
    &#x3C;/form>
  );
}
</code></pre>
<h3 id="データフェッチング最適化">データフェッチング最適化</h3>
<pre><code class="language-tsx">// lib/data-fetching.ts
import { unstable_cache } from 'next/cache';

// Parallel Data Fetching（並列データフェッチ）
export async function getPageData(slug: string) {
  const [post, relatedPosts, comments] = await Promise.all([
    getPost(slug),
    getRelatedPosts(slug),
    getComments(slug),
  ]);
  
  return { post, relatedPosts, comments };
}

// Request Deduplication（リクエスト重複排除）
const getPost = unstable_cache(
  async (slug: string) => {
    const response = await fetch(`/api/posts/${slug}`, {
      next: { 
        revalidate: 3600,
        tags: ['post', `post-${slug}`]
      }
    });
    return response.json();
  },
  ['post-by-slug'],
  {
    revalidate: 3600,
    tags: ['posts']
  }
);

// Waterfall Prevention（ウォーターフォール防止）
export async function ProductPage({ id }: { id: string }) {
  // ❌ 悪い例：順次実行（ウォーターフォール）
  // const product = await getProduct(id);
  // const reviews = await getReviews(id);
  // const recommendations = await getRecommendations(id);
  
  // ✅ 良い例：並列実行
  const dataPromise = Promise.all([
    getProduct(id),
    getReviews(id),
    getRecommendations(id),
  ]);
  
  const [product, reviews, recommendations] = await dataPromise;
  
  return (
    &#x3C;div>
      &#x3C;ProductInfo product={product} />
      &#x3C;Reviews reviews={reviews} />
      &#x3C;Recommendations items={recommendations} />
    &#x3C;/div>
  );
}
</code></pre>
<h2 id="パフォーマンス測定と改善">パフォーマンス測定と改善</h2>
<h3 id="core-web-vitalsの測定">Core Web Vitalsの測定</h3>
<pre><code class="language-tsx">// hooks/useWebVitals.ts
import { useEffect } from 'react';
import { onCLS, onFID, onLCP, onFCP, onTTFB } from 'web-vitals';

export function useWebVitals() {
  useEffect(() => {
    // Largest Contentful Paint
    onLCP((metric) => {
      console.log('LCP:', metric.value);
      // Google Analyticsに送信
      gtag('event', 'web_vitals', {
        event_category: 'Web Vitals',
        event_label: 'LCP',
        value: Math.round(metric.value),
        metric_id: metric.id,
        metric_value: metric.value,
        metric_delta: metric.delta,
      });
    });
    
    // First Input Delay
    onFID((metric) => {
      console.log('FID:', metric.value);
    });
    
    // Cumulative Layout Shift
    onCLS((metric) => {
      console.log('CLS:', metric.value);
    });
    
    // First Contentful Paint
    onFCP((metric) => {
      console.log('FCP:', metric.value);
    });
    
    // Time to First Byte
    onTTFB((metric) => {
      console.log('TTFB:', metric.value);
    });
  }, []);
}

// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    &#x3C;html>
      &#x3C;body>
        &#x3C;WebVitalsReporter />
        {children}
      &#x3C;/body>
    &#x3C;/html>
  );
}

function WebVitalsReporter() {
  useWebVitals();
  return null;
}
</code></pre>
<h3 id="バンドルサイズの最適化">バンドルサイズの最適化</h3>
<pre><code class="language-javascript">// next.config.js
module.exports = {
  // Bundle Analyzer設定
  webpack: (config, { isServer }) => {
    if (process.env.ANALYZE === 'true') {
      const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          reportFilename: isServer ? '../analyze/server.html' : './analyze/client.html',
        })
      );
    }
    return config;
  },
  
  // 画像最適化
  images: {
    domains: ['images.example.com'],
    formats: ['image/avif', 'image/webp'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
  
  // SWC minifier使用
  swcMinify: true,
  
  // 実験的機能
  experimental: {
    optimizeCss: true,
    legacyBrowsers: false,
  },
};
</code></pre>
<h3 id="画像最適化戦略">画像最適化戦略</h3>
<pre><code class="language-tsx">// components/OptimizedImage.tsx
import Image from 'next/image';
import { useState } from 'react';

interface OptimizedImageProps {
  src: string;
  alt: string;
  priority?: boolean;
  className?: string;
}

export function OptimizedImage({ 
  src, 
  alt, 
  priority = false,
  className 
}: OptimizedImageProps) {
  const [isLoading, setIsLoading] = useState(true);
  
  return (
    &#x3C;div className={`image-container ${className}`}>
      &#x3C;Image
        src={src}
        alt={alt}
        fill
        priority={priority}
        quality={85}
        sizes="(max-width: 640px) 100vw,
               (max-width: 1024px) 50vw,
               33vw"
        placeholder="blur"
        blurDataURL={`data:image/svg+xml;base64,...`} // 実際のblur画像
        onLoadingComplete={() => setIsLoading(false)}
        className={`
          duration-700 ease-in-out
          ${isLoading ? 'scale-110 blur-2xl grayscale' : 'scale-100 blur-0 grayscale-0'}
        `}
      />
    &#x3C;/div>
  );
}
</code></pre>
<h2 id="実践的な選択基準">実践的な選択基準</h2>
<h3 id="レンダリング戦略の選択フローチャート">レンダリング戦略の選択フローチャート</h3>
<div class="mermaid">flowchart TD
    Start[開始] --&gt; Q1{コンテンツは頻繁に更新される？}
    Q1 --&gt;|Yes| Q2{リアルタイム性が必要？}
    Q1 --&gt;|No| Q3{SEOは重要？}
    
    Q2 --&gt;|Yes| CSR[CSR推奨]
    Q2 --&gt;|No| Q4{更新頻度は？}
    
    Q3 --&gt;|Yes| SSG[SSG推奨]
    Q3 --&gt;|No| Q5{ユーザー固有のコンテンツ？}
    
    Q4 --&gt;|毎分〜毎時| SSR[SSR推奨]
    Q4 --&gt;|毎日〜毎週| ISR[ISR推奨]
    
    Q5 --&gt;|Yes| CSR
    Q5 --&gt;|No| SSG
    
    CSR --&gt; End[終了]
    SSR --&gt; End
    SSG --&gt; End
    ISR --&gt; End</div>
<h3 id="実際のユースケースマッピング">実際のユースケースマッピング</h3>


















































<table><thead><tr><th>ユースケース</th><th>推奨戦略</th><th>理由</th></tr></thead><tbody><tr><td><strong>企業サイトのトップページ</strong></td><td>SSG + ISR</td><td>SEO重要、更新頻度低、高速表示必要</td></tr><tr><td><strong>ブログ記事</strong></td><td>SSG</td><td>コンテンツ固定、SEO最重要</td></tr><tr><td><strong>ECサイトの商品ページ</strong></td><td>ISR</td><td>在庫・価格の定期更新、SEO重要</td></tr><tr><td><strong>管理画面</strong></td><td>CSR</td><td>SEO不要、高インタラクティブ性</td></tr><tr><td><strong>ニュースサイト</strong></td><td>SSR + ISR</td><td>最新性重要、SEO必要</td></tr><tr><td><strong>SNSフィード</strong></td><td>CSR + SSR</td><td>初期表示速度とリアルタイム更新の両立</td></tr><tr><td><strong>ユーザープロフィール</strong></td><td>SSR</td><td>動的コンテンツ、SEO一部必要</td></tr><tr><td><strong>ランディングページ</strong></td><td>SSG</td><td>高速表示、SEO最重要、更新少ない</td></tr></tbody></table>
<h2 id="高度なトピック">高度なトピック</h2>
<h3 id="react-19とnextjs-15の新機能2024-2025">React 19とNext.js 15の新機能（2024-2025）</h3>
<h4 id="react-19の主要アップデート">React 19の主要アップデート</h4>
<pre><code class="language-tsx">// 1. use() Hook - プロミスやコンテキストを直接使用
import { use } from 'react';

function Comments({ commentsPromise }) {
  // プロミスを直接使用（Suspenseと自動統合）
  const comments = use(commentsPromise);
  return &#x3C;div>{comments.map(c => &#x3C;p>{c.text}&#x3C;/p>)}&#x3C;/div>;
}

// 2. Server Components での async/await
async function ProductDetails({ id }) {
  const product = await fetch(`/api/products/${id}`).then(r => r.json());
  return &#x3C;div>{product.name}&#x3C;/div>;
}

// 3. Actions - フォーム処理の簡素化
function ContactForm() {
  async function submitAction(formData: FormData) {
    'use server';
    await saveContact(formData);
  }
  
  return (
    &#x3C;form action={submitAction}>
      &#x3C;input name="email" type="email" />
      &#x3C;button type="submit">送信&#x3C;/button>
    &#x3C;/form>
  );
}
</code></pre>
<h4 id="nextjs-15の新機能">Next.js 15の新機能</h4>
<pre><code class="language-tsx">// 1. Turbopack (デフォルト有効化)
// next.config.js
module.exports = {
  experimental: {
    turbo: true, // Webpack比で最大10倍高速
  },
};

// 2. 改善されたエラーハンドリング
export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error &#x26; { digest?: string };
  reset: () => void;
}) {
  return (
    &#x3C;div>
      &#x3C;h2>エラーが発生しました&#x3C;/h2>
      &#x3C;details>
        &#x3C;summary>詳細&#x3C;/summary>
        &#x3C;pre>{error.message}&#x3C;/pre>
      &#x3C;/details>
      &#x3C;button onClick={reset}>再試行&#x3C;/button>
    &#x3C;/div>
  );
}
</code></pre>
<h3 id="react-server-componentsrsc">React Server Components（RSC）</h3>
<pre><code class="language-tsx">// app/products/ProductList.tsx - Server Component
import { db } from '@/lib/db';

// Server Componentはasync関数として定義可能
export default async function ProductList({ category }: { category: string }) {
  // サーバーサイドで直接DBアクセス
  const products = await db.product.findMany({
    where: { category },
    include: { 
      reviews: {
        select: { rating: true }
      }
    }
  });
  
  // サーバーサイドで集計処理
  const productsWithRating = products.map(product => ({
    ...product,
    averageRating: product.reviews.reduce((acc, r) => acc + r.rating, 0) / product.reviews.length
  }));
  
  return (
    &#x3C;div className="product-list">
      {productsWithRating.map(product => (
        // Client Componentに必要最小限のデータを渡す
        &#x3C;ProductCard 
          key={product.id} 
          product={product}
          averageRating={product.averageRating}
        />
      ))}
    &#x3C;/div>
  );
}

// components/ProductCard.tsx - Client Component
'use client';

import { useState } from 'react';
import { addToCart } from '@/actions/cart';

export function ProductCard({ product, averageRating }) {
  const [isAdding, setIsAdding] = useState(false);
  
  const handleAddToCart = async () => {
    setIsAdding(true);
    await addToCart(product.id);
    setIsAdding(false);
  };
  
  return (
    &#x3C;div className="product-card">
      &#x3C;h3>{product.name}&#x3C;/h3>
      &#x3C;p>評価: {averageRating.toFixed(1)}&#x3C;/p>
      &#x3C;button onClick={handleAddToCart} disabled={isAdding}>
        {isAdding ? 'カートに追加中...' : 'カートに追加'}
      &#x3C;/button>
    &#x3C;/div>
  );
}
</code></pre>
<h3 id="edge-runtime最適化">Edge Runtime最適化</h3>
<pre><code class="language-tsx">// app/api/geo/route.ts - Edge Runtime使用
export const runtime = 'edge'; // Edge Runtimeを指定

export async function GET(request: Request) {
  // CloudflareやVercel Edge Functionsで実行
  const country = request.headers.get('CF-IPCountry') || 'JP';
  const city = request.headers.get('CF-City') || 'Tokyo';
  
  // 地域に基づいたコンテンツ配信
  const content = await getLocalizedContent(country, city);
  
  return new Response(JSON.stringify(content), {
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'public, max-age=3600',
      'CDN-Cache-Control': 'max-age=86400',
    },
  });
}

// middleware.ts - Edge Middlewareでルーティング
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const country = request.geo?.country || 'JP';
  
  // 地域別リダイレクト
  if (country === 'US' &#x26;&#x26; request.nextUrl.pathname === '/') {
    return NextResponse.redirect(new URL('/us', request.url));
  }
  
  // A/Bテスト
  const bucket = Math.random() &#x3C; 0.5 ? 'a' : 'b';
  const response = NextResponse.next();
  response.cookies.set('ab-test', bucket);
  
  return response;
}

export const config = {
  matcher: ['/((?!api|_next/static|favicon.ico).*)'],
};
</code></pre>
<h3 id="partial-prerendering部分的事前レンダリング">Partial Prerendering（部分的事前レンダリング）</h3>
<pre><code class="language-tsx">// app/dashboard/page.tsx - Partial Prerendering (実験的機能)
import { Suspense } from 'react';

export const experimental_ppr = true; // Partial Prerenderingを有効化

export default function Dashboard() {
  return (
    &#x3C;div>
      {/* 静的にプリレンダリングされる部分 */}
      &#x3C;header>
        &#x3C;h1>ダッシュボード&#x3C;/h1>
        &#x3C;Navigation />
      &#x3C;/header>
      
      {/* 動的な部分はSuspenseで囲む */}
      &#x3C;Suspense fallback={&#x3C;div>Loading user data...&#x3C;/div>}>
        &#x3C;UserDashboard />
      &#x3C;/Suspense>
      
      {/* 静的な部分 */}
      &#x3C;footer>
        &#x3C;Copyright />
      &#x3C;/footer>
    &#x3C;/div>
  );
}

async function UserDashboard() {
  const session = await getSession();
  const userData = await getUserData(session.userId);
  
  return &#x3C;DashboardContent data={userData} />;
}
</code></pre>
<h2 id="セキュリティ考慮事項">セキュリティ考慮事項</h2>
<h3 id="xss対策">XSS対策</h3>
<pre><code class="language-tsx">// ❌ 危険な実装
export function DangerousComponent({ htmlContent }: { htmlContent: string }) {
  return &#x3C;div dangerouslySetInnerHTML={{ __html: htmlContent }} />;
}

// ✅ 安全な実装
import DOMPurify from 'isomorphic-dompurify';

export function SafeComponent({ htmlContent }: { htmlContent: string }) {
  const cleanHTML = DOMPurify.sanitize(htmlContent, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href', 'target', 'rel'],
  });
  
  return &#x3C;div dangerouslySetInnerHTML={{ __html: cleanHTML }} />;
}

// Server Actionsでの検証
'use server';

import { z } from 'zod';

const formSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  message: z.string().min(10).max(1000),
});

export async function submitForm(formData: FormData) {
  const validatedFields = formSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    message: formData.get('message'),
  });
  
  if (!validatedFields.success) {
    return { error: validatedFields.error.flatten().fieldErrors };
  }
  
  // 安全に処理を続行
  await saveToDatabase(validatedFields.data);
}
</code></pre>
<h2 id="デバッグとトラブルシューティング">デバッグとトラブルシューティング</h2>
<h3 id="hydrationエラーの対処">Hydrationエラーの対処</h3>
<pre><code class="language-tsx">// ❌ Hydrationエラーが発生する例
function BadComponent() {
  return (
    &#x3C;div>
      現在時刻: {new Date().toLocaleTimeString()}
    &#x3C;/div>
  );
}

// ✅ Hydrationエラーを防ぐ実装
'use client';

import { useEffect, useState } from 'react';

function GoodComponent() {
  const [time, setTime] = useState&#x3C;string>('');
  
  useEffect(() => {
    setTime(new Date().toLocaleTimeString());
    const interval = setInterval(() => {
      setTime(new Date().toLocaleTimeString());
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  // サーバーサイドでは空文字列、クライアントサイドで時刻表示
  return (
    &#x3C;div>
      現在時刻: {time || 'Loading...'}
    &#x3C;/div>
  );
}
</code></pre>
<h2 id="まとめ">まとめ</h2>
<h3 id="重要なポイントのチェックリスト">重要なポイントのチェックリスト</h3>
<p><strong>基本理解</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> CSR/SSR/SSG/ISRの動作原理を説明できる</li>
<li class="task-list-item"><input type="checkbox" disabled> 各戦略のメリット・デメリットを理解している</li>
<li class="task-list-item"><input type="checkbox" disabled> Core Web Vitalsと各戦略の関係を説明できる</li>
</ul>
<p><strong>実装スキル</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> Next.js App Routerで各戦略を実装できる</li>
<li class="task-list-item"><input type="checkbox" disabled> データフェッチングの最適化ができる</li>
<li class="task-list-item"><input type="checkbox" disabled> Suspenseとストリーミングを活用できる</li>
<li class="task-list-item"><input type="checkbox" disabled> React Server Componentsを適切に使える</li>
</ul>
<p><strong>パフォーマンス</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> バンドルサイズの最適化ができる</li>
<li class="task-list-item"><input type="checkbox" disabled> 画像最適化の実装ができる</li>
<li class="task-list-item"><input type="checkbox" disabled> Core Web Vitalsの測定と改善ができる</li>
</ul>
<p><strong>応用力</strong>:</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> プロジェクトに適した戦略を選択できる</li>
<li class="task-list-item"><input type="checkbox" disabled> ハイブリッドレンダリングを設計できる</li>
<li class="task-list-item"><input type="checkbox" disabled> セキュリティを考慮した実装ができる</li>
</ul>
<h3 id="面接での回答例">面接での回答例</h3>
<p><strong>Q1: CSRとSSRの違いを説明してください</strong></p>
<pre><code>A: CSRとSSRの本質的な違いは、HTMLの生成場所とタイミングです。

CSRはブラウザ上でJavaScriptを実行してHTMLを生成します。
初期表示は遅いですが、その後のインタラクションは高速です。
SPAやダッシュボードなど、SEOが不要でインタラクティブ性が
重要な場面で使用します。

SSRはサーバー側でHTMLを生成してブラウザに送信します。
初期表示が速く、SEOに有利ですが、サーバー負荷が高くなります。
ECサイトやニュースサイトなど、SEOとコンテンツの鮮度が
重要な場面で使用します。

実際のプロジェクトでは、React Server ComponentsやSuspenseを
活用して、両者の利点を組み合わせたハイブリッドな実装を
行うことが多いです。
</code></pre>
<p><strong>Q2: Hydrationとは何ですか？エラーが起きる原因は？</strong></p>
<pre><code>A: Hydrationは、SSRで生成された静的HTMLに、クライアントサイドで
JavaScriptのイベントハンドラーや状態管理を「注入」するプロセスです。

エラーが起きる主な原因：
1. サーバーとクライアントで異なるHTMLが生成される
   - Math.random()や Date.now()の使用
   - window/documentオブジェクトの参照
2. 条件付きレンダリングの不整合
3. 外部ライブラリの不適切な使用

対策として、useEffectでクライアントサイドのみの処理を分離したり、
dynamic importでSSRを無効化したりします。
</code></pre>
<p><strong>Q3: ISRとSSGの違いは？どう使い分ける？</strong></p>
<pre><code>A: SSGはビルド時に全ページを生成し、ISRは必要に応じて
ページを再生成できる点が違います。

SSG：
- ビルド時に全ページ生成
- 更新にはリビルドが必要
- 小規模サイト、更新頻度が低いコンテンツ向け

ISR：
- オンデマンドまたは定期的に再生成
- revalidateで更新間隔を制御
- 大規模ECサイト、ニュースサイト向け

例：ブログは記事数が少なければSSG、
数千記事以上ならISRを選択します。
</code></pre>
<p><strong>Q4: React Server Componentsの利点は？</strong></p>
<pre><code>A: RSCの主な利点は3つあります：

1. バンドルサイズの削減
   - サーバー専用の依存関係はクライアントに送られない
   - 大きなライブラリ（MDX、構文ハイライト等）をサーバーに隔離

2. データフェッチの簡素化
   - async/awaitで直接データベースアクセス可能
   - ウォーターフォール問題の解消

3. セキュリティの向上
   - APIキーやDBアクセスをサーバーに隔離
   - 機密データの露出リスク低減

注意点として、Client ComponentsとのデータやPropsの
受け渡しには制約があります。
</code></pre>
<h3 id="他のフレームワークとの比較">他のフレームワークとの比較</h3>
<h4 id="nextjs-vs-remix-vs-astro">Next.js vs Remix vs Astro</h4>















































<table><thead><tr><th>特徴</th><th>Next.js</th><th>Remix</th><th>Astro</th></tr></thead><tbody><tr><td><strong>主な強み</strong></td><td>柔軟性、大規模エコシステム</td><td>データローディング、プログレッシブエンハンスメント</td><td>ゼロJSデフォルト、高速性</td></tr><tr><td><strong>デフォルト戦略</strong></td><td>SSG/ISR</td><td>SSR</td><td>SSG</td></tr><tr><td><strong>学習曲線</strong></td><td>中程度</td><td>やや高い</td><td>低い</td></tr><tr><td><strong>適用場面</strong></td><td>汎用的、大規模アプリ</td><td>動的コンテンツ中心</td><td>コンテンツサイト</td></tr><tr><td><strong>React Server Components</strong></td><td>✅ フル対応</td><td>❌ 未対応</td><td>⚠️ 部分対応</td></tr><tr><td><strong>エッジランタイム</strong></td><td>✅ 対応</td><td>✅ 対応</td><td>✅ 対応</td></tr></tbody></table>
<pre><code class="language-tsx">// Remixのデータローディング例
export async function loader({ params }) {
  const product = await getProduct(params.id);
  return json({ product });
}

export default function Product() {
  const { product } = useLoaderData();
  return &#x3C;div>{product.name}&#x3C;/div>;
}

// Astroのアイランドアーキテクチャ例
---
// .astro ファイル
import ReactComponent from './ReactComponent.jsx';
const data = await fetch('/api/data').then(r => r.json());
---
&#x3C;html>
  &#x3C;body>
    &#x3C;!-- 静的HTML -->
    &#x3C;h1>{data.title}&#x3C;/h1>
    &#x3C;!-- インタラクティブな部分のみReact -->
    &#x3C;ReactComponent client:load data={data} />
  &#x3C;/body>
&#x3C;/html>
</code></pre>
<h3 id="継続的な学習のために">継続的な学習のために</h3>
<ol>
<li><strong>実践プロジェクト</strong>: 各戦略を使った小規模アプリを作成</li>
<li><strong>パフォーマンス測定</strong>: Lighthouse、WebPageTestでの定期的な測定</li>
<li><strong>最新動向</strong>: Next.js、React公式ドキュメントのチェック</li>
<li><strong>コミュニティ</strong>: React/Next.jsコミュニティへの参加</li>
<li><strong>他フレームワークの学習</strong>: Remix、Astro、SvelteKitなども触ってみる</li>
</ol>
<h2 id="参考リンク">参考リンク</h2>
<ul>
<li><a href="https://nextjs.org/docs">Next.js Documentation</a></li>
<li><a href="https://react.dev/reference/react/use-server">React Server Components</a></li>
<li><a href="https://web.dev/vitals/">Web Vitals</a></li>
<li><a href="https://nextjs.org/docs/app">Next.js App Router</a></li>
<li><a href="https://vercel.com/docs/functions/edge-functions">Vercel Edge Functions</a></li>
</ul>
<hr>
<p><em>この記事は、React開発における実践的なレンダリング戦略の選択と実装に基づいて作成されました。</em></p></article><nav class="mt-8 pt-4 border-t border-gray-700 flex justify-between"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">← ホームへ</a><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/blog/">記事一覧へ →</a></nav></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-aa7deb192a774533.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[87555,[],\"\"]\n3:I[31295,[],\"\"]\n5:I[59665,[],\"MetadataBoundary\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[26614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/19bdf9af4d1ae4d4.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"XAGetg_fUqPEAt2Yh_57s\",\"p\":\"\",\"c\":[\"\",\"blog\",\"react-rendering-strategies-complete-guide\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"react-rendering-strategies-complete-guide\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/19bdf9af4d1ae4d4.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png\",\"type\":\"image/png\"}]}],[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"react-rendering-strategies-complete-guide\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[\"$\",\"$L5\",null,{\"children\":\"$L6\"}],null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"6A7i_zOGsJoLC7Mj09skC\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:\"$Sreact.suspense\"\n10:I[74911,[],\"AsyncMetadata\"]\n6:[\"$\",\"$f\",null,{\"fallback\":null,\"children\":[\"$\",\"$L10\",null,{\"promise\":\"$@11\"}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"12:I[6874,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"\"]\n14:I[31203,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"default\"]\n15:I[4197,[\"6874\",\"static/chunks/6874-6c1ddde525f3893c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js\"],\"default\"]\n13:Tc57d,"])</script><script>self.__next_f.push([1,"\u003cp\u003eReact開発において「CSRとSSRの違いを説明してください」という質問は、面接で必ず聞かれる定番の質問です。しかし、単に「クライアントサイドレンダリング」「サーバーサイドレンダリング」と答えるだけでは、3年以上の経験を持つエンジニアとしては不十分です。本記事では、各レンダリング戦略の本質的な理解から、実装の詳細、パフォーマンス最適化まで、実務で必要な知識を網羅的に解説します。\u003c/p\u003e\n\u003ch2 id=\"-初心者向け解説\"\u003e💡 初心者向け解説\u003c/h2\u003e\n\u003ch3 id=\"レンダリングとは\"\u003eレンダリングとは？\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e簡単に言うと\u003c/strong\u003e: ブラウザに表示されるHTMLを生成するプロセスです。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e例：レストランの料理提供\nCSR：お客様のテーブルで調理（ブラウザで生成）\nSSR：厨房で調理して配膳（サーバーで生成）\nSSG：作り置き料理（事前に生成）\nISR：人気メニューは作り置き、注文があれば新しく作る（ハイブリッド）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"-目次\"\u003e📚 目次\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E6%88%A6%E7%95%A5%E3%81%AE%E5%9F%BA%E7%A4%8E\"\u003eレンダリング戦略の基礎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#csrclient-side-rendering%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A\"\u003eCSR（Client-Side Rendering）の深掘り\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ssrserver-side-rendering%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A\"\u003eSSR（Server-Side Rendering）の深掘り\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ssgstatic-site-generation%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A\"\u003eSSG（Static Site Generation）の深掘り\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#isrincremental-static-regeneration%E3%81%AE%E6%B7%B1%E6%8E%98%E3%82%8A\"\u003eISR（Incremental Static Regeneration）の深掘り\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%AE%9F%E8%A3%85%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E6%9C%80%E9%81%A9%E5%8C%96%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF\"\u003e実装パターンと最適化テクニック\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%B8%AC%E5%AE%9A%E3%81%A8%E6%94%B9%E5%96%84\"\u003eパフォーマンス測定と改善\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%AE%9F%E8%B7%B5%E7%9A%84%E3%81%AA%E9%81%B8%E6%8A%9E%E5%9F%BA%E6%BA%96\"\u003e実践的な選択基準\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E9%AB%98%E5%BA%A6%E3%81%AA%E3%83%88%E3%83%94%E3%83%83%E3%82%AF\"\u003e高度なトピック\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"レンダリング戦略の基礎\"\u003eレンダリング戦略の基礎\u003c/h2\u003e\n\u003ch3 id=\"各戦略の概要と特徴\"\u003e各戦略の概要と特徴\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e戦略\u003c/th\u003e\u003cth\u003eHTML生成場所\u003c/th\u003e\u003cth\u003eデータ取得タイミング\u003c/th\u003e\u003cth\u003eSEO\u003c/th\u003e\u003cth\u003e初期表示速度\u003c/th\u003e\u003cth\u003eインタラクティブ性\u003c/th\u003e\u003cth\u003e適用場面\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eCSR\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eブラウザ\u003c/td\u003e\u003ctd\u003eランタイム\u003c/td\u003e\u003ctd\u003e△\u003c/td\u003e\u003ctd\u003e遅い\u003c/td\u003e\u003ctd\u003e高い\u003c/td\u003e\u003ctd\u003e管理画面、SPA\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eSSR\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eサーバー\u003c/td\u003e\u003ctd\u003eリクエスト時\u003c/td\u003e\u003ctd\u003e◎\u003c/td\u003e\u003ctd\u003e中間\u003c/td\u003e\u003ctd\u003e中間\u003c/td\u003e\u003ctd\u003eECサイト、ニュース\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eSSG\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eビルド時\u003c/td\u003e\u003ctd\u003eビルド時\u003c/td\u003e\u003ctd\u003e◎\u003c/td\u003e\u003ctd\u003e速い\u003c/td\u003e\u003ctd\u003e中間\u003c/td\u003e\u003ctd\u003eブログ、LP\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eISR\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eビルド時+α\u003c/td\u003e\u003ctd\u003eビルド時+再検証時\u003c/td\u003e\u003ctd\u003e◎\u003c/td\u003e\u003ctd\u003e速い\u003c/td\u003e\u003ctd\u003e中間\u003c/td\u003e\u003ctd\u003e大規模ECサイト\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3 id=\"webパフォーマンスメトリクス\"\u003eWebパフォーマンスメトリクス\u003c/h3\u003e\n\u003cp\u003e理解すべき重要な指標：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// Core Web Vitals\ninterface WebVitals {\n  LCP: number;  // Largest Contentful Paint（最大コンテンツの描画）\n  FID: number;  // First Input Delay（初回入力遅延） ※INPに置き換わりつつある\n  CLS: number;  // Cumulative Layout Shift（累積レイアウトシフト）\n  FCP: number;  // First Contentful Paint（初回コンテンツ描画）\n  TTFB: number; // Time to First Byte（最初のバイトまでの時間）\n  TTI: number;  // Time to Interactive（インタラクティブになるまでの時間）\n  INP: number;  // Interaction to Next Paint（2024年3月からFIDに代わる新指標）\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"csrclient-side-renderingの深掘り\"\u003eCSR（Client-Side Rendering）の深掘り\u003c/h2\u003e\n\u003ch3 id=\"csrの仕組み\"\u003eCSRの仕組み\u003c/h3\u003e\n\u003cdiv class=\"mermaid\"\u003esequenceDiagram\n    participant User\n    participant Browser\n    participant Server\n    participant API\n    \n    User-\u0026gt;\u0026gt;Browser: URLアクセス\n    Browser-\u0026gt;\u0026gt;Server: HTMLリクエスト\n    Server--\u0026gt;\u0026gt;Browser: 空のHTML + JSバンドル\n    Browser-\u0026gt;\u0026gt;Browser: JSダウンロード・パース\n    Browser-\u0026gt;\u0026gt;Browser: React App初期化\n    Browser-\u0026gt;\u0026gt;API: データフェッチ\n    API--\u0026gt;\u0026gt;Browser: JSONデータ\n    Browser-\u0026gt;\u0026gt;Browser: Virtual DOM生成\n    Browser-\u0026gt;\u0026gt;Browser: DOM更新\n    Browser--\u0026gt;\u0026gt;User: 画面表示\u003c/div\u003e\n\u003ch3 id=\"csrの実装例\"\u003eCSRの実装例\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// pages/products.tsx (CSR実装)\nimport { useState, useEffect } from 'react';\nimport { Product } from '@/types';\n\nexport default function ProductsPage() {\n  const [products, setProducts] = useState\u0026#x3C;Product[]\u003e([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState\u0026#x3C;string | null\u003e(null);\n\n  useEffect(() =\u003e {\n    fetchProducts();\n  }, []);\n\n  const fetchProducts = async () =\u003e {\n    try {\n      setLoading(true);\n      const response = await fetch('/api/products');\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      setProducts(data);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'エラーが発生しました');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (loading) {\n    return (\n      \u0026#x3C;div className=\"skeleton-container\"\u003e\n        {/* スケルトンスクリーン実装 */}\n        {[...Array(6)].map((_, i) =\u003e (\n          \u0026#x3C;div key={i} className=\"skeleton-card\"\u003e\n            \u0026#x3C;div className=\"skeleton-image\" /\u003e\n            \u0026#x3C;div className=\"skeleton-text\" /\u003e\n            \u0026#x3C;div className=\"skeleton-text short\" /\u003e\n          \u0026#x3C;/div\u003e\n        ))}\n      \u0026#x3C;/div\u003e\n    );\n  }\n\n  if (error) {\n    return (\n      \u0026#x3C;div className=\"error-container\"\u003e\n        \u0026#x3C;h2\u003eエラーが発生しました\u0026#x3C;/h2\u003e\n        \u0026#x3C;p\u003e{error}\u0026#x3C;/p\u003e\n        \u0026#x3C;button onClick={fetchProducts}\u003e再試行\u0026#x3C;/button\u003e\n      \u0026#x3C;/div\u003e\n    );\n  }\n\n  return (\n    \u0026#x3C;div className=\"products-grid\"\u003e\n      {products.map((product) =\u003e (\n        \u0026#x3C;ProductCard key={product.id} product={product} /\u003e\n      ))}\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"csrの最適化テクニック\"\u003eCSRの最適化テクニック\u003c/h3\u003e\n\u003ch4 id=\"1-code-splittingコード分割\"\u003e1. Code Splitting（コード分割）\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// 動的インポートによるコード分割\nimport dynamic from 'next/dynamic';\nimport { Suspense } from 'react';\n\n// 重いコンポーネントを遅延ロード\nconst HeavyChart = dynamic(\n  () =\u003e import('@/components/HeavyChart'),\n  {\n    loading: () =\u003e \u0026#x3C;div\u003eグラフを読み込み中...\u0026#x3C;/div\u003e,\n    ssr: false // CSRのみで動作\n  }\n);\n\nexport default function Dashboard() {\n  return (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;h1\u003eダッシュボード\u0026#x3C;/h1\u003e\n      \u0026#x3C;Suspense fallback={\u0026#x3C;div\u003eLoading...\u0026#x3C;/div\u003e}\u003e\n        \u0026#x3C;HeavyChart /\u003e\n      \u0026#x3C;/Suspense\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"2-データフェッチの最適化\"\u003e2. データフェッチの最適化\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// React Query (TanStack Query)を使用した高度なデータ管理\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\n\ninterface Product {\n  id: string;\n  name: string;\n  price: number;\n}\n\n// カスタムフックでデータフェッチロジックを抽象化\nexport function useProducts(options?: { \n  enabled?: boolean; \n  staleTime?: number; \n}) {\n  return useQuery\u0026#x3C;Product[]\u003e({\n    queryKey: ['products'],\n    queryFn: async () =\u003e {\n      const response = await fetch('/api/products');\n      if (!response.ok) throw new Error('Network response was not ok');\n      return response.json();\n    },\n    staleTime: options?.staleTime ?? 5 * 60 * 1000, // 5分間キャッシュ\n    enabled: options?.enabled ?? true,\n    retry: 3, // 3回までリトライ\n    retryDelay: (attemptIndex) =\u003e Math.min(1000 * 2 ** attemptIndex, 30000),\n  });\n}\n\n// Optimistic Update実装\nexport function useUpdateProduct() {\n  const queryClient = useQueryClient();\n  \n  return useMutation({\n    mutationFn: async (product: Product) =\u003e {\n      const response = await fetch(`/api/products/${product.id}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(product),\n      });\n      if (!response.ok) throw new Error('Update failed');\n      return response.json();\n    },\n    onMutate: async (newProduct) =\u003e {\n      // 楽観的更新\n      await queryClient.cancelQueries({ queryKey: ['products'] });\n      const previousProducts = queryClient.getQueryData(['products']);\n      \n      queryClient.setQueryData(['products'], (old: Product[]) =\u003e \n        old.map(p =\u003e p.id === newProduct.id ? newProduct : p)\n      );\n      \n      return { previousProducts };\n    },\n    onError: (err, newProduct, context) =\u003e {\n      // エラー時はロールバック\n      queryClient.setQueryData(['products'], context?.previousProducts);\n    },\n    onSettled: () =\u003e {\n      // 最終的にサーバーと同期\n      queryClient.invalidateQueries({ queryKey: ['products'] });\n    },\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"csrのメリットデメリット\"\u003eCSRのメリット・デメリット\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eメリット\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e🚀 高いインタラクティブ性\u003c/li\u003e\n\u003cli\u003e💾 サーバー負荷が低い\u003c/li\u003e\n\u003cli\u003e📱 SPAとして動作可能\u003c/li\u003e\n\u003cli\u003e🔄 リアルタイム更新が容易\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eデメリット\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e🐌 初期表示が遅い\u003c/li\u003e\n\u003cli\u003e🔍 SEOに不利\u003c/li\u003e\n\u003cli\u003e📦 大きなJSバンドルサイズ\u003c/li\u003e\n\u003cli\u003e📱 低スペックデバイスで性能問題\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ssrserver-side-renderingの深掘り\"\u003eSSR（Server-Side Rendering）の深掘り\u003c/h2\u003e\n\u003ch3 id=\"ssrの仕組み\"\u003eSSRの仕組み\u003c/h3\u003e\n\u003cdiv class=\"mermaid\"\u003esequenceDiagram\n    participant User\n    participant Browser\n    participant Server\n    participant API\n    \n    User-\u0026gt;\u0026gt;Browser: URLアクセス\n    Browser-\u0026gt;\u0026gt;Server: ページリクエスト\n    Server-\u0026gt;\u0026gt;API: データフェッチ\n    API--\u0026gt;\u0026gt;Server: データ\n    Server-\u0026gt;\u0026gt;Server: React コンポーネントをレンダリング\n    Server-\u0026gt;\u0026gt;Server: HTMLを生成\n    Server--\u0026gt;\u0026gt;Browser: 完全なHTML + JSバンドル\n    Browser-\u0026gt;\u0026gt;Browser: HTMLパース・表示\n    Browser-\u0026gt;\u0026gt;Browser: JSダウンロード・実行（Hydration）\n    Browser--\u0026gt;\u0026gt;User: インタラクティブな画面\u003c/div\u003e\n\u003ch3 id=\"ssrの実装例nextjs-app-router\"\u003eSSRの実装例（Next.js App Router）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/products/page.tsx (SSR with App Router)\nimport { Suspense } from 'react';\nimport { headers } from 'next/headers';\n\n// データフェッチング関数\nasync function getProducts() {\n  const host = headers().get('host');\n  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http';\n  \n  const res = await fetch(`${protocol}://${host}/api/products`, {\n    cache: 'no-store', // SSRを強制\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch products');\n  }\n\n  return res.json();\n}\n\n// Server Component\nexport default async function ProductsPage() {\n  const products = await getProducts();\n\n  return (\n    \u0026#x3C;div className=\"container mx-auto px-4\"\u003e\n      \u0026#x3C;h1 className=\"text-3xl font-bold mb-8\"\u003e商品一覧\u0026#x3C;/h1\u003e\n      \n      \u0026#x3C;Suspense fallback={\u0026#x3C;ProductsSkeleton /\u003e}\u003e\n        \u0026#x3C;ProductGrid products={products} /\u003e\n      \u0026#x3C;/Suspense\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\n// Client Component for interactivity\n'use client';\n\nimport { useState } from 'react';\n\nfunction ProductGrid({ products }: { products: Product[] }) {\n  const [filter, setFilter] = useState('all');\n  \n  const filteredProducts = products.filter(product =\u003e {\n    if (filter === 'all') return true;\n    return product.category === filter;\n  });\n\n  return (\n    \u0026#x3C;\u003e\n      \u0026#x3C;FilterBar onFilterChange={setFilter} /\u003e\n      \u0026#x3C;div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\"\u003e\n        {filteredProducts.map((product) =\u003e (\n          \u0026#x3C;ProductCard key={product.id} product={product} /\u003e\n        ))}\n      \u0026#x3C;/div\u003e\n    \u0026#x3C;/\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"streaming-ssrストリーミングssr\"\u003eStreaming SSR（ストリーミングSSR）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/dashboard/page.tsx\nimport { Suspense } from 'react';\n\n// 遅いデータフェッチ\nasync function getAnalytics() {\n  const res = await fetch('/api/analytics', {\n    cache: 'no-store'\n  });\n  // 意図的に遅延を追加（実際のAPIが遅い場合を想定）\n  await new Promise(resolve =\u003e setTimeout(resolve, 3000));\n  return res.json();\n}\n\n// 速いデータフェッチ\nasync function getQuickStats() {\n  const res = await fetch('/api/quick-stats', {\n    cache: 'no-store'\n  });\n  return res.json();\n}\n\n// メインコンポーネント\nexport default async function Dashboard() {\n  const quickStats = await getQuickStats();\n\n  return (\n    \u0026#x3C;div className=\"dashboard\"\u003e\n      \u0026#x3C;h1\u003eダッシュボード\u0026#x3C;/h1\u003e\n      \n      {/* すぐに表示される部分 */}\n      \u0026#x3C;QuickStats data={quickStats} /\u003e\n      \n      {/* ストリーミングで後から表示される部分 */}\n      \u0026#x3C;Suspense fallback={\u0026#x3C;AnalyticsSkeleton /\u003e}\u003e\n        \u0026#x3C;AnalyticsSection /\u003e\n      \u0026#x3C;/Suspense\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\n// 遅延ロードされるコンポーネント\nasync function AnalyticsSection() {\n  const analytics = await getAnalytics();\n  return \u0026#x3C;Analytics data={analytics} /\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ssrのエッジケース処理\"\u003eSSRのエッジケース処理\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// SSRでの条件付きレンダリング\n'use client';\n\nimport { useEffect, useState } from 'react';\n\nexport function ClientOnlyComponent() {\n  const [isClient, setIsClient] = useState(false);\n  \n  useEffect(() =\u003e {\n    setIsClient(true);\n  }, []);\n\n  // サーバーサイドでは何も表示しない\n  if (!isClient) {\n    return null;\n  }\n\n  // クライアントサイドのみで動作するコード\n  return (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;p\u003eブラウザの幅: {window.innerWidth}px\u0026#x3C;/p\u003e\n      \u0026#x3C;p\u003e現在のURL: {window.location.href}\u0026#x3C;/p\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ssgstatic-site-generationの深掘り\"\u003eSSG（Static Site Generation）の深掘り\u003c/h2\u003e\n\u003ch3 id=\"ssgの仕組み\"\u003eSSGの仕組み\u003c/h3\u003e\n\u003cdiv class=\"mermaid\"\u003esequenceDiagram\n    participant Developer\n    participant BuildProcess\n    participant API\n    participant CDN\n    participant User\n    participant Browser\n    \n    Developer-\u0026gt;\u0026gt;BuildProcess: ビルド実行\n    BuildProcess-\u0026gt;\u0026gt;API: データフェッチ\n    API--\u0026gt;\u0026gt;BuildProcess: データ\n    BuildProcess-\u0026gt;\u0026gt;BuildProcess: HTMLファイル生成\n    BuildProcess-\u0026gt;\u0026gt;CDN: 静的ファイルをデプロイ\n    User-\u0026gt;\u0026gt;Browser: URLアクセス\n    Browser-\u0026gt;\u0026gt;CDN: HTMLリクエスト\n    CDN--\u0026gt;\u0026gt;Browser: キャッシュされたHTML\n    Browser--\u0026gt;\u0026gt;User: 即座に表示\u003c/div\u003e\n\u003ch3 id=\"ssgの実装例\"\u003eSSGの実装例\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/blog/[slug]/page.tsx\nimport { notFound } from 'next/navigation';\nimport { getBlogPost, getAllBlogSlugs } from '@/lib/blog';\nimport { MDXRemote } from 'next-mdx-remote/rsc';\n\n// 動的ルートパラメータの型定義\ninterface PageProps {\n  params: {\n    slug: string;\n  };\n}\n\n// ビルド時に生成するパスを定義\nexport async function generateStaticParams() {\n  const slugs = await getAllBlogSlugs();\n  \n  return slugs.map((slug) =\u003e ({\n    slug: slug,\n  }));\n}\n\n// メタデータの生成\nexport async function generateMetadata({ params }: PageProps) {\n  const post = await getBlogPost(params.slug);\n  \n  if (!post) {\n    return {};\n  }\n\n  return {\n    title: post.title,\n    description: post.excerpt,\n    openGraph: {\n      title: post.title,\n      description: post.excerpt,\n      images: [post.ogImage],\n      type: 'article',\n      publishedTime: post.publishedAt,\n      authors: [post.author],\n    },\n    twitter: {\n      card: 'summary_large_image',\n      title: post.title,\n      description: post.excerpt,\n      images: [post.ogImage],\n    },\n  };\n}\n\n// ページコンポーネント\nexport default async function BlogPostPage({ params }: PageProps) {\n  const post = await getBlogPost(params.slug);\n  \n  if (!post) {\n    notFound();\n  }\n\n  return (\n    \u0026#x3C;article className=\"prose prose-lg mx-auto\"\u003e\n      \u0026#x3C;header\u003e\n        \u0026#x3C;h1\u003e{post.title}\u0026#x3C;/h1\u003e\n        \u0026#x3C;div className=\"meta\"\u003e\n          \u0026#x3C;time dateTime={post.publishedAt}\u003e\n            {new Date(post.publishedAt).toLocaleDateString('ja-JP')}\n          \u0026#x3C;/time\u003e\n          \u0026#x3C;span className=\"author\"\u003eby {post.author}\u0026#x3C;/span\u003e\n        \u0026#x3C;/div\u003e\n      \u0026#x3C;/header\u003e\n      \n      \u0026#x3C;MDXRemote source={post.content} /\u003e\n      \n      \u0026#x3C;footer\u003e\n        \u0026#x3C;RelatedPosts currentSlug={params.slug} /\u003e\n      \u0026#x3C;/footer\u003e\n    \u0026#x3C;/article\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ssgの最適化\"\u003eSSGの最適化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// lib/blog.ts - 効率的なデータフェッチング\nimport { cache } from 'react';\nimport { unstable_cache } from 'next/cache';\n\n// React cacheでリクエスト中のメモ化\nexport const getBlogPost = cache(async (slug: string) =\u003e {\n  const post = await db.post.findUnique({\n    where: { slug },\n    include: {\n      author: true,\n      tags: true,\n    },\n  });\n  \n  return post;\n});\n\n// Next.js cacheでビルド間のキャッシュ\nexport const getPopularPosts = unstable_cache(\n  async () =\u003e {\n    const posts = await db.post.findMany({\n      where: { published: true },\n      orderBy: { views: 'desc' },\n      take: 10,\n      select: {\n        id: true,\n        title: true,\n        slug: true,\n        excerpt: true,\n        views: true,\n      },\n    });\n    \n    return posts;\n  },\n  ['popular-posts'],\n  {\n    revalidate: 3600, // 1時間キャッシュ\n    tags: ['posts'],\n  }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"isrincremental-static-regenerationの深掘り\"\u003eISR（Incremental Static Regeneration）の深掘り\u003c/h2\u003e\n\u003ch3 id=\"isrの仕組み\"\u003eISRの仕組み\u003c/h3\u003e\n\u003cdiv class=\"mermaid\"\u003esequenceDiagram\n    participant User1\n    participant User2\n    participant CDN\n    participant Server\n    participant API\n    \n    Note over CDN: 初回リクエスト\n    User1-\u0026gt;\u0026gt;CDN: ページリクエスト\n    CDN-\u0026gt;\u0026gt;Server: キャッシュミス\n    Server-\u0026gt;\u0026gt;API: データフェッチ\n    API--\u0026gt;\u0026gt;Server: データ\n    Server-\u0026gt;\u0026gt;Server: HTML生成\n    Server--\u0026gt;\u0026gt;CDN: HTML（キャッシュ）\n    CDN--\u0026gt;\u0026gt;User1: HTML配信\n    \n    Note over CDN: 再検証前\n    User2-\u0026gt;\u0026gt;CDN: ページリクエスト\n    CDN--\u0026gt;\u0026gt;User2: キャッシュされたHTML（高速）\n    \n    Note over CDN: 再検証期間経過後\n    User1-\u0026gt;\u0026gt;CDN: ページリクエスト\n    CDN--\u0026gt;\u0026gt;User1: 古いHTML（即座に返す）\n    CDN-\u0026gt;\u0026gt;Server: バックグラウンドで再生成\n    Server-\u0026gt;\u0026gt;API: 最新データフェッチ\n    API--\u0026gt;\u0026gt;Server: データ\n    Server-\u0026gt;\u0026gt;Server: HTML再生成\n    Server--\u0026gt;\u0026gt;CDN: 新しいHTML（キャッシュ更新）\u003c/div\u003e\n\u003ch3 id=\"isrの実装例\"\u003eISRの実装例\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/products/[id]/page.tsx\nimport { Metadata } from 'next';\n\ninterface PageProps {\n  params: { id: string };\n}\n\n// ISRの設定\nexport const revalidate = 60; // 60秒ごとに再検証\n\n// または動的な再検証\nexport const dynamicParams = true; // 事前生成されていないパスを許可\n\nexport async function generateStaticParams() {\n  // ビルド時に人気商品のみ事前生成\n  const popularProducts = await fetch('https://api.example.com/products/popular')\n    .then(res =\u003e res.json());\n  \n  return popularProducts.map((product: any) =\u003e ({\n    id: product.id.toString(),\n  }));\n}\n\nexport async function generateMetadata({ params }: PageProps): Promise\u0026#x3C;Metadata\u003e {\n  const product = await getProduct(params.id);\n  \n  return {\n    title: product.name,\n    description: product.description,\n  };\n}\n\nasync function getProduct(id: string) {\n  const res = await fetch(`https://api.example.com/products/${id}`, {\n    next: { revalidate: 60 } // フェッチレベルでの再検証\n  });\n  \n  if (!res.ok) {\n    throw new Error('Failed to fetch product');\n  }\n  \n  return res.json();\n}\n\nexport default async function ProductPage({ params }: PageProps) {\n  const product = await getProduct(params.id);\n  \n  return (\n    \u0026#x3C;div className=\"product-detail\"\u003e\n      \u0026#x3C;h1\u003e{product.name}\u0026#x3C;/h1\u003e\n      \u0026#x3C;p className=\"price\"\u003e¥{product.price.toLocaleString()}\u0026#x3C;/p\u003e\n      \u0026#x3C;div className=\"description\"\u003e{product.description}\u0026#x3C;/div\u003e\n      \n      {/* Client Component for dynamic features */}\n      \u0026#x3C;ProductActions productId={product.id} /\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"on-demand-isrオンデマンド再検証\"\u003eOn-Demand ISR（オンデマンド再検証）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/api/revalidate/route.ts\nimport { revalidatePath, revalidateTag } from 'next/cache';\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport async function POST(request: NextRequest) {\n  const secret = request.nextUrl.searchParams.get('secret');\n  const path = request.nextUrl.searchParams.get('path');\n  const tag = request.nextUrl.searchParams.get('tag');\n\n  // シークレットトークンの検証\n  if (secret !== process.env.REVALIDATION_SECRET) {\n    return NextResponse.json({ message: 'Invalid secret' }, { status: 401 });\n  }\n\n  try {\n    if (path) {\n      // 特定のパスを再検証\n      revalidatePath(path);\n      return NextResponse.json({ revalidated: true, path, now: Date.now() });\n    }\n    \n    if (tag) {\n      // タグベースの再検証\n      revalidateTag(tag);\n      return NextResponse.json({ revalidated: true, tag, now: Date.now() });\n    }\n    \n    return NextResponse.json({ message: 'Missing path or tag' }, { status: 400 });\n  } catch (err) {\n    return NextResponse.json({ message: 'Error revalidating' }, { status: 500 });\n  }\n}\n\n// Webhookからの呼び出し例（CMSの更新時など）\nasync function handleCMSUpdate(updatedContent: any) {\n  await fetch('https://your-app.com/api/revalidate', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      secret: process.env.REVALIDATION_SECRET,\n      path: `/blog/${updatedContent.slug}`,\n    }),\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"実装パターンと最適化テクニック\"\u003e実装パターンと最適化テクニック\u003c/h2\u003e\n\u003ch3 id=\"ハイブリッドレンダリング\"\u003eハイブリッドレンダリング\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/dashboard/page.tsx - 複数の戦略を組み合わせる\nimport { Suspense } from 'react';\nimport { headers } from 'next/headers';\n\n// 静的な部分（SSG）\nexport default function DashboardLayout() {\n  return (\n    \u0026#x3C;div className=\"dashboard\"\u003e\n      \u0026#x3C;StaticHeader /\u003e\n      \n      \u0026#x3C;div className=\"dashboard-content\"\u003e\n        {/* 動的な部分（SSR） */}\n        \u0026#x3C;Suspense fallback={\u0026#x3C;UserInfoSkeleton /\u003e}\u003e\n          \u0026#x3C;UserInfo /\u003e\n        \u0026#x3C;/Suspense\u003e\n        \n        {/* クライアントサイドの部分（CSR） */}\n        \u0026#x3C;RealtimeMetrics /\u003e\n      \u0026#x3C;/div\u003e\n      \n      \u0026#x3C;StaticFooter /\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\n// SSR部分\nasync function UserInfo() {\n  const session = await getServerSession();\n  const user = await getUserData(session.userId);\n  \n  return (\n    \u0026#x3C;div className=\"user-info\"\u003e\n      \u0026#x3C;h2\u003eこんにちは、{user.name}さん\u0026#x3C;/h2\u003e\n      \u0026#x3C;p\u003e最終ログイン: {user.lastLogin}\u0026#x3C;/p\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\n// CSR部分\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { io } from 'socket.io-client';\n\nfunction RealtimeMetrics() {\n  const [metrics, setMetrics] = useState(null);\n  \n  useEffect(() =\u003e {\n    const socket = io('/metrics');\n    \n    socket.on('update', (data) =\u003e {\n      setMetrics(data);\n    });\n    \n    return () =\u003e socket.disconnect();\n  }, []);\n  \n  if (!metrics) return \u0026#x3C;div\u003eメトリクスを読み込み中...\u0026#x3C;/div\u003e;\n  \n  return (\n    \u0026#x3C;div className=\"metrics\"\u003e\n      \u0026#x3C;MetricCard title=\"オンラインユーザー\" value={metrics.onlineUsers} /\u003e\n      \u0026#x3C;MetricCard title=\"今日の売上\" value={metrics.todaySales} /\u003e\n      \u0026#x3C;MetricCard title=\"処理中の注文\" value={metrics.pendingOrders} /\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"progressive-enhancement段階的強化\"\u003eProgressive Enhancement（段階的強化）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// components/SearchForm.tsx\n'use client';\n\nimport { useRouter } from 'next/navigation';\nimport { useTransition } from 'react';\n\nexport function SearchForm() {\n  const router = useRouter();\n  const [isPending, startTransition] = useTransition();\n  \n  // JavaScript無効時でも動作するフォーム\n  return (\n    \u0026#x3C;form \n      action=\"/search\" \n      method=\"GET\"\n      onSubmit={(e) =\u003e {\n        e.preventDefault();\n        const formData = new FormData(e.currentTarget);\n        const query = formData.get('q');\n        \n        startTransition(() =\u003e {\n          router.push(`/search?q=${encodeURIComponent(query)}`);\n        });\n      }}\n    \u003e\n      \u0026#x3C;input\n        type=\"search\"\n        name=\"q\"\n        placeholder=\"検索...\"\n        required\n        disabled={isPending}\n      /\u003e\n      \u0026#x3C;button type=\"submit\" disabled={isPending}\u003e\n        {isPending ? '検索中...' : '検索'}\n      \u0026#x3C;/button\u003e\n    \u0026#x3C;/form\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"データフェッチング最適化\"\u003eデータフェッチング最適化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// lib/data-fetching.ts\nimport { unstable_cache } from 'next/cache';\n\n// Parallel Data Fetching（並列データフェッチ）\nexport async function getPageData(slug: string) {\n  const [post, relatedPosts, comments] = await Promise.all([\n    getPost(slug),\n    getRelatedPosts(slug),\n    getComments(slug),\n  ]);\n  \n  return { post, relatedPosts, comments };\n}\n\n// Request Deduplication（リクエスト重複排除）\nconst getPost = unstable_cache(\n  async (slug: string) =\u003e {\n    const response = await fetch(`/api/posts/${slug}`, {\n      next: { \n        revalidate: 3600,\n        tags: ['post', `post-${slug}`]\n      }\n    });\n    return response.json();\n  },\n  ['post-by-slug'],\n  {\n    revalidate: 3600,\n    tags: ['posts']\n  }\n);\n\n// Waterfall Prevention（ウォーターフォール防止）\nexport async function ProductPage({ id }: { id: string }) {\n  // ❌ 悪い例：順次実行（ウォーターフォール）\n  // const product = await getProduct(id);\n  // const reviews = await getReviews(id);\n  // const recommendations = await getRecommendations(id);\n  \n  // ✅ 良い例：並列実行\n  const dataPromise = Promise.all([\n    getProduct(id),\n    getReviews(id),\n    getRecommendations(id),\n  ]);\n  \n  const [product, reviews, recommendations] = await dataPromise;\n  \n  return (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;ProductInfo product={product} /\u003e\n      \u0026#x3C;Reviews reviews={reviews} /\u003e\n      \u0026#x3C;Recommendations items={recommendations} /\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"パフォーマンス測定と改善\"\u003eパフォーマンス測定と改善\u003c/h2\u003e\n\u003ch3 id=\"core-web-vitalsの測定\"\u003eCore Web Vitalsの測定\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// hooks/useWebVitals.ts\nimport { useEffect } from 'react';\nimport { onCLS, onFID, onLCP, onFCP, onTTFB } from 'web-vitals';\n\nexport function useWebVitals() {\n  useEffect(() =\u003e {\n    // Largest Contentful Paint\n    onLCP((metric) =\u003e {\n      console.log('LCP:', metric.value);\n      // Google Analyticsに送信\n      gtag('event', 'web_vitals', {\n        event_category: 'Web Vitals',\n        event_label: 'LCP',\n        value: Math.round(metric.value),\n        metric_id: metric.id,\n        metric_value: metric.value,\n        metric_delta: metric.delta,\n      });\n    });\n    \n    // First Input Delay\n    onFID((metric) =\u003e {\n      console.log('FID:', metric.value);\n    });\n    \n    // Cumulative Layout Shift\n    onCLS((metric) =\u003e {\n      console.log('CLS:', metric.value);\n    });\n    \n    // First Contentful Paint\n    onFCP((metric) =\u003e {\n      console.log('FCP:', metric.value);\n    });\n    \n    // Time to First Byte\n    onTTFB((metric) =\u003e {\n      console.log('TTFB:', metric.value);\n    });\n  }, []);\n}\n\n// app/layout.tsx\nexport default function RootLayout({ children }) {\n  return (\n    \u0026#x3C;html\u003e\n      \u0026#x3C;body\u003e\n        \u0026#x3C;WebVitalsReporter /\u003e\n        {children}\n      \u0026#x3C;/body\u003e\n    \u0026#x3C;/html\u003e\n  );\n}\n\nfunction WebVitalsReporter() {\n  useWebVitals();\n  return null;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"バンドルサイズの最適化\"\u003eバンドルサイズの最適化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// next.config.js\nmodule.exports = {\n  // Bundle Analyzer設定\n  webpack: (config, { isServer }) =\u003e {\n    if (process.env.ANALYZE === 'true') {\n      const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n      config.plugins.push(\n        new BundleAnalyzerPlugin({\n          analyzerMode: 'static',\n          reportFilename: isServer ? '../analyze/server.html' : './analyze/client.html',\n        })\n      );\n    }\n    return config;\n  },\n  \n  // 画像最適化\n  images: {\n    domains: ['images.example.com'],\n    formats: ['image/avif', 'image/webp'],\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n  },\n  \n  // SWC minifier使用\n  swcMinify: true,\n  \n  // 実験的機能\n  experimental: {\n    optimizeCss: true,\n    legacyBrowsers: false,\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"画像最適化戦略\"\u003e画像最適化戦略\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// components/OptimizedImage.tsx\nimport Image from 'next/image';\nimport { useState } from 'react';\n\ninterface OptimizedImageProps {\n  src: string;\n  alt: string;\n  priority?: boolean;\n  className?: string;\n}\n\nexport function OptimizedImage({ \n  src, \n  alt, \n  priority = false,\n  className \n}: OptimizedImageProps) {\n  const [isLoading, setIsLoading] = useState(true);\n  \n  return (\n    \u0026#x3C;div className={`image-container ${className}`}\u003e\n      \u0026#x3C;Image\n        src={src}\n        alt={alt}\n        fill\n        priority={priority}\n        quality={85}\n        sizes=\"(max-width: 640px) 100vw,\n               (max-width: 1024px) 50vw,\n               33vw\"\n        placeholder=\"blur\"\n        blurDataURL={`data:image/svg+xml;base64,...`} // 実際のblur画像\n        onLoadingComplete={() =\u003e setIsLoading(false)}\n        className={`\n          duration-700 ease-in-out\n          ${isLoading ? 'scale-110 blur-2xl grayscale' : 'scale-100 blur-0 grayscale-0'}\n        `}\n      /\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"実践的な選択基準\"\u003e実践的な選択基準\u003c/h2\u003e\n\u003ch3 id=\"レンダリング戦略の選択フローチャート\"\u003eレンダリング戦略の選択フローチャート\u003c/h3\u003e\n\u003cdiv class=\"mermaid\"\u003eflowchart TD\n    Start[開始] --\u0026gt; Q1{コンテンツは頻繁に更新される？}\n    Q1 --\u0026gt;|Yes| Q2{リアルタイム性が必要？}\n    Q1 --\u0026gt;|No| Q3{SEOは重要？}\n    \n    Q2 --\u0026gt;|Yes| CSR[CSR推奨]\n    Q2 --\u0026gt;|No| Q4{更新頻度は？}\n    \n    Q3 --\u0026gt;|Yes| SSG[SSG推奨]\n    Q3 --\u0026gt;|No| Q5{ユーザー固有のコンテンツ？}\n    \n    Q4 --\u0026gt;|毎分〜毎時| SSR[SSR推奨]\n    Q4 --\u0026gt;|毎日〜毎週| ISR[ISR推奨]\n    \n    Q5 --\u0026gt;|Yes| CSR\n    Q5 --\u0026gt;|No| SSG\n    \n    CSR --\u0026gt; End[終了]\n    SSR --\u0026gt; End\n    SSG --\u0026gt; End\n    ISR --\u0026gt; End\u003c/div\u003e\n\u003ch3 id=\"実際のユースケースマッピング\"\u003e実際のユースケースマッピング\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eユースケース\u003c/th\u003e\u003cth\u003e推奨戦略\u003c/th\u003e\u003cth\u003e理由\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e企業サイトのトップページ\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eSSG + ISR\u003c/td\u003e\u003ctd\u003eSEO重要、更新頻度低、高速表示必要\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eブログ記事\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eSSG\u003c/td\u003e\u003ctd\u003eコンテンツ固定、SEO最重要\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eECサイトの商品ページ\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eISR\u003c/td\u003e\u003ctd\u003e在庫・価格の定期更新、SEO重要\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e管理画面\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eCSR\u003c/td\u003e\u003ctd\u003eSEO不要、高インタラクティブ性\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eニュースサイト\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eSSR + ISR\u003c/td\u003e\u003ctd\u003e最新性重要、SEO必要\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eSNSフィード\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eCSR + SSR\u003c/td\u003e\u003ctd\u003e初期表示速度とリアルタイム更新の両立\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eユーザープロフィール\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eSSR\u003c/td\u003e\u003ctd\u003e動的コンテンツ、SEO一部必要\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eランディングページ\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eSSG\u003c/td\u003e\u003ctd\u003e高速表示、SEO最重要、更新少ない\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2 id=\"高度なトピック\"\u003e高度なトピック\u003c/h2\u003e\n\u003ch3 id=\"react-19とnextjs-15の新機能2024-2025\"\u003eReact 19とNext.js 15の新機能（2024-2025）\u003c/h3\u003e\n\u003ch4 id=\"react-19の主要アップデート\"\u003eReact 19の主要アップデート\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// 1. use() Hook - プロミスやコンテキストを直接使用\nimport { use } from 'react';\n\nfunction Comments({ commentsPromise }) {\n  // プロミスを直接使用（Suspenseと自動統合）\n  const comments = use(commentsPromise);\n  return \u0026#x3C;div\u003e{comments.map(c =\u003e \u0026#x3C;p\u003e{c.text}\u0026#x3C;/p\u003e)}\u0026#x3C;/div\u003e;\n}\n\n// 2. Server Components での async/await\nasync function ProductDetails({ id }) {\n  const product = await fetch(`/api/products/${id}`).then(r =\u003e r.json());\n  return \u0026#x3C;div\u003e{product.name}\u0026#x3C;/div\u003e;\n}\n\n// 3. Actions - フォーム処理の簡素化\nfunction ContactForm() {\n  async function submitAction(formData: FormData) {\n    'use server';\n    await saveContact(formData);\n  }\n  \n  return (\n    \u0026#x3C;form action={submitAction}\u003e\n      \u0026#x3C;input name=\"email\" type=\"email\" /\u003e\n      \u0026#x3C;button type=\"submit\"\u003e送信\u0026#x3C;/button\u003e\n    \u0026#x3C;/form\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"nextjs-15の新機能\"\u003eNext.js 15の新機能\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// 1. Turbopack (デフォルト有効化)\n// next.config.js\nmodule.exports = {\n  experimental: {\n    turbo: true, // Webpack比で最大10倍高速\n  },\n};\n\n// 2. 改善されたエラーハンドリング\nexport default function ErrorBoundary({\n  error,\n  reset,\n}: {\n  error: Error \u0026#x26; { digest?: string };\n  reset: () =\u003e void;\n}) {\n  return (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;h2\u003eエラーが発生しました\u0026#x3C;/h2\u003e\n      \u0026#x3C;details\u003e\n        \u0026#x3C;summary\u003e詳細\u0026#x3C;/summary\u003e\n        \u0026#x3C;pre\u003e{error.message}\u0026#x3C;/pre\u003e\n      \u0026#x3C;/details\u003e\n      \u0026#x3C;button onClick={reset}\u003e再試行\u0026#x3C;/button\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"react-server-componentsrsc\"\u003eReact Server Components（RSC）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/products/ProductList.tsx - Server Component\nimport { db } from '@/lib/db';\n\n// Server Componentはasync関数として定義可能\nexport default async function ProductList({ category }: { category: string }) {\n  // サーバーサイドで直接DBアクセス\n  const products = await db.product.findMany({\n    where: { category },\n    include: { \n      reviews: {\n        select: { rating: true }\n      }\n    }\n  });\n  \n  // サーバーサイドで集計処理\n  const productsWithRating = products.map(product =\u003e ({\n    ...product,\n    averageRating: product.reviews.reduce((acc, r) =\u003e acc + r.rating, 0) / product.reviews.length\n  }));\n  \n  return (\n    \u0026#x3C;div className=\"product-list\"\u003e\n      {productsWithRating.map(product =\u003e (\n        // Client Componentに必要最小限のデータを渡す\n        \u0026#x3C;ProductCard \n          key={product.id} \n          product={product}\n          averageRating={product.averageRating}\n        /\u003e\n      ))}\n    \u0026#x3C;/div\u003e\n  );\n}\n\n// components/ProductCard.tsx - Client Component\n'use client';\n\nimport { useState } from 'react';\nimport { addToCart } from '@/actions/cart';\n\nexport function ProductCard({ product, averageRating }) {\n  const [isAdding, setIsAdding] = useState(false);\n  \n  const handleAddToCart = async () =\u003e {\n    setIsAdding(true);\n    await addToCart(product.id);\n    setIsAdding(false);\n  };\n  \n  return (\n    \u0026#x3C;div className=\"product-card\"\u003e\n      \u0026#x3C;h3\u003e{product.name}\u0026#x3C;/h3\u003e\n      \u0026#x3C;p\u003e評価: {averageRating.toFixed(1)}\u0026#x3C;/p\u003e\n      \u0026#x3C;button onClick={handleAddToCart} disabled={isAdding}\u003e\n        {isAdding ? 'カートに追加中...' : 'カートに追加'}\n      \u0026#x3C;/button\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"edge-runtime最適化\"\u003eEdge Runtime最適化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/api/geo/route.ts - Edge Runtime使用\nexport const runtime = 'edge'; // Edge Runtimeを指定\n\nexport async function GET(request: Request) {\n  // CloudflareやVercel Edge Functionsで実行\n  const country = request.headers.get('CF-IPCountry') || 'JP';\n  const city = request.headers.get('CF-City') || 'Tokyo';\n  \n  // 地域に基づいたコンテンツ配信\n  const content = await getLocalizedContent(country, city);\n  \n  return new Response(JSON.stringify(content), {\n    headers: {\n      'Content-Type': 'application/json',\n      'Cache-Control': 'public, max-age=3600',\n      'CDN-Cache-Control': 'max-age=86400',\n    },\n  });\n}\n\n// middleware.ts - Edge Middlewareでルーティング\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  const country = request.geo?.country || 'JP';\n  \n  // 地域別リダイレクト\n  if (country === 'US' \u0026#x26;\u0026#x26; request.nextUrl.pathname === '/') {\n    return NextResponse.redirect(new URL('/us', request.url));\n  }\n  \n  // A/Bテスト\n  const bucket = Math.random() \u0026#x3C; 0.5 ? 'a' : 'b';\n  const response = NextResponse.next();\n  response.cookies.set('ab-test', bucket);\n  \n  return response;\n}\n\nexport const config = {\n  matcher: ['/((?!api|_next/static|favicon.ico).*)'],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"partial-prerendering部分的事前レンダリング\"\u003ePartial Prerendering（部分的事前レンダリング）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// app/dashboard/page.tsx - Partial Prerendering (実験的機能)\nimport { Suspense } from 'react';\n\nexport const experimental_ppr = true; // Partial Prerenderingを有効化\n\nexport default function Dashboard() {\n  return (\n    \u0026#x3C;div\u003e\n      {/* 静的にプリレンダリングされる部分 */}\n      \u0026#x3C;header\u003e\n        \u0026#x3C;h1\u003eダッシュボード\u0026#x3C;/h1\u003e\n        \u0026#x3C;Navigation /\u003e\n      \u0026#x3C;/header\u003e\n      \n      {/* 動的な部分はSuspenseで囲む */}\n      \u0026#x3C;Suspense fallback={\u0026#x3C;div\u003eLoading user data...\u0026#x3C;/div\u003e}\u003e\n        \u0026#x3C;UserDashboard /\u003e\n      \u0026#x3C;/Suspense\u003e\n      \n      {/* 静的な部分 */}\n      \u0026#x3C;footer\u003e\n        \u0026#x3C;Copyright /\u003e\n      \u0026#x3C;/footer\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\nasync function UserDashboard() {\n  const session = await getSession();\n  const userData = await getUserData(session.userId);\n  \n  return \u0026#x3C;DashboardContent data={userData} /\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"セキュリティ考慮事項\"\u003eセキュリティ考慮事項\u003c/h2\u003e\n\u003ch3 id=\"xss対策\"\u003eXSS対策\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// ❌ 危険な実装\nexport function DangerousComponent({ htmlContent }: { htmlContent: string }) {\n  return \u0026#x3C;div dangerouslySetInnerHTML={{ __html: htmlContent }} /\u003e;\n}\n\n// ✅ 安全な実装\nimport DOMPurify from 'isomorphic-dompurify';\n\nexport function SafeComponent({ htmlContent }: { htmlContent: string }) {\n  const cleanHTML = DOMPurify.sanitize(htmlContent, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],\n    ALLOWED_ATTR: ['href', 'target', 'rel'],\n  });\n  \n  return \u0026#x3C;div dangerouslySetInnerHTML={{ __html: cleanHTML }} /\u003e;\n}\n\n// Server Actionsでの検証\n'use server';\n\nimport { z } from 'zod';\n\nconst formSchema = z.object({\n  name: z.string().min(1).max(100),\n  email: z.string().email(),\n  message: z.string().min(10).max(1000),\n});\n\nexport async function submitForm(formData: FormData) {\n  const validatedFields = formSchema.safeParse({\n    name: formData.get('name'),\n    email: formData.get('email'),\n    message: formData.get('message'),\n  });\n  \n  if (!validatedFields.success) {\n    return { error: validatedFields.error.flatten().fieldErrors };\n  }\n  \n  // 安全に処理を続行\n  await saveToDatabase(validatedFields.data);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"デバッグとトラブルシューティング\"\u003eデバッグとトラブルシューティング\u003c/h2\u003e\n\u003ch3 id=\"hydrationエラーの対処\"\u003eHydrationエラーの対処\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// ❌ Hydrationエラーが発生する例\nfunction BadComponent() {\n  return (\n    \u0026#x3C;div\u003e\n      現在時刻: {new Date().toLocaleTimeString()}\n    \u0026#x3C;/div\u003e\n  );\n}\n\n// ✅ Hydrationエラーを防ぐ実装\n'use client';\n\nimport { useEffect, useState } from 'react';\n\nfunction GoodComponent() {\n  const [time, setTime] = useState\u0026#x3C;string\u003e('');\n  \n  useEffect(() =\u003e {\n    setTime(new Date().toLocaleTimeString());\n    const interval = setInterval(() =\u003e {\n      setTime(new Date().toLocaleTimeString());\n    }, 1000);\n    \n    return () =\u003e clearInterval(interval);\n  }, []);\n  \n  // サーバーサイドでは空文字列、クライアントサイドで時刻表示\n  return (\n    \u0026#x3C;div\u003e\n      現在時刻: {time || 'Loading...'}\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"まとめ\"\u003eまとめ\u003c/h2\u003e\n\u003ch3 id=\"重要なポイントのチェックリスト\"\u003e重要なポイントのチェックリスト\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e基本理解\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e CSR/SSR/SSG/ISRの動作原理を説明できる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e 各戦略のメリット・デメリットを理解している\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Core Web Vitalsと各戦略の関係を説明できる\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e実装スキル\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Next.js App Routerで各戦略を実装できる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e データフェッチングの最適化ができる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Suspenseとストリーミングを活用できる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e React Server Componentsを適切に使える\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eパフォーマンス\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e バンドルサイズの最適化ができる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e 画像最適化の実装ができる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e Core Web Vitalsの測定と改善ができる\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e応用力\u003c/strong\u003e:\u003c/p\u003e\n\u003cul class=\"contains-task-list\"\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e プロジェクトに適した戦略を選択できる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e ハイブリッドレンダリングを設計できる\u003c/li\u003e\n\u003cli class=\"task-list-item\"\u003e\u003cinput type=\"checkbox\" disabled\u003e セキュリティを考慮した実装ができる\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"面接での回答例\"\u003e面接での回答例\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eQ1: CSRとSSRの違いを説明してください\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: CSRとSSRの本質的な違いは、HTMLの生成場所とタイミングです。\n\nCSRはブラウザ上でJavaScriptを実行してHTMLを生成します。\n初期表示は遅いですが、その後のインタラクションは高速です。\nSPAやダッシュボードなど、SEOが不要でインタラクティブ性が\n重要な場面で使用します。\n\nSSRはサーバー側でHTMLを生成してブラウザに送信します。\n初期表示が速く、SEOに有利ですが、サーバー負荷が高くなります。\nECサイトやニュースサイトなど、SEOとコンテンツの鮮度が\n重要な場面で使用します。\n\n実際のプロジェクトでは、React Server ComponentsやSuspenseを\n活用して、両者の利点を組み合わせたハイブリッドな実装を\n行うことが多いです。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eQ2: Hydrationとは何ですか？エラーが起きる原因は？\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: Hydrationは、SSRで生成された静的HTMLに、クライアントサイドで\nJavaScriptのイベントハンドラーや状態管理を「注入」するプロセスです。\n\nエラーが起きる主な原因：\n1. サーバーとクライアントで異なるHTMLが生成される\n   - Math.random()や Date.now()の使用\n   - window/documentオブジェクトの参照\n2. 条件付きレンダリングの不整合\n3. 外部ライブラリの不適切な使用\n\n対策として、useEffectでクライアントサイドのみの処理を分離したり、\ndynamic importでSSRを無効化したりします。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eQ3: ISRとSSGの違いは？どう使い分ける？\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: SSGはビルド時に全ページを生成し、ISRは必要に応じて\nページを再生成できる点が違います。\n\nSSG：\n- ビルド時に全ページ生成\n- 更新にはリビルドが必要\n- 小規模サイト、更新頻度が低いコンテンツ向け\n\nISR：\n- オンデマンドまたは定期的に再生成\n- revalidateで更新間隔を制御\n- 大規模ECサイト、ニュースサイト向け\n\n例：ブログは記事数が少なければSSG、\n数千記事以上ならISRを選択します。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eQ4: React Server Componentsの利点は？\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA: RSCの主な利点は3つあります：\n\n1. バンドルサイズの削減\n   - サーバー専用の依存関係はクライアントに送られない\n   - 大きなライブラリ（MDX、構文ハイライト等）をサーバーに隔離\n\n2. データフェッチの簡素化\n   - async/awaitで直接データベースアクセス可能\n   - ウォーターフォール問題の解消\n\n3. セキュリティの向上\n   - APIキーやDBアクセスをサーバーに隔離\n   - 機密データの露出リスク低減\n\n注意点として、Client ComponentsとのデータやPropsの\n受け渡しには制約があります。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"他のフレームワークとの比較\"\u003e他のフレームワークとの比較\u003c/h3\u003e\n\u003ch4 id=\"nextjs-vs-remix-vs-astro\"\u003eNext.js vs Remix vs Astro\u003c/h4\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e特徴\u003c/th\u003e\u003cth\u003eNext.js\u003c/th\u003e\u003cth\u003eRemix\u003c/th\u003e\u003cth\u003eAstro\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e主な強み\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e柔軟性、大規模エコシステム\u003c/td\u003e\u003ctd\u003eデータローディング、プログレッシブエンハンスメント\u003c/td\u003e\u003ctd\u003eゼロJSデフォルト、高速性\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eデフォルト戦略\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eSSG/ISR\u003c/td\u003e\u003ctd\u003eSSR\u003c/td\u003e\u003ctd\u003eSSG\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e学習曲線\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e中程度\u003c/td\u003e\u003ctd\u003eやや高い\u003c/td\u003e\u003ctd\u003e低い\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e適用場面\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e汎用的、大規模アプリ\u003c/td\u003e\u003ctd\u003e動的コンテンツ中心\u003c/td\u003e\u003ctd\u003eコンテンツサイト\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eReact Server Components\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e✅ フル対応\u003c/td\u003e\u003ctd\u003e❌ 未対応\u003c/td\u003e\u003ctd\u003e⚠️ 部分対応\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eエッジランタイム\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e✅ 対応\u003c/td\u003e\u003ctd\u003e✅ 対応\u003c/td\u003e\u003ctd\u003e✅ 対応\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e// Remixのデータローディング例\nexport async function loader({ params }) {\n  const product = await getProduct(params.id);\n  return json({ product });\n}\n\nexport default function Product() {\n  const { product } = useLoaderData();\n  return \u0026#x3C;div\u003e{product.name}\u0026#x3C;/div\u003e;\n}\n\n// Astroのアイランドアーキテクチャ例\n---\n// .astro ファイル\nimport ReactComponent from './ReactComponent.jsx';\nconst data = await fetch('/api/data').then(r =\u003e r.json());\n---\n\u0026#x3C;html\u003e\n  \u0026#x3C;body\u003e\n    \u0026#x3C;!-- 静的HTML --\u003e\n    \u0026#x3C;h1\u003e{data.title}\u0026#x3C;/h1\u003e\n    \u0026#x3C;!-- インタラクティブな部分のみReact --\u003e\n    \u0026#x3C;ReactComponent client:load data={data} /\u003e\n  \u0026#x3C;/body\u003e\n\u0026#x3C;/html\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"継続的な学習のために\"\u003e継続的な学習のために\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e実践プロジェクト\u003c/strong\u003e: 各戦略を使った小規模アプリを作成\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eパフォーマンス測定\u003c/strong\u003e: Lighthouse、WebPageTestでの定期的な測定\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e最新動向\u003c/strong\u003e: Next.js、React公式ドキュメントのチェック\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eコミュニティ\u003c/strong\u003e: React/Next.jsコミュニティへの参加\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e他フレームワークの学習\u003c/strong\u003e: Remix、Astro、SvelteKitなども触ってみる\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"参考リンク\"\u003e参考リンク\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/docs\"\u003eNext.js Documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://react.dev/reference/react/use-server\"\u003eReact Server Components\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://web.dev/vitals/\"\u003eWeb Vitals\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nextjs.org/docs/app\"\u003eNext.js App Router\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://vercel.com/docs/functions/edge-functions\"\u003eVercel Edge Functions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cem\u003eこの記事は、React開発における実践的なレンダリング戦略の選択と実装に基づいて作成されました。\u003c/em\u003e\u003c/p\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold mb-2\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-green-600\",\"children\":[\"#\",40]}],\" \",\"React レンダリング戦略完全ガイド - CSR/SSR/SSG/ISRを本質から理解する\"]}],[\"$\",\"ul\",null,{\"className\":\"list-none border-b border-gray-600 pb-4 mb-6\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"作成日時: \",\"2025-08-25 00:45\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"更新日時: \",\"2025-08-25 00:54\"]}],[\"$\",\"li\",null,{\"className\":\"flex flex-wrap gap-2 mt-2\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"React\"}],[\"$\",\"span\",\"1\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"Next.js\"}],[\"$\",\"span\",\"2\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"CSR\"}],[\"$\",\"span\",\"3\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"SSR\"}],[\"$\",\"span\",\"4\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"SSG\"}],[\"$\",\"span\",\"5\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"ISR\"}],[\"$\",\"span\",\"6\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"レンダリング\"}],[\"$\",\"span\",\"7\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"パフォーマンス\"}],[\"$\",\"span\",\"8\",{\"className\":\"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs\",\"children\":\"SEO\"}]]}]]}],[\"$\",\"nav\",null,{\"className\":\"mb-6 pb-4 border-b border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}],[\"$\",\"article\",null,{\"className\":\"prose dark:prose-invert\",\"dangerouslySetInnerHTML\":{\"__html\":\"$13\"}}],[\"$\",\"$L14\",null,{}],[\"$\",\"nav\",null,{\"className\":\"mt-8 pt-4 border-t border-gray-700 flex justify-between\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"← ホームへ\"}],[\"$\",\"$L12\",null,{\"href\":\"/blog\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"記事一覧へ →\"}]]}],[\"$\",\"$L15\",null,{}]]}]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"11:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Maita Tomoya Dev IO\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"米田智哉の技術ブログ。キャッチアップしたことをメモします。\"}]],\"error\":null,\"digest\":\"$undefined\"}\nb:{\"metadata\":\"$11:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>