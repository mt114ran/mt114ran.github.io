1:"$Sreact.fragment"
2:I[87555,[],""]
3:I[31295,[],""]
5:I[59665,[],"MetadataBoundary"]
7:I[59665,[],"OutletBoundary"]
a:I[74911,[],"AsyncMetadataOutlet"]
c:I[59665,[],"ViewportBoundary"]
e:I[26614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/19bdf9af4d1ae4d4.css","style"]
0:{"P":null,"b":"KZrMisSdXyu7FDjuS9HOy","p":"","c":["","blog","react-component-conditional-rendering-best-practices",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","react-component-conditional-rendering-best-practices","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/19bdf9af4d1ae4d4.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":["$","link",null,{"rel":"icon","href":"/favicon.png","type":"image/png"}]}],["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","react-component-conditional-rendering-best-practices","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",["$","$L5",null,{"children":"$L6"}],null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","X2uzTvbTtkRIN4MTaZor5",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$e","$undefined"],"s":false,"S":true}
f:"$Sreact.suspense"
10:I[74911,[],"AsyncMetadata"]
6:["$","$f",null,{"fallback":null,"children":["$","$L10",null,{"promise":"$@11"}]}]
9:null
12:I[6874,["6874","static/chunks/6874-6c1ddde525f3893c.js","5953","static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js"],""]
14:I[31203,["6874","static/chunks/6874-6c1ddde525f3893c.js","5953","static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js"],"default"]
15:I[4197,["6874","static/chunks/6874-6c1ddde525f3893c.js","5953","static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js"],"default"]
13:T3efd,<h1 id="react-コンポーネントの条件分岐レンダリング判定ロジックはどこに配置するべきか">React コンポーネントの条件分岐レンダリング：判定ロジックはどこに配置するべきか</h1>
<h2 id="はじめに">はじめに</h2>
<p>React開発において、コンポーネントの表示/非表示を制御する際に「判定ロジックをどこに配置するべきか」は重要な設計判断です。特に、API から取得したデータに基づく条件分岐では、親コンポーネントで判定するか、子コンポーネント内で判定するかで保守性や再利用性が大きく変わります。</p>
<p>本記事では、実際のReact Nativeアプリでの発送遅延通知機能を例に、条件分岐の配置について詳しく解説します。</p>
<h2 id="具体的な事例発送遅延通知コンポーネント">具体的な事例：発送遅延通知コンポーネント</h2>
<h3 id="要件">要件</h3>
<ul>
<li>APIから取得したメタデータに基づいて発送遅延通知を表示</li>
<li>フラグが <code>true</code> かつ テキストが存在する場合のみ表示</li>
<li>複数画面で再利用される可能性</li>
</ul>
<h3 id="実装パターン1親コンポーネントで判定">実装パターン1：親コンポーネントで判定</h3>
<pre><code class="language-tsx">// 親コンポーネント（呼び出し元）
const OriginalPackProductsPage = () => {
  const { metadata } = useAppMetadata();
  
  // 親で表示条件を判定
  const shouldShowNotice = metadata?.isShowShippingDelayNotice &#x26;&#x26; 
                          metadata?.shippingDelayNoticeText;

  return (
    &#x3C;View>
      {/* 親で条件を判定してから子を呼び出す */}
      {shouldShowNotice &#x26;&#x26; (
        &#x3C;ShippingDelayNotice text={metadata.shippingDelayNoticeText} />
      )}
    &#x3C;/View>
  );
};

// 子コンポーネント（表示専用）
const ShippingDelayNotice = ({ text }: { text: string }) => {
  return (
    &#x3C;View style={styles.container}>
      &#x3C;Text style={styles.text}>{text}&#x3C;/Text>
    &#x3C;/View>
  );
};
</code></pre>
<h3 id="実装パターン2子コンポーネントで判定推奨">実装パターン2：子コンポーネントで判定（推奨）</h3>
<pre><code class="language-tsx">// 親コンポーネント（呼び出し元）
const OriginalPackProductsPage = () => {
  return (
    &#x3C;View>
      {/* シンプルに子コンポーネントを呼び出すだけ */}
      &#x3C;ShippingDelayNotice />
    &#x3C;/View>
  );
};

// 子コンポーネント（判定＋表示）
const ShippingDelayNotice = () => {
  const { metadata } = useAppMetadata();
  
  const isShowNotice = metadata?.isShowShippingDelayNotice &#x26;&#x26; 
                      metadata?.shippingDelayNoticeText;

  // 発送遅延通知フラグがfalseまたはテキストを取得できていない場合は何も表示しない
  if (!isShowNotice) {
    return null;
  }

  return (
    &#x3C;View style={styles.container}>
      &#x3C;Text style={styles.text}>
        {metadata.shippingDelayNoticeText}
      &#x3C;/Text>
    &#x3C;/View>
  );
};
</code></pre>
<h2 id="各パターンの比較分析">各パターンの比較分析</h2>
<h3 id="パターン1親で判定の特徴">パターン1（親で判定）の特徴</h3>
<p><strong>メリット：</strong></p>
<ul>
<li>子コンポーネントがシンプル</li>
<li>propsが明確で単体テストしやすい</li>
<li>表示ロジックと描画ロジックが分離されている</li>
</ul>
<p><strong>デメリット：</strong></p>
<ul>
<li>呼び出し元が毎回同じ条件判定を書く必要がある</li>
<li>APIの構造変更時に複数箇所の修正が必要</li>
<li>再利用時に条件判定のコードが重複する</li>
</ul>
<h3 id="パターン2子で判定の特徴">パターン2（子で判定）の特徴</h3>
<p><strong>メリット：</strong></p>
<ul>
<li>呼び出し元がシンプル</li>
<li>条件判定ロジックが1箇所に集約</li>
<li>再利用時の実装が簡単</li>
<li>APIの構造変更時の影響範囲が限定的</li>
</ul>
<p><strong>デメリット：</strong></p>
<ul>
<li>子コンポーネントがAPI依存になる</li>
<li>単体テスト時にAPIモックが必要</li>
</ul>
<h2 id="設計原則から見た判断基準">設計原則から見た判断基準</h2>
<h3 id="1-単一責任の原則single-responsibility-principle">1. 単一責任の原則（Single Responsibility Principle）</h3>
<pre><code class="language-tsx">// ❌ 親が複数の責任を持つ
const Parent = () => {
  // 1. データ取得の責任
  const { metadata } = useAppMetadata();
  
  // 2. 表示判定の責任
  const shouldShow = metadata?.flag &#x26;&#x26; metadata?.text;
  
  // 3. UI構築の責任
  return &#x3C;View>{shouldShow &#x26;&#x26; &#x3C;Child />}&#x3C;/View>;
};

// ✅ 責任を適切に分離
const Parent = () => {
  // UI構築の責任のみ
  return &#x3C;View>&#x3C;Child />&#x3C;/View>;
};

const Child = () => {
  // データ取得と表示判定の責任
  const { metadata } = useAppMetadata();
  const shouldShow = metadata?.flag &#x26;&#x26; metadata?.text;
  if (!shouldShow) return null;
  
  return &#x3C;View>...&#x3C;/View>;
};
</code></pre>
<h3 id="2-dry原則dont-repeat-yourself">2. DRY原則（Don't Repeat Yourself）</h3>
<pre><code class="language-tsx">// ❌ 複数箇所で同じ判定ロジック
const PageA = () => {
  const { metadata } = useAppMetadata();
  const shouldShow = metadata?.isShowShippingDelayNotice &#x26;&#x26; 
                    metadata?.shippingDelayNoticeText;
  return shouldShow &#x26;&#x26; &#x3C;ShippingDelayNotice />;
};

const PageB = () => {
  const { metadata } = useAppMetadata();
  // 同じ判定ロジックが重複
  const shouldShow = metadata?.isShowShippingDelayNotice &#x26;&#x26; 
                    metadata?.shippingDelayNoticeText;
  return shouldShow &#x26;&#x26; &#x3C;ShippingDelayNotice />;
};

// ✅ 判定ロジックを1箇所に集約
const PageA = () => &#x3C;ShippingDelayNotice />;
const PageB = () => &#x3C;ShippingDelayNotice />;

const ShippingDelayNotice = () => {
  // 判定ロジックが1箇所のみ
  const { metadata } = useAppMetadata();
  const shouldShow = metadata?.isShowShippingDelayNotice &#x26;&#x26; 
                    metadata?.shippingDelayNoticeText;
  if (!shouldShow) return null;
  return &#x3C;View>...&#x3C;/View>;
};
</code></pre>
<h3 id="3-関心の分離separation-of-concerns">3. 関心の分離（Separation of Concerns）</h3>
<p>コンポーネントの責任を明確に分離することで、保守性が向上します：</p>
<pre><code class="language-tsx">// ✅ 各コンポーネントが明確な責任を持つ
const ShippingDelayNotice = () => {
  // 発送遅延通知に関する全ての責任を集約
  const { metadata } = useAppMetadata();
  
  // この条件は「発送遅延通知」の表示条件なので、
  // このコンポーネントが知っているべき知識
  const isShowNotice = metadata?.isShowShippingDelayNotice &#x26;&#x26; 
                      metadata?.shippingDelayNoticeText;

  if (!isShowNotice) {
    return null;
  }

  return (
    &#x3C;View style={styles.container}>
      &#x3C;Text style={styles.text}>
        {metadata.shippingDelayNoticeText}
      &#x3C;/Text>
    &#x3C;/View>
  );
};
</code></pre>
<h2 id="実践的な判断基準">実践的な判断基準</h2>
<h3 id="子コンポーネントで判定すべき場合">子コンポーネントで判定すべき場合</h3>
<ol>
<li>
<p><strong>コンポーネント固有の表示条件</strong></p>
<pre><code class="language-tsx">// ユーザープロフィール画像の表示判定
const Avatar = () => {
  const { user } = useAuth();
  // アバターコンポーネント自身が判断すべき条件
  if (!user?.avatarUrl) return &#x3C;DefaultAvatar />;
  return &#x3C;img src={user.avatarUrl} />;
};
</code></pre>
</li>
<li>
<p><strong>複数箇所で再利用される条件</strong></p>
<pre><code class="language-tsx">// 通知バッジの表示判定
const NotificationBadge = () => {
  const { unreadCount } = useNotification();
  // バッジ表示の条件はバッジコンポーネント自身が持つべき
  if (unreadCount === 0) return null;
  return &#x3C;Badge count={unreadCount} />;
};
</code></pre>
</li>
<li>
<p><strong>APIデータ構造に密結合な条件</strong></p>
</li>
</ol>
<h3 id="親コンポーネントで判定すべき場合">親コンポーネントで判定すべき場合</h3>
<ol>
<li>
<p><strong>ビジネスロジックに関わる条件</strong></p>
<pre><code class="language-tsx">const OrderPage = () => {
  const { order } = useOrder();
  // 注文状態は親のビジネスロジック
  const canShowShippingInfo = order.status === 'shipped';
  
  return (
    &#x3C;div>
      {canShowShippingInfo &#x26;&#x26; &#x3C;ShippingInfo orderId={order.id} />}
    &#x3C;/div>
  );
};
</code></pre>
</li>
<li>
<p><strong>画面固有の表示制御</strong></p>
<pre><code class="language-tsx">const Dashboard = () => {
  const [activeTab, setActiveTab] = useState('overview');
  // タブ表示は画面固有のUI制御
  return (
    &#x3C;div>
      {activeTab === 'analytics' &#x26;&#x26; &#x3C;AnalyticsChart />}
    &#x3C;/div>
  );
};
</code></pre>
</li>
</ol>
<h2 id="typescriptでの型安全な実装">TypeScriptでの型安全な実装</h2>
<p>条件分岐を子コンポーネントで行う場合の型安全な実装例：</p>
<pre><code class="language-tsx">// APIレスポンスの型定義
type AppMetadata = {
  minimumAppVersion: string;
  isShowShippingDelayNotice: boolean;
  shippingDelayNoticeText: string;
};

// オプショナルチェーニングを活用した安全な条件判定
const ShippingDelayNotice = () => {
  const { metadata } = useAppMetadata();
  
  // TypeScriptの型システムと組み合わせた安全な判定
  const isShowNotice = metadata?.isShowShippingDelayNotice &#x26;&#x26; 
                      metadata?.shippingDelayNoticeText;

  // 発送遅延通知フラグがfalseまたはテキストを取得できていない場合は何も表示しない
  if (!isShowNotice) {
    return null;
  }

  return (
    &#x3C;View style={styles.container}>
      &#x3C;Text style={styles.text}>
        {/* この時点でmetadata.shippingDelayNoticeTextは存在することが保証されている */}
        {metadata.shippingDelayNoticeText}
      &#x3C;/Text>
    &#x3C;/View>
  );
};
</code></pre>
<h2 id="オプショナルチェーニングの重要性">オプショナルチェーニング（?.）の重要性</h2>
<p>APIから取得したデータの条件判定では、オプショナルチェーニングが重要な役割を果たします：</p>
<pre><code class="language-tsx">// ❌ unsafe - metadataがnullの場合エラー
if (metadata.isShowShippingDelayNotice &#x26;&#x26; metadata.shippingDelayNoticeText) {
  // TypeError: Cannot read property 'isShowShippingDelayNotice' of null
}

// ✅ safe - metadataがnull/undefinedでも安全
if (metadata?.isShowShippingDelayNotice &#x26;&#x26; metadata?.shippingDelayNoticeText) {
  // metadataがnullの場合、undefinedが返される
}
</code></pre>
<p><strong>解説：</strong></p>
<ul>
<li><code>metadata?.isShowShippingDelayNotice</code> は metadata が null/undefined の場合に undefined を返す</li>
<li><code>&#x26;&#x26;</code> 演算子により、左辺が falsy な場合は右辺を評価しない</li>
<li>この組み合わせで安全な条件判定が実現できる</li>
</ul>
<h2 id="テスト観点での考慮事項">テスト観点での考慮事項</h2>
<h3 id="子コンポーネントで判定する場合のテスト">子コンポーネントで判定する場合のテスト</h3>
<pre><code class="language-tsx">// APIモックを使った統合テスト
describe('ShippingDelayNotice', () => {
  it('フラグがtrueでテキストがある場合に表示される', async () => {
    // APIレスポンスをモック
    const mockMetadata = {
      isShowShippingDelayNotice: true,
      shippingDelayNoticeText: '発送が遅延しています'
    };
    
    jest.mocked(useAppMetadata).mockReturnValue({
      metadata: mockMetadata,
      isLoading: false,
      error: null
    });

    const { getByText } = render(&#x3C;ShippingDelayNotice />);
    expect(getByText('発送が遅延しています')).toBeInTheDocument();
  });

  it('フラグがfalseの場合は表示されない', () => {
    const mockMetadata = {
      isShowShippingDelayNotice: false,
      shippingDelayNoticeText: '発送が遅延しています'
    };
    
    jest.mocked(useAppMetadata).mockReturnValue({
      metadata: mockMetadata,
      isLoading: false,
      error: null
    });

    const { container } = render(&#x3C;ShippingDelayNotice />);
    expect(container.firstChild).toBeNull();
  });

  it('テキストが空文字の場合は表示されない', () => {
    const mockMetadata = {
      isShowShippingDelayNotice: true,
      shippingDelayNoticeText: ''
    };
    
    jest.mocked(useAppMetadata).mockReturnValue({
      metadata: mockMetadata,
      isLoading: false,
      error: null
    });

    const { container } = render(&#x3C;ShippingDelayNotice />);
    expect(container.firstChild).toBeNull();
  });
});
</code></pre>
<h2 id="実際の開発での判断フロー">実際の開発での判断フロー</h2>
<p>条件分岐の配置を決める際の判断フローチャート：</p>
<pre><code>1. この条件はコンポーネント固有のものか？
   YES → 子コンポーネントで判定
   NO → 次へ

2. 複数箇所で同じ条件を使用するか？
   YES → 子コンポーネントで判定
   NO → 次へ

3. 画面やビジネスロジック固有の条件か？
   YES → 親コンポーネントで判定
   NO → プロジェクト方針に従う
</code></pre>
<h2 id="結論">結論</h2>
<p><strong>推奨：子コンポーネント内での条件判定</strong></p>
<p>今回の発送遅延通知のような場合、以下の理由から子コンポーネント内での判定が適している：</p>
<ol>
<li><strong>保守性</strong>: 条件変更時の影響範囲が限定的</li>
<li><strong>再利用性</strong>: 他画面での利用時に実装が簡単</li>
<li><strong>責任の明確化</strong>: コンポーネント自身が表示条件を管理</li>
<li><strong>DRY原則</strong>: 条件判定ロジックの重複を防止</li>
</ol>
<p>ただし、画面固有のビジネスロジックや複雑な状態管理が絡む場合は、親コンポーネントでの判定も有効です。重要なのは、プロジェクトのアーキテクチャと要件に応じて一貫した方針を採用することです。</p>
<h2 id="まとめのポイント">まとめのポイント</h2>
<ul>
<li><strong>コンポーネント固有の条件</strong>は子コンポーネントで判定する</li>
<li><strong>DRY原則</strong>を重視して重複コードを避ける</li>
<li><strong>TypeScript</strong>とオプショナルチェーニングで型安全性を確保</li>
<li><strong>テストしやすさ</strong>も考慮してアーキテクチャを決定する</li>
<li><strong>一貫性</strong>のある方針をプロジェクト全体で採用する</li>
</ul>
<p>適切な条件分岐の配置により、保守性が高く拡張しやすいReactアプリケーションを構築できます。</p>
<h2 id="参考記事">参考記事</h2>
<ul>
<li><a href="https://react.dev/learn/conditional-rendering">React 公式ドキュメント - 条件付きレンダー</a></li>
<li><a href="https://www.patterns.dev/posts/react-design-patterns">React Design Patterns and Best Practices</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#optional-properties">TypeScript 公式ドキュメント - Optional Chaining</a></li>
</ul>4:["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","h1",null,{"className":"text-3xl font-bold mb-2","children":[["$","span",null,{"className":"text-green-600","children":["#",100]}]," ","React コンポーネントの条件分岐レンダリング：判定ロジックはどこに配置するべきか"]}],["$","ul",null,{"className":"list-none border-b border-gray-600 pb-4 mb-6","children":[["$","li",null,{"className":"text-gray-500 text-sm","children":["作成日時: ","2025-09-05 13:19"]}],["$","li",null,{"className":"text-gray-500 text-sm","children":["更新日時: ","2025-09-05 13:19"]}],["$","li",null,{"className":"flex flex-wrap gap-2 mt-2","children":[["$","span","0",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"React"}],["$","span","1",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"TypeScript"}],["$","span","2",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"条件分岐"}],["$","span","3",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"アーキテクチャ"}],["$","span","4",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"ベストプラクティス"}]]}]]}],["$","nav",null,{"className":"mb-6 pb-4 border-b border-gray-700 flex justify-between","children":[["$","$L12",null,{"href":"/","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"← ホームへ"}],["$","$L12",null,{"href":"/blog","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"記事一覧へ →"}]]}],["$","article",null,{"className":"prose dark:prose-invert","dangerouslySetInnerHTML":{"__html":"$13"}}],["$","$L14",null,{}],["$","nav",null,{"className":"mt-8 pt-4 border-t border-gray-700 flex justify-between","children":[["$","$L12",null,{"href":"/","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"← ホームへ"}],["$","$L12",null,{"href":"/blog","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"記事一覧へ →"}]]}],["$","$L15",null,{}]]}]
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
11:{"metadata":[["$","title","0",{"children":"Maita Tomoya Dev IO"}],["$","meta","1",{"name":"description","content":"米田智哉の技術ブログ。キャッチアップしたことをメモします。"}]],"error":null,"digest":"$undefined"}
b:{"metadata":"$11:metadata","error":null,"digest":"$undefined"}
