1:"$Sreact.fragment"
2:I[87555,[],""]
3:I[31295,[],""]
5:I[59665,[],"MetadataBoundary"]
7:I[59665,[],"OutletBoundary"]
a:I[74911,[],"AsyncMetadataOutlet"]
c:I[59665,[],"ViewportBoundary"]
e:I[26614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/19bdf9af4d1ae4d4.css","style"]
0:{"P":null,"b":"KZrMisSdXyu7FDjuS9HOy","p":"","c":["","blog","webview-session-token-500-error",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","webview-session-token-500-error","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/19bdf9af4d1ae4d4.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":["$","link",null,{"rel":"icon","href":"/favicon.png","type":"image/png"}]}],["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","webview-session-token-500-error","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",["$","$L5",null,{"children":"$L6"}],null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","mmPZJYIo9Ygw8UnLDMpNP",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$e","$undefined"],"s":false,"S":true}
f:"$Sreact.suspense"
10:I[74911,[],"AsyncMetadata"]
6:["$","$f",null,{"fallback":null,"children":["$","$L10",null,{"promise":"$@11"}]}]
9:null
12:I[6874,["6874","static/chunks/6874-6c1ddde525f3893c.js","5953","static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js"],""]
14:I[31203,["6874","static/chunks/6874-6c1ddde525f3893c.js","5953","static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js"],"default"]
15:I[4197,["6874","static/chunks/6874-6c1ddde525f3893c.js","5953","static/chunks/app/blog/%5Bslug%5D/page-26397bcee018c1a3.js"],"default"]
13:T8b91,<h2 id="はじめに">はじめに</h2>
<p>モバイルアプリ開発において、WebViewを使用した機能実装は一般的な手法です。しかし、WebViewの認証管理は思わぬ落とし穴があり、今回はその典型的な問題である「<strong>トークン期限切れによる500エラー</strong>」について、実際に遭遇した問題と解決方法を共有します。</p>
<p>この記事では、React NativeアプリとRailsバックエンドを例に、WebViewにおけるセッション管理の複雑さと、その解決アプローチについて解説します。</p>
<h2 id="目次">目次</h2>
<ol>
<li><a href="#%E5%95%8F%E9%A1%8C%E3%81%AE%E6%A6%82%E8%A6%81">問題の概要</a></li>
<li><a href="#webview%E3%81%AE%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E7%8B%AC%E7%AB%8B%E6%80%A7">WebViewのセッション独立性</a></li>
<li><a href="#%E4%BA%8C%E9%87%8D%E8%AA%8D%E8%A8%BC%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF">二重認証システムの仕組み</a></li>
<li><a href="#500%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%8C%E7%99%BA%E7%94%9F%E3%81%99%E3%82%8B%E3%83%A1%E3%82%AB%E3%83%8B%E3%82%BA%E3%83%A0">500エラーが発生するメカニズム</a></li>
<li><a href="#%E5%95%8F%E9%A1%8C%E3%81%AE%E5%86%8D%E7%8F%BE%E6%96%B9%E6%B3%95">問題の再現方法</a></li>
<li><a href="#%E8%A7%A3%E6%B1%BA%E3%82%A2%E3%83%97%E3%83%AD%E3%83%BC%E3%83%81">解決アプローチ</a></li>
<li><a href="#%E5%AE%9F%E8%A3%85%E4%BE%8B">実装例</a></li>
<li><a href="#%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E8%80%83%E6%85%AE%E4%BA%8B%E9%A0%85">セキュリティ考慮事項</a></li>
<li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li>
</ol>
<h2 id="問題の概要">問題の概要</h2>
<p>あるECアプリで、以下のような問題が発生していました：</p>
<ul>
<li><strong>症状</strong>: アプリ内のWebView（ポイント購入画面など）で突然500エラーが発生</li>
<li><strong>頻度</strong>: 約100件/日</li>
<li><strong>タイミング</strong>: アプリ起動から約1時間後</li>
<li><strong>影響</strong>: ユーザーが決済できない、高額取引が中断される</li>
</ul>
<p>エラーログを確認すると、<code>TokenExpiredError</code>が原因でした。しかし、なぜトークンの期限切れが500エラーになるのでしょうか？</p>
<h2 id="webviewのセッション独立性">WebViewのセッション独立性</h2>
<h3 id="知っておくべき重要な事実">知っておくべき重要な事実</h3>
<p><strong>WebViewのセッションは、通常のブラウザ（Safari/Chrome）とは完全に独立しています。</strong></p>
<pre><code class="language-javascript">// この認識は間違い！
// ❌ ブラウザでログイン → WebViewでも自動的にログイン状態

// 実際の動作
// ✅ ブラウザでログイン → WebViewは未ログイン状態のまま
</code></pre>
<h3 id="なぜ独立しているのか">なぜ独立しているのか</h3>





















<table><thead><tr><th>理由</th><th>説明</th></tr></thead><tbody><tr><td><strong>セキュリティ</strong></td><td>アプリ間でCookieが共有されるとセキュリティリスクになる</td></tr><tr><td><strong>プライバシー</strong></td><td>ユーザーのブラウジング情報をアプリが取得できてしまう</td></tr><tr><td><strong>仕様</strong></td><td>iOS/AndroidのWebViewは意図的に独立設計</td></tr></tbody></table>
<h3 id="プラットフォーム別の挙動">プラットフォーム別の挙動</h3>
<pre><code class="language-javascript">// React Native WebViewの設定例
&#x3C;WebView
  source={{ uri: 'https://example.com' }}
  // iOSでのみ有効（Safariとクッキー共有）
  sharedCookiesEnabled={true}  
  // Androidでは効果なし
/>
</code></pre>
<h2 id="二重認証システムの仕組み">二重認証システムの仕組み</h2>
<p>今回の問題の根本原因は、<strong>セッションとトークンの二重管理</strong>にありました。</p>
<h3 id="システム構成図">システム構成図</h3>
<pre><code>┌─────────────────────────────────────────────────┐
│                  モバイルアプリ                     │
│                                                   │
│  ┌─────────────┐        ┌─────────────────┐    │
│  │   Native    │        │     WebView      │    │
│  │   Screen    │        │                  │    │
│  └─────────────┘        └─────────────────┘    │
│         ↓                        ↓               │
│   Firebase Auth            Authorization        │
│   (ID Token)               Header + Token       │
└─────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────┐
│                 Rails Backend                    │
│                                                  │
│   通常Web: Cookieセッション（1ヶ月有効）           │
│   WebView: Firebaseトークン（1時間有効）          │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 id="認証方式の比較">認証方式の比較</h3>
<pre><code class="language-ruby"># Rails側の認証処理（簡略化）
class ApplicationController &#x3C; ActionController::Base
  def current_user
    if is_webview_request?
      # WebViewからのアクセス
      authenticate_with_firebase_token
    else
      # 通常のWebアクセス
      authenticate_with_session
    end
  end
  
  private
  
  def is_webview_request?
    request.user_agent&#x26;.include?('MY-APP-WEBVIEW')
  end
  
  def authenticate_with_session
    User.find_by(id: session[:user_id])
  end
  
  def authenticate_with_firebase_token
    token = extract_bearer_token
    payload = decode_firebase_token(token)  # ここで例外発生！
    User.find_by(firebase_uid: payload['user_id'])
  end
end
</code></pre>
<h2 id="500エラーが発生するメカニズム">500エラーが発生するメカニズム</h2>
<h3 id="エラー発生のタイムライン">エラー発生のタイムライン</h3>
<div class="mermaid">timeline
    title トークン期限切れによる500エラー発生フロー
    
    0分   : アプリ起動・ログイン成功
          : Firebaseトークン発行（有効期限60分）
    
    30分  : WebView機能を使用
          : トークン有効・正常動作
    
    60分  : トークン有効期限切れ
          : （バックグラウンドで自動更新されず）
    
    65分  : WebViewでポイント購入画面を開く
          : 期限切れトークンをサーバーに送信
          : サーバーでトークン検証失敗
          : 500 Internal Server Error</div>
<h3 id="実際のエラーコード">実際のエラーコード</h3>
<pre><code class="language-ruby"># lib/firebase_token_decoder.rb
class FirebaseTokenDecoder
  class InvalidTokenError &#x3C; StandardError; end
  
  def decode(token)
    # JWTライブラリでデコード
    payload = JWT.decode(token, public_key, true, options)
    payload
  rescue JWT::ExpiredSignature => e
    # ❌ 問題: 期限切れを500エラーとして扱っていた
    raise InvalidTokenError, e.message
  rescue JWT::DecodeError => e
    raise InvalidTokenError, e.message
  end
end
</code></pre>
<h2 id="問題の再現方法">問題の再現方法</h2>
<h3 id="開発環境での再現手順">開発環境での再現手順</h3>
<pre><code class="language-bash"># 1. 期限切れトークンを模擬的に作成
expired_token="eyJhbGciOiJSUzI1NiIsImtpZCI6InRlc3QifQ.eyJleHAiOjE2MDk0NTkyMDAsInVpZCI6InRlc3QxMjMifQ.dummy"

# 2. WebViewのUser-Agentでリクエスト
curl -H "User-Agent: MY-APP-WEBVIEW" \
     -H "Authorization: Bearer $expired_token" \
     "http://localhost:3000/api/points"

# 結果: 500 Internal Server Error
</code></pre>
<h3 id="iosシミュレータでの確認">iOSシミュレータでの確認</h3>
<pre><code class="language-javascript">// React Native側のデバッグコード
const debugTokenExpiry = () => {
  // 強制的に古いトークンを使用
  const expiredToken = 'eyJhbGciOiJSUzI1Ni...'; // 1時間前のトークン
  
  return (
    &#x3C;WebView
      source={{ uri: 'https://example.com/points' }}
      injectedJavaScriptBeforeContentLoaded={`
        window.FIREBASE_TOKEN = '${expiredToken}';
      `}
    />
  );
};
</code></pre>
<h2 id="firebase-sdkの隠れた仕様---トークン自動更新の真実">Firebase SDKの隠れた仕様 - トークン自動更新の真実</h2>
<h3 id="重要な発見-5分前の自動更新メカニズム">重要な発見: 5分前の自動更新メカニズム</h3>
<p>Firebase SDKには、開発者があまり意識していない重要な仕様があります。</p>
<pre><code class="language-javascript">// getIdToken()の実際の動作
getIdToken(currentUser, false) // デフォルト
</code></pre>
<p><strong>実は以下の動作をします：</strong></p>
<ol>
<li><strong>キャッシュされたトークンを確認</strong></li>
<li><strong>トークンの有効期限が5分以上残っている → キャッシュを返す</strong></li>
<li><strong>トークンの有効期限が5分未満 → 自動的に新しいトークンを取得</strong></li>
</ol>
<p>つまり、完全に期限切れになる前に自動更新される仕組みがあります！</p>
<h3 id="情報源による裏付け">情報源による裏付け</h3>
<h4 id="1-firebase公式開発者の証言">1. Firebase公式開発者の証言</h4>
<p><strong>Peter Friese氏（Firebase Developer Advocate）によると：</strong></p>
<blockquote>
<p>"Firebase's client SDKs automatically handle refreshing the user's ID token. If the app is running, the SDK will retrieve a new ID token (using the refresh token) about 5 minutes before the ID token expires."</p>
</blockquote>
<p><strong>Frank van Puffelen氏（Firebase公式）もStack Overflowで明確に述べています：</strong></p>
<blockquote>
<p>"The Firebase Authentication SDK automatically refreshes the ID token about 5 minutes before it expires, and getIdToken() always gives you the latest token."</p>
<p>出典: <a href="https://stackoverflow.com/questions/78127324/how-to-refresh-firebase-access-token-using-next-auth-credentials-provider">How to refresh firebase access token using next-auth credentials provider? - Stack Overflow</a></p>
</blockquote>
<h4 id="2-getidtokenメソッドの動作詳細">2. getIdToken()メソッドの動作詳細</h4>




















<table><thead><tr><th>パラメータ</th><th>動作</th><th>使用場面</th></tr></thead><tbody><tr><td><code>forceRefresh: false</code>（デフォルト）</td><td>- 有効期限が5分以上ある場合：キャッシュを返す<br>- 有効期限が5分未満：自動更新<br>- 期限切れ：新しいトークンを取得</td><td>通常の使用</td></tr><tr><td><code>forceRefresh: true</code></td><td>有効期限に関わらず新しいトークンを強制取得</td><td>特別な場合のみ</td></tr></tbody></table>
<h3 id="自動更新が発生する条件">自動更新が発生する条件</h3>
<pre><code class="language-javascript">// 自動更新のタイミングを可視化
class TokenRefreshMonitor {
  constructor() {
    this.checkInterval = 60000; // 1分ごとにチェック
  }
  
  async monitorTokenStatus() {
    const user = auth().currentUser;
    if (!user) return;
    
    const token = await user.getIdToken();
    const decoded = this.decodeJWT(token);
    const now = Date.now() / 1000;
    const timeToExpiry = decoded.exp - now;
    
    console.log({
      status: this.getTokenStatus(timeToExpiry),
      minutesRemaining: Math.floor(timeToExpiry / 60),
      willAutoRefresh: timeToExpiry &#x3C; 300, // 5分未満で自動更新
      timestamp: new Date().toISOString()
    });
  }
  
  getTokenStatus(secondsRemaining) {
    if (secondsRemaining > 300) return '✅ 有効（キャッシュ使用）';
    if (secondsRemaining > 0) return '⚠️ 自動更新ゾーン';
    return '❌ 期限切れ';
  }
  
  decodeJWT(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    return JSON.parse(atob(base64));
  }
}
</code></pre>
<h3 id="実際の動作フロー">実際の動作フロー</h3>
<div class="mermaid">graph TD
    A[getIdToken呼び出し] --&gt; B{トークンの状態確認}
    B --&gt;|有効期限 &gt; 5分| C[キャッシュされたトークンを返す]
    B --&gt;|有効期限 &lt; 5分| D[新しいトークンを自動取得]
    B --&gt;|期限切れ| E[新しいトークンを取得]
    D --&gt; F[新しいトークンをキャッシュ]
    E --&gt; F
    F --&gt; G[トークンを返す]
    C --&gt; G</div>
<h3 id="なぜこの仕様が重要なのか">なぜこの仕様が重要なのか</h3>
<ol>
<li>
<p><strong>パフォーマンスの最適化</strong></p>
<ul>
<li>不要なネットワーク通信を削減</li>
<li>サーバー負荷の軽減</li>
</ul>
</li>
<li>
<p><strong>シームレスな体験</strong></p>
<ul>
<li>ユーザーが意識せずに継続利用可能</li>
<li>期限切れによる中断を防ぐ</li>
</ul>
</li>
<li>
<p><strong>開発者の負担軽減</strong></p>
<ul>
<li>手動でのトークン管理が不要</li>
<li>複雑なリフレッシュロジックの実装が不要</li>
</ul>
</li>
</ol>
<h3 id="ベストプラクティス実装例">ベストプラクティス実装例</h3>
<pre><code class="language-javascript">// 推奨される実装パターン
class OptimizedTokenManager {
  constructor() {
    this.tokenCache = null;
    this.lastRefresh = null;
  }
  
  async getToken() {
    const user = auth().currentUser;
    if (!user) throw new Error('User not authenticated');
    
    // Firebase SDKの自動更新に任せる（forceRefresh: false）
    // 5分前になると自動的に新しいトークンを取得
    const token = await user.getIdToken(/* forceRefresh */ false);
    
    // デバッグ用：トークンの状態をログ出力
    if (__DEV__) {
      this.logTokenStatus(token);
    }
    
    return token;
  }
  
  // 強制更新が必要な特別なケースのみ
  async forceRefreshToken() {
    const user = auth().currentUser;
    if (!user) throw new Error('User not authenticated');
    
    console.log('⚠️ 強制的にトークンを更新します');
    return await user.getIdToken(/* forceRefresh */ true);
  }
  
  logTokenStatus(token) {
    const decoded = this.decodeJWT(token);
    const now = Date.now() / 1000;
    const remaining = decoded.exp - now;
    
    console.log('🔐 Token Status:', {
      expiresIn: `${Math.floor(remaining / 60)}分${Math.floor(remaining % 60)}秒`,
      autoRefreshActive: remaining &#x3C; 300,
      tokenAge: this.lastRefresh ? 
        `${Math.floor((Date.now() - this.lastRefresh) / 1000)}秒` : '初回取得'
    });
    
    this.lastRefresh = Date.now();
  }
  
  decodeJWT(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    return JSON.parse(atob(base64));
  }
}

// 使用例
const tokenManager = new OptimizedTokenManager();

// 通常のAPI呼び出し時
async function callAPI(endpoint, data) {
  try {
    // Firebase SDKの自動更新メカニズムを活用
    const token = await tokenManager.getToken();
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });
    
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
}
</code></pre>
<h3 id="注意点とトラブルシューティング">注意点とトラブルシューティング</h3>
<h4 id="自動更新が機能しないケース">自動更新が機能しないケース</h4>
<ol>
<li>
<p><strong>アプリがバックグラウンドにある場合</strong></p>
<pre><code class="language-javascript">// アプリがフォアグラウンドに戻った時の処理
AppState.addEventListener('change', (nextAppState) => {
  if (nextAppState === 'active') {
    // トークンの状態を確認し、必要なら更新
    tokenManager.getToken();
  }
});
</code></pre>
</li>
<li>
<p><strong>ネットワーク接続が不安定な場合</strong></p>
<pre><code class="language-javascript">// リトライロジックの実装
async function getTokenWithRetry(maxRetries = 3) {
  for (let i = 0; i &#x3C; maxRetries; i++) {
    try {
      return await auth().currentUser.getIdToken();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}
</code></pre>
</li>
<li>
<p><strong>Firebase SDKのバージョンが古い場合</strong></p>
<pre><code class="language-json">// package.jsonで最新バージョンを使用
{
  "dependencies": {
    "@react-native-firebase/auth": "^18.0.0"
  }
}
</code></pre>
</li>
</ol>
<h2 id="解決アプローチ">解決アプローチ</h2>
<h3 id="アプローチ1-エラーハンドリングの改善短期対策">アプローチ1: エラーハンドリングの改善（短期対策）</h3>
<pre><code class="language-ruby"># 修正版: 期限切れと無効トークンを区別
class FirebaseTokenDecoder
  class InvalidTokenError &#x3C; StandardError; end
  class ExpiredTokenError &#x3C; StandardError; end  # 新規追加
  
  def decode(token)
    payload = JWT.decode(token, public_key, true, options)
    payload
  rescue JWT::ExpiredSignature => e
    # ✅ 期限切れは別の例外として扱う
    Rails.logger.info "Token expired: #{e.message}"
    raise ExpiredTokenError, e.message
  rescue JWT::DecodeError => e
    raise InvalidTokenError, e.message
  end
end

# コントローラー側の処理
def authenticate_with_firebase_token
  begin
    token = extract_bearer_token
    payload = decode_firebase_token(token)
    User.find_by(firebase_uid: payload['user_id'])
  rescue FirebaseTokenDecoder::ExpiredTokenError => e
    # ✅ 期限切れの場合は graceful に処理
    handle_expired_token
  rescue FirebaseTokenDecoder::InvalidTokenError => e
    # 本当に無効なトークンの場合のみエラー
    render_unauthorized
  end
end

def handle_expired_token
  # セッションベースの認証にフォールバック
  if current_session_user.present?
    # 既存セッションで継続
    response.headers['X-Token-Expired'] = 'true'
    return current_session_user
  else
    # セッションもない場合は401
    render json: { error: 'Token expired' }, status: :unauthorized
  end
end
</code></pre>
<h3 id="アプローチ2-トークン自動更新中期対策">アプローチ2: トークン自動更新（中期対策）</h3>
<pre><code class="language-javascript">// React Native側: トークンの自動更新
import auth from '@react-native-firebase/auth';

class TokenManager {
  constructor() {
    this.token = null;
    this.tokenExpiry = null;
  }
  
  async getValidToken() {
    const now = Date.now();
    
    // トークンが存在し、期限まで5分以上ある場合はそのまま使用
    if (this.token &#x26;&#x26; this.tokenExpiry &#x26;&#x26; (this.tokenExpiry - now) > 5 * 60 * 1000) {
      return this.token;
    }
    
    // トークンを更新
    const user = auth().currentUser;
    if (user) {
      this.token = await user.getIdToken(true);
      // JWTをデコードして有効期限を取得
      const payload = this.decodeJWT(this.token);
      this.tokenExpiry = payload.exp * 1000;
      return this.token;
    }
    
    throw new Error('User not authenticated');
  }
  
  decodeJWT(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    return JSON.parse(atob(base64));
  }
}

// WebView使用時
const MyWebView = () => {
  const [token, setToken] = useState(null);
  const tokenManager = new TokenManager();
  
  useEffect(() => {
    // 初回トークン取得
    tokenManager.getValidToken().then(setToken);
    
    // 30分ごとにトークンを更新
    const interval = setInterval(() => {
      tokenManager.getValidToken().then(setToken);
    }, 30 * 60 * 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    &#x3C;WebView
      source={{ uri: 'https://example.com/points' }}
      injectedJavaScriptBeforeContentLoaded={`
        window.FIREBASE_TOKEN = '${token}';
        
        // Fetchをオーバーライドしてトークンを自動付与
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
          const [url, options = {}] = args;
          options.headers = {
            ...options.headers,
            'Authorization': 'Bearer ' + window.FIREBASE_TOKEN
          };
          return originalFetch.call(this, url, options);
        };
      `}
    />
  );
};
</code></pre>
<h3 id="アプローチ3-webviewとの通信強化長期対策">アプローチ3: WebViewとの通信強化（長期対策）</h3>
<pre><code class="language-javascript">// WebViewとネイティブ間でメッセージングを使用
const EnhancedWebView = () => {
  const webViewRef = useRef(null);
  
  const handleMessage = async (event) => {
    const { type, data } = JSON.parse(event.nativeEvent.data);
    
    switch (type) {
      case 'TOKEN_REFRESH_NEEDED':
        // トークンを更新してWebViewに送信
        const newToken = await auth().currentUser.getIdToken(true);
        webViewRef.current.postMessage(JSON.stringify({
          type: 'NEW_TOKEN',
          token: newToken
        }));
        break;
        
      case 'AUTH_ERROR':
        // 認証エラーの場合は再ログイン画面へ
        navigation.navigate('Login');
        break;
    }
  };
  
  return (
    &#x3C;WebView
      ref={webViewRef}
      source={{ uri: 'https://example.com/points' }}
      onMessage={handleMessage}
      injectedJavaScript={`
        // WebView内でのトークン管理
        class TokenHandler {
          constructor() {
            this.token = window.INITIAL_TOKEN;
          }
          
          checkTokenExpiry() {
            try {
              const payload = JSON.parse(atob(this.token.split('.')[1]));
              const now = Date.now() / 1000;
              
              if (payload.exp - now &#x3C; 300) { // 5分前
                // ネイティブ側にトークン更新を要求
                window.ReactNativeWebView.postMessage(JSON.stringify({
                  type: 'TOKEN_REFRESH_NEEDED'
                }));
              }
            } catch (e) {
              console.error('Token check failed:', e);
            }
          }
          
          updateToken(newToken) {
            this.token = newToken;
            // 既存のリクエストヘッダーを更新
            this.updateAuthHeaders();
          }
        }
        
        const tokenHandler = new TokenHandler();
        
        // 3分ごとにトークンをチェック
        setInterval(() => tokenHandler.checkTokenExpiry(), 3 * 60 * 1000);
        
        // ネイティブからのメッセージを受信
        window.addEventListener('message', (event) => {
          const data = JSON.parse(event.data);
          if (data.type === 'NEW_TOKEN') {
            tokenHandler.updateToken(data.token);
          }
        });
      `}
    />
  );
};
</code></pre>
<h2 id="セキュリティ考慮事項">セキュリティ考慮事項</h2>
<h3 id="トークン期限切れ時の判断基準">トークン期限切れ時の判断基準</h3>
<pre><code class="language-ruby"># セキュリティとUXのバランスを考慮した実装
class TokenExpiryHandler
  # 最後のアクティビティから30分以内なら継続を許可
  GRACE_PERIOD = 30.minutes
  
  def handle_expired_token(session, user)
    last_activity = session[:last_activity_at]
    
    if last_activity &#x26;&#x26; Time.current - last_activity &#x3C; GRACE_PERIOD
      # アクティブなユーザーは継続利用可能
      log_security_event(:token_expired_but_active, user)
      session[:last_activity_at] = Time.current
      return :continue_with_grace
    else
      # 非アクティブなユーザーは再認証
      log_security_event(:token_expired_and_inactive, user)
      return :require_reauth
    end
  end
  
  private
  
  def log_security_event(event_type, user)
    SecurityAuditLog.create!(
      event: event_type,
      user: user,
      ip_address: request.remote_ip,
      user_agent: request.user_agent,
      timestamp: Time.current
    )
  end
end
</code></pre>
<h3 id="セキュリティチェックリスト">セキュリティチェックリスト</h3>
<p>✅ <strong>実装時に確認すべき項目</strong></p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> トークンの有効期限は適切か（1時間は妥当）</li>
<li class="task-list-item"><input type="checkbox" disabled> 期限切れトークンのログは適切に記録されているか</li>
<li class="task-list-item"><input type="checkbox" disabled> 不正なトークンと期限切れトークンを区別しているか</li>
<li class="task-list-item"><input type="checkbox" disabled> フォールバック時のセキュリティリスクを評価したか</li>
<li class="task-list-item"><input type="checkbox" disabled> 監査ログを適切に出力しているか</li>
</ul>
<h2 id="ハンズオン-実際に試してみよう">ハンズオン: 実際に試してみよう</h2>
<h3 id="環境構築">環境構築</h3>
<pre><code class="language-bash"># 1. サンプルプロジェクトのクローン
git clone https://github.com/example/webview-auth-sample.git
cd webview-auth-sample

# 2. バックエンド（Rails）のセットアップ
cd backend
bundle install
rails db:create db:migrate
rails server

# 3. フロントエンド（React Native）のセットアップ
cd ../mobile
npm install
cd ios &#x26;&#x26; pod install &#x26;&#x26; cd ..
npm run ios
</code></pre>
<h3 id="デバッグ用のコード">デバッグ用のコード</h3>
<pre><code class="language-javascript">// デバッグ用: トークンの状態を可視化
const TokenDebugger = () => {
  const [tokenInfo, setTokenInfo] = useState(null);
  
  useEffect(() => {
    const checkToken = async () => {
      const user = auth().currentUser;
      if (user) {
        const token = await user.getIdToken();
        const decoded = JSON.parse(atob(token.split('.')[1]));
        
        setTokenInfo({
          uid: decoded.user_id,
          exp: new Date(decoded.exp * 1000).toLocaleString(),
          remaining: Math.floor((decoded.exp * 1000 - Date.now()) / 1000 / 60) + '分'
        });
      }
    };
    
    checkToken();
    const interval = setInterval(checkToken, 10000); // 10秒ごと
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    &#x3C;View style={styles.debugContainer}>
      &#x3C;Text>UID: {tokenInfo?.uid}&#x3C;/Text>
      &#x3C;Text>有効期限: {tokenInfo?.exp}&#x3C;/Text>
      &#x3C;Text>残り時間: {tokenInfo?.remaining}&#x3C;/Text>
    &#x3C;/View>
  );
};
</code></pre>
<h2 id="よくある質問faq">よくある質問（FAQ）</h2>
<h3 id="q1-なぜwebviewでセッションを共有できないのか">Q1: なぜWebViewでセッションを共有できないのか？</h3>
<p><strong>A</strong>: セキュリティとプライバシーの観点から、モバイルOSはWebViewとシステムブラウザのCookie/セッションを意図的に分離しています。これにより、悪意のあるアプリがユーザーのブラウジングデータにアクセスすることを防いでいます。</p>
<h3 id="q2-トークンの有効期限を延ばせばいいのでは">Q2: トークンの有効期限を延ばせばいいのでは？</h3>
<p><strong>A</strong>: Firebase Authenticationのトークン有効期限は1時間で固定されており、変更できません。これはセキュリティベストプラクティスに基づく設計です。代わりに、リフレッシュトークンを使用した自動更新を実装すべきです。</p>
<h3 id="q3-401エラーではなく500エラーになるのはなぜ">Q3: 401エラーではなく500エラーになるのはなぜ？</h3>
<p><strong>A</strong>: 実装の問題です。トークン検証の例外処理が適切でなく、すべての例外を内部エラーとして扱っていたためです。期限切れ（401）と内部エラー（500）を適切に区別する必要があります。</p>
<h2 id="パフォーマンスへの影響">パフォーマンスへの影響</h2>
<h3 id="トークン更新のオーバーヘッド">トークン更新のオーバーヘッド</h3>
<pre><code class="language-javascript">// パフォーマンス測定
const measureTokenRefresh = async () => {
  const iterations = 100;
  const times = [];
  
  for (let i = 0; i &#x3C; iterations; i++) {
    const start = performance.now();
    await auth().currentUser.getIdToken(true);
    const end = performance.now();
    times.push(end - start);
  }
  
  console.log({
    average: times.reduce((a, b) => a + b) / times.length,
    min: Math.min(...times),
    max: Math.max(...times)
  });
};

// 実測値（例）
// {
//   average: 245.3,  // ミリ秒
//   min: 180.5,
//   max: 520.1
// }
</code></pre>
<h3 id="推奨される更新戦略">推奨される更新戦略</h3>





























<table><thead><tr><th>戦略</th><th>更新タイミング</th><th>メリット</th><th>デメリット</th></tr></thead><tbody><tr><td><strong>Proactive</strong></td><td>50分ごと</td><td>エラーが発生しない</td><td>無駄な通信が発生</td></tr><tr><td><strong>Reactive</strong></td><td>エラー時のみ</td><td>通信量が最小</td><td>初回エラーは避けられない</td></tr><tr><td><strong>Hybrid</strong></td><td>55分経過 or エラー時</td><td>バランスが良い</td><td>実装が複雑</td></tr></tbody></table>
<h2 id="まとめ">まとめ</h2>
<h3 id="学んだこと">学んだこと</h3>
<ol>
<li>
<p><strong>WebViewのセッションは独立している</strong></p>
<ul>
<li>ブラウザのセッションを期待してはいけない</li>
<li>独自の認証メカニズムが必要</li>
</ul>
</li>
<li>
<p><strong>エラーハンドリングの重要性</strong></p>
<ul>
<li>期限切れと無効を区別する</li>
<li>500エラーは避け、適切なステータスコードを返す</li>
</ul>
</li>
<li>
<p><strong>UXとセキュリティのバランス</strong></p>
<ul>
<li>完全にブロックするとUXが悪化</li>
<li>適切なフォールバックとグレースピリオドの設定</li>
</ul>
</li>
</ol>
<h3 id="ベストプラクティス">ベストプラクティス</h3>
<pre><code class="language-javascript">// ✅ 推奨される実装パターン
const WebViewAuthPattern = {
  // 1. トークンの自動更新
  autoRefresh: true,
  refreshInterval: 30 * 60 * 1000, // 30分
  
  // 2. エラーハンドリング
  handleTokenExpiry: 'graceful', // 'strict' | 'graceful'
  
  // 3. フォールバック
  fallbackAuth: 'session', // 'session' | 'reauth' | 'none'
  
  // 4. 監査ログ
  auditLogging: true,
  
  // 5. ユーザー通知
  notifyUser: false // エラー時にユーザーに通知するか
};
</code></pre>
<h3 id="今後の展望">今後の展望</h3>
<ol>
<li>
<p><strong>WebView依存の削減</strong></p>
<ul>
<li>可能な限りネイティブ実装に移行</li>
<li>WebViewは最小限の使用に留める</li>
</ul>
</li>
<li>
<p><strong>統一認証基盤の構築</strong></p>
<ul>
<li>セッションとトークンの一元管理</li>
<li>より柔軟な認証フロー</li>
</ul>
</li>
<li>
<p><strong>エラー監視の強化</strong></p>
<ul>
<li>リアルタイムでのエラー検知</li>
<li>自動リカバリーメカニズム</li>
</ul>
</li>
</ol>
<h2 id="参考資料">参考資料</h2>
<h3 id="firebase認証とトークン管理">Firebase認証とトークン管理</h3>
<ul>
<li><a href="https://firebase.google.com/docs/reference/rest/auth">Firebase Authentication REST API Reference</a></li>
<li><a href="https://firebase.google.com/docs/auth/admin/manage-sessions">Manage User Sessions | Firebase Authentication</a></li>
<li><a href="https://firebase.google.com/docs/auth/admin/verify-id-tokens">Verify ID Tokens | Firebase Authentication</a></li>
<li><a href="https://x.com/peterfriese/status/1509425270603792385">Peter Friese (Firebase Developer) on Token Refresh</a></li>
<li><a href="https://stackoverflow.com/questions/78127324/how-to-refresh-firebase-access-token-using-next-auth-credentials-provider">Frank van Puffelen answer on Token Auto-refresh - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/49656489/is-the-firebase-access-token-refreshed-automatically">Firebase Token Auto-refresh Discussion - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/76929017/firebase-auth-when-are-tokens-refreshed">Firebase Auth - When are tokens refreshed? - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/74344333/best-practice-to-get-users-idtoken-from-firebase-using-getidtoken-forceref">Best practice for getIdToken usage - Stack Overflow</a></li>
</ul>
<h3 id="webview実装">WebView実装</h3>
<ul>
<li><a href="https://github.com/react-native-webview/react-native-webview/blob/master/docs/Guide.md">React Native WebView Documentation</a></li>
<li><a href="https://developer.apple.com/documentation/webkit/wkwebview">iOS WKWebView Documentation</a></li>
<li><a href="https://developer.android.com/reference/android/webkit/WebView">Android WebView Documentation</a></li>
</ul>
<h3 id="バックエンド実装">バックエンド実装</h3>
<ul>
<li><a href="https://guides.rubyonrails.org/action_controller_overview.html#session">Rails Action Controller Overview - Sessions</a></li>
<li><a href="https://jwt.io/introduction">JWT.io - JSON Web Tokens Introduction</a></li>
</ul>
<h3 id="セキュリティ">セキュリティ</h3>
<ul>
<li><a href="https://owasp.org/www-project-mobile-security-testing-guide/">OWASP Mobile Security Testing Guide</a></li>
</ul>
<h2 id="著者について">著者について</h2>
<p>Webアプリケーションとモバイルアプリのハイブリッド開発に従事しているエンジニアです。認証システムの複雑性と戦いながら、より良いユーザー体験を提供するための方法を日々模索しています。</p>
<hr>
<p>この記事が、同じような問題に直面している方の助けになれば幸いです。質問やフィードバックがありましたら、お気軽にコメントください。</p>4:["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","h1",null,{"className":"text-3xl font-bold mb-2","children":[["$","span",null,{"className":"text-green-600","children":["#","$undefined"]}]," ","WebViewで発生する500エラーの真相 - セッションとトークンの二重管理問題を解決する"]}],["$","ul",null,{"className":"list-none border-b border-gray-600 pb-4 mb-6","children":[["$","li",null,{"className":"text-gray-500 text-sm","children":["作成日時: ","2025-09-12 19:53"]}],["$","li",null,{"className":"text-gray-500 text-sm","children":["更新日時: ","2025-09-12 21:30"]}],["$","li",null,{"className":"flex flex-wrap gap-2 mt-2","children":[["$","span","0",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"WebView"}],["$","span","1",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"React Native"}],["$","span","2",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"Rails"}],["$","span","3",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"Firebase"}],["$","span","4",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"認証"}],["$","span","5",{"className":"px-2 py-1 bg-gray-800 text-gray-300 rounded text-xs","children":"セッション管理"}]]}]]}],["$","nav",null,{"className":"mb-6 pb-4 border-b border-gray-700 flex justify-between","children":[["$","$L12",null,{"href":"/","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"← ホームへ"}],["$","$L12",null,{"href":"/blog","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"記事一覧へ →"}]]}],["$","article",null,{"className":"prose dark:prose-invert","dangerouslySetInnerHTML":{"__html":"$13"}}],["$","$L14",null,{}],["$","nav",null,{"className":"mt-8 pt-4 border-t border-gray-700 flex justify-between","children":[["$","$L12",null,{"href":"/","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"← ホームへ"}],["$","$L12",null,{"href":"/blog","className":"text-blue-400 hover:text-blue-300 hover:underline","children":"記事一覧へ →"}]]}],["$","$L15",null,{}]]}]
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
11:{"metadata":[["$","title","0",{"children":"Maita Tomoya Dev IO"}],["$","meta","1",{"name":"description","content":"米田智哉の技術ブログ。キャッチアップしたことをメモします。"}]],"error":null,"digest":"$undefined"}
b:{"metadata":"$11:metadata","error":null,"digest":"$undefined"}
