<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/21fca20b31fba572.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-29ebadaebe2fcb3f.js"/><script src="/_next/static/chunks/4bd1b696-d8f047cced1b4886.js" async=""></script><script src="/_next/static/chunks/684-8e4d9e1e4139006e.js" async=""></script><script src="/_next/static/chunks/main-app-d1c324b32b03123c.js" async=""></script><script src="/_next/static/chunks/874-8d3839f72fd80c3c.js" async=""></script><script src="/_next/static/chunks/app/note/webpage-temp/%5Bid%5D/page-4b841b09f124fe29.js" async=""></script><meta name="next-size-adjust" content=""/><link rel="icon" href="/favicon.png" type="image/png"/><title>Maita Tomoya Dev IO</title><meta name="description" content="米田智哉の技術ブログ。キャッチアップしたことをメモします。"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 antialiased"><div class="min-h-screen bg-gray-900 text-gray-100"><div class="max-w-7xl mx-auto py-10 px-4"><nav class="mb-6 flex gap-4"><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/">ホーム</a><span class="text-gray-500">/</span><a class="text-blue-400 hover:text-blue-300 hover:underline" href="/note/webpage-temp/">テンプレート一覧</a><span class="text-gray-500">/</span><span class="text-gray-400">3D テトリスゲーム</span></nav><div class="mb-8"><div class="flex items-center gap-4 mb-4"><h1 class="text-3xl font-bold">3D テトリスゲーム</h1><span class="px-3 py-1 bg-blue-600 text-white rounded text-sm">3D Graphics</span></div><p class="text-gray-300 text-lg mb-4">Three.jsで作る立体的なテトリス。クラシックなゲームを3D空間で楽しもう！</p><div class="flex flex-wrap gap-2 mb-4"><span class="px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm">✓ <!-- -->3D空間でのテトリス</span><span class="px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm">✓ <!-- -->キーボード操作（矢印キー、スペース）</span><span class="px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm">✓ <!-- -->スコアとレベルシステム</span><span class="px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm">✓ <!-- -->次のブロック表示</span><span class="px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm">✓ <!-- -->ゲームオーバー判定</span><span class="px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm">✓ <!-- -->パーティクルエフェクト</span></div><div class="flex flex-wrap gap-2 mb-6"><span class="text-sm text-gray-500">#<!-- -->three.js</span><span class="text-sm text-gray-500">#<!-- -->3D</span><span class="text-sm text-gray-500">#<!-- -->game</span><span class="text-sm text-gray-500">#<!-- -->tetris</span><span class="text-sm text-gray-500">#<!-- -->interactive</span></div><div class="flex gap-4"><a href="/note/webpage-temp/three-js-tetris/preview" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors cursor-pointer"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>フルページプレビュー</a><a class="inline-flex items-center gap-2 px-6 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors" href="/note/webpage-temp/guide/"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>初心者向け学習ガイド</a></div></div><div class="space-y-6"><div class="border-b border-gray-700"><nav class="flex gap-6"><button class="py-2 px-1 border-b-2 font-medium text-sm transition-colors border-blue-500 text-blue-400">プレビュー</button><button class="py-2 px-1 border-b-2 font-medium text-sm transition-colors border-transparent text-gray-400 hover:text-gray-300">HTML</button><button class="py-2 px-1 border-b-2 font-medium text-sm transition-colors border-transparent text-gray-400 hover:text-gray-300">CSS</button><button class="py-2 px-1 border-b-2 font-medium text-sm transition-colors border-transparent text-gray-400 hover:text-gray-300">JavaScript</button></nav></div><div class="min-h-[600px]"><div class="space-y-4"><div class="flex justify-center gap-4"><button class="px-4 py-2 rounded bg-blue-600 text-white">デスクトップ</button><button class="px-4 py-2 rounded bg-gray-700 text-gray-300">モバイル</button></div><div class="bg-white rounded-lg overflow-hidden shadow-lg"><iframe srcDoc="
      &lt;!DOCTYPE html&gt;
      &lt;html lang=&quot;ja&quot;&gt;
      &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        
        
        &lt;style&gt;* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: &#x27;Courier New&#x27;, monospace;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
}

.game-container {
    width: 100%;
    max-width: 1400px;
    padding: 2rem;
}

.game-header {
    text-align: center;
    margin-bottom: 2rem;
    animation: slideDown 0.5s ease;
}

.game-header h1 {
    font-size: 3rem;
    margin-bottom: 0.5rem;
    text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
    background: linear-gradient(45deg, #00ff88, #00bbff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.subtitle {
    font-size: 1.2rem;
    opacity: 0.9;
}

.game-layout {
    display: flex;
    gap: 2rem;
    align-items: flex-start;
}

.side-panel {
    flex: 0 0 200px;
}

.game-board {
    flex: 1;
    position: relative;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    padding: 1rem;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}

#tetrisCanvas {
    width: 100%;
    height: 600px;
    display: block;
    border-radius: 10px;
}

.game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 10px;
    backdrop-filter: blur(5px);
    transition: opacity 0.3s;
}

.game-overlay.hidden {
    opacity: 0;
    pointer-events: none;
}

.overlay-content {
    text-align: center;
    animation: pulse 2s infinite;
}

.overlay-content h2 {
    font-size: 3rem;
    margin-bottom: 1rem;
    background: linear-gradient(45deg, #ff00ff, #00ffff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.overlay-content p {
    font-size: 1.2rem;
    margin-bottom: 2rem;
    opacity: 0.9;
}

#startBtn {
    padding: 1rem 3rem;
    font-size: 1.2rem;
    background: linear-gradient(45deg, #00ff88, #00bbff);
    border: none;
    border-radius: 50px;
    color: #000;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 5px 20px rgba(0,255,136,0.4);
}

#startBtn:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 30px rgba(0,255,136,0.6);
}

.info-box {
    background: rgba(0, 0, 0, 0.4);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 1rem;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.info-box h3 {
    font-size: 0.9rem;
    text-transform: uppercase;
    opacity: 0.7;
    margin-bottom: 0.5rem;
}

.score, .level, .lines {
    font-size: 2rem;
    font-weight: bold;
    background: linear-gradient(45deg, #ffaa00, #ff00aa);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

#nextBlockCanvas {
    width: 100%;
    height: 150px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
}

.controls {
    font-size: 0.85rem;
}

.control-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
    padding: 0.3rem;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
}

.key {
    background: rgba(255, 255, 255, 0.2);
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    font-weight: bold;
    min-width: 60px;
    text-align: center;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@media (max-width: 1024px) {
    .game-layout {
        flex-direction: column;
        align-items: center;
    }
    
    .side-panel {
        width: 100%;
        max-width: 400px;
        display: flex;
        gap: 1rem;
    }
    
    .side-panel.left {
        order: 2;
    }
    
    .side-panel.right {
        order: 3;
    }
    
    .game-board {
        order: 1;
        width: 100%;
        max-width: 600px;
    }
    
    .info-box {
        flex: 1;
    }
}

@media (max-width: 640px) {
    .game-header h1 {
        font-size: 2rem;
    }
    
    #tetrisCanvas {
        height: 400px;
    }
    
    .side-panel {
        flex-direction: column;
    }
}&lt;/style&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;!-- Three.js CDN --&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js&quot;&gt;&lt;/script&gt;

&lt;div class=&quot;game-container&quot;&gt;
    &lt;div class=&quot;game-header&quot;&gt;
        &lt;h1&gt;🎮 3D TETRIS&lt;/h1&gt;
        &lt;p class=&quot;subtitle&quot;&gt;Classic Game in 3D Space&lt;/p&gt;
    &lt;/div&gt;

    &lt;div class=&quot;game-layout&quot;&gt;
        &lt;div class=&quot;side-panel left&quot;&gt;
            &lt;div class=&quot;info-box&quot;&gt;
                &lt;h3&gt;スコア&lt;/h3&gt;
                &lt;div class=&quot;score&quot; id=&quot;score&quot;&gt;0&lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;info-box&quot;&gt;
                &lt;h3&gt;レベル&lt;/h3&gt;
                &lt;div class=&quot;level&quot; id=&quot;level&quot;&gt;1&lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;info-box&quot;&gt;
                &lt;h3&gt;ライン&lt;/h3&gt;
                &lt;div class=&quot;lines&quot; id=&quot;lines&quot;&gt;0&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;game-board&quot;&gt;
            &lt;canvas id=&quot;tetrisCanvas&quot;&gt;&lt;/canvas&gt;
            
            &lt;div class=&quot;game-overlay&quot; id=&quot;gameOverlay&quot;&gt;
                &lt;div class=&quot;overlay-content&quot;&gt;
                    &lt;h2 id=&quot;overlayTitle&quot;&gt;3D TETRIS&lt;/h2&gt;
                    &lt;p id=&quot;overlayMessage&quot;&gt;スペースキーでスタート&lt;/p&gt;
                    &lt;button id=&quot;startBtn&quot;&gt;▶️ PLAY&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;side-panel right&quot;&gt;
            &lt;div class=&quot;info-box&quot;&gt;
                &lt;h3&gt;次のブロック&lt;/h3&gt;
                &lt;canvas id=&quot;nextBlockCanvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;info-box controls&quot;&gt;
                &lt;h3&gt;操作方法&lt;/h3&gt;
                &lt;div class=&quot;control-item&quot;&gt;
                    &lt;span class=&quot;key&quot;&gt;←→&lt;/span&gt;
                    &lt;span&gt;移動&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;control-item&quot;&gt;
                    &lt;span class=&quot;key&quot;&gt;↑&lt;/span&gt;
                    &lt;span&gt;回転&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;control-item&quot;&gt;
                    &lt;span class=&quot;key&quot;&gt;↓&lt;/span&gt;
                    &lt;span&gt;落下&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;control-item&quot;&gt;
                    &lt;span class=&quot;key&quot;&gt;Space&lt;/span&gt;
                    &lt;span&gt;即落下&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;control-item&quot;&gt;
                    &lt;span class=&quot;key&quot;&gt;P&lt;/span&gt;
                    &lt;span&gt;一時停止&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
        &lt;script&gt;
          // すべてのイベントリスナーをDOMContentLoaded後に登録
          (function() {
            // 3D Tetris Game
class Tetris3D {
    constructor() {
        this.canvas = document.getElementById(&#x27;tetrisCanvas&#x27;);
        this.nextCanvas = document.getElementById(&#x27;nextBlockCanvas&#x27;);
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.nextRenderer = null;
        
        // Game state
        this.board = [];
        this.currentPiece = null;
        this.nextPiece = null;
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.gameRunning = false;
        this.gamePaused = false;
        this.dropTimer = 0;
        this.dropInterval = 1000;
        
        // Board dimensions
        this.BOARD_WIDTH = 10;
        this.BOARD_HEIGHT = 20;
        this.BOARD_DEPTH = 1;
        
        // Tetromino shapes
        this.shapes = {
            I: { shape: [[1,1,1,1]], color: 0x00ffff },
            O: { shape: [[1,1],[1,1]], color: 0xffff00 },
            T: { shape: [[0,1,0],[1,1,1]], color: 0xff00ff },
            S: { shape: [[0,1,1],[1,1,0]], color: 0x00ff00 },
            Z: { shape: [[1,1,0],[0,1,1]], color: 0xff0000 },
            J: { shape: [[1,0,0],[1,1,1]], color: 0x0000ff },
            L: { shape: [[0,0,1],[1,1,1]], color: 0xffa500 }
        };
        
        this.init();
        this.setupEventListeners();
    }
    
    init() {
        // Initialize board
        this.board = Array(this.BOARD_HEIGHT).fill(null).map(() =&gt; 
            Array(this.BOARD_WIDTH).fill(0)
        );
        
        // Main scene setup
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a0a0a);
        
        // Camera setup
        const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
        this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        this.camera.position.set(0, 10, 25);
        this.camera.lookAt(0, 0, 0);
        
        // Renderer setup
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: true
        });
        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
        this.renderer.shadowMap.enabled = true;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
        
        // Create game board
        this.createBoard();
        
        // Setup next block preview
        this.setupNextBlockPreview();
        
        // Start animation loop
        this.lastTime = 0;
        this.animate(0);
    }
    
    createBoard() {
        // Board outline
        const boardGeometry = new THREE.BoxGeometry(
            this.BOARD_WIDTH + 0.2,
            this.BOARD_HEIGHT + 0.2,
            this.BOARD_DEPTH
        );
        const boardMaterial = new THREE.MeshBasicMaterial({
            color: 0x222222,
            wireframe: true
        });
        const boardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
        this.scene.add(boardMesh);
        
        // Grid lines
        const gridMaterial = new THREE.LineBasicMaterial({
            color: 0x333333,
            transparent: true,
            opacity: 0.3
        });
        
        // Vertical lines
        for (let x = -this.BOARD_WIDTH/2 + 1; x &lt; this.BOARD_WIDTH/2; x++) {
            const points = [];
            points.push(new THREE.Vector3(x, -this.BOARD_HEIGHT/2, 0));
            points.push(new THREE.Vector3(x, this.BOARD_HEIGHT/2, 0));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            this.scene.add(line);
        }
        
        // Horizontal lines
        for (let y = -this.BOARD_HEIGHT/2 + 1; y &lt; this.BOARD_HEIGHT/2; y++) {
            const points = [];
            points.push(new THREE.Vector3(-this.BOARD_WIDTH/2, y, 0));
            points.push(new THREE.Vector3(this.BOARD_WIDTH/2, y, 0));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            this.scene.add(line);
        }
    }
    
    setupNextBlockPreview() {
        // Scene for next block
        this.nextScene = new THREE.Scene();
        this.nextScene.background = new THREE.Color(0x0a0a0a);
        
        // Camera for next block
        this.nextCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
        this.nextCamera.position.set(0, 0, 8);
        this.nextCamera.lookAt(0, 0, 0);
        
        // Renderer for next block
        this.nextRenderer = new THREE.WebGLRenderer({
            canvas: this.nextCanvas,
            antialias: true
        });
        this.nextRenderer.setSize(150, 150);
        
        // Lighting for next block
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.nextScene.add(ambientLight);
    }
    
    createPiece(type) {
        const shapeData = this.shapes[type];
        const shape = shapeData.shape;
        const color = shapeData.color;
        
        return {
            type: type,
            shape: shape,
            color: color,
            x: Math.floor(this.BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),
            y: this.BOARD_HEIGHT - 1,
            rotation: 0,
            mesh: null
        };
    }
    
    spawnPiece() {
        if (!this.nextPiece) {
            const types = Object.keys(this.shapes);
            const randomType = types[Math.floor(Math.random() * types.length)];
            this.nextPiece = this.createPiece(randomType);
        }
        
        this.currentPiece = this.nextPiece;
        
        // Generate next piece
        const types = Object.keys(this.shapes);
        const randomType = types[Math.floor(Math.random() * types.length)];
        this.nextPiece = this.createPiece(randomType);
        
        // Display next piece
        this.displayNextPiece();
        
        // Check if game over
        if (!this.isValidPosition(this.currentPiece)) {
            this.gameOver();
            return false;
        }
        
        return true;
    }
    
    displayNextPiece() {
        // Clear previous mesh
        while(this.nextScene.children.length &gt; 1) {
            const child = this.nextScene.children[1];
            this.nextScene.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        }
        
        // Create mesh for next piece
        const shape = this.nextPiece.shape;
        const color = this.nextPiece.color;
        const group = new THREE.Group();
        
        const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
        const material = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.2
        });
        
        for (let y = 0; y &lt; shape.length; y++) {
            for (let x = 0; x &lt; shape[y].length; x++) {
                if (shape[y][x]) {
                    const cube = new THREE.Mesh(geometry, material);
                    cube.position.set(
                        x - shape[y].length / 2 + 0.5,
                        -y + shape.length / 2 - 0.5,
                        0
                    );
                    group.add(cube);
                }
            }
        }
        
        this.nextScene.add(group);
        
        // Rotate preview
        group.rotation.y = Math.PI / 6;
        group.rotation.x = Math.PI / 8;
    }
    
    rotatePiece() {
        if (!this.currentPiece) return;
        
        const rotated = this.rotate(this.currentPiece.shape);
        const testPiece = {...this.currentPiece, shape: rotated};
        
        if (this.isValidPosition(testPiece)) {
            this.currentPiece.shape = rotated;
            this.currentPiece.rotation += 90;
        }
    }
    
    rotate(matrix) {
        const N = matrix.length;
        const M = matrix[0].length;
        const rotated = Array(M).fill(null).map(() =&gt; Array(N).fill(0));
        
        for (let i = 0; i &lt; N; i++) {
            for (let j = 0; j &lt; M; j++) {
                rotated[j][N - 1 - i] = matrix[i][j];
            }
        }
        
        return rotated;
    }
    
    movePiece(dx, dy) {
        if (!this.currentPiece) return;
        
        const testPiece = {
            ...this.currentPiece,
            x: this.currentPiece.x + dx,
            y: this.currentPiece.y + dy
        };
        
        if (this.isValidPosition(testPiece)) {
            this.currentPiece.x += dx;
            this.currentPiece.y += dy;
            return true;
        }
        
        return false;
    }
    
    isValidPosition(piece) {
        const shape = piece.shape;
        
        for (let y = 0; y &lt; shape.length; y++) {
            for (let x = 0; x &lt; shape[y].length; x++) {
                if (shape[y][x]) {
                    const boardX = piece.x + x;
                    const boardY = piece.y - y;
                    
                    // Check boundaries
                    if (boardX &lt; 0 || boardX &gt;= this.BOARD_WIDTH ||
                        boardY &lt; 0 || boardY &gt;= this.BOARD_HEIGHT) {
                        return false;
                    }
                    
                    // Check collision with placed pieces
                    if (this.board[boardY][boardX]) {
                        return false;
                    }
                }
            }
        }
        
        return true;
    }
    
    lockPiece() {
        const shape = this.currentPiece.shape;
        const color = this.currentPiece.color;
        
        for (let y = 0; y &lt; shape.length; y++) {
            for (let x = 0; x &lt; shape[y].length; x++) {
                if (shape[y][x]) {
                    const boardX = this.currentPiece.x + x;
                    const boardY = this.currentPiece.y - y;
                    
                    if (boardY &gt;= 0 &amp;&amp; boardY &lt; this.BOARD_HEIGHT) {
                        this.board[boardY][boardX] = color;
                    }
                }
            }
        }
        
        // Check for completed lines
        this.checkLines();
        
        // Spawn new piece
        this.spawnPiece();
    }
    
    checkLines() {
        let linesCleared = 0;
        
        for (let y = 0; y &lt; this.BOARD_HEIGHT; y++) {
            if (this.board[y].every(cell =&gt; cell !== 0)) {
                // Remove line
                this.board.splice(y, 1);
                // Add empty line at top
                this.board.push(Array(this.BOARD_WIDTH).fill(0));
                linesCleared++;
                y--; // Check same line again
            }
        }
        
        if (linesCleared &gt; 0) {
            this.lines += linesCleared;
            this.score += linesCleared * 100 * this.level;
            
            // Level up every 10 lines
            this.level = Math.floor(this.lines / 10) + 1;
            this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
            
            this.updateDisplay();
        }
    }
    
    dropPiece() {
        if (!this.movePiece(0, -1)) {
            this.lockPiece();
        }
    }
    
    hardDrop() {
        while (this.movePiece(0, -1)) {
            this.score += 2;
        }
        this.lockPiece();
        this.updateDisplay();
    }
    
    updateDisplay() {
        document.getElementById(&#x27;score&#x27;).textContent = this.score;
        document.getElementById(&#x27;level&#x27;).textContent = this.level;
        document.getElementById(&#x27;lines&#x27;).textContent = this.lines;
    }
    
    render() {
        // Clear previous blocks
        const blocksToRemove = [];
        this.scene.traverse((child) =&gt; {
            if (child.userData.isBlock) {
                blocksToRemove.push(child);
            }
        });
        blocksToRemove.forEach(block =&gt; {
            this.scene.remove(block);
            if (block.geometry) block.geometry.dispose();
            if (block.material) block.material.dispose();
        });
        
        // Render board
        const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
        
        for (let y = 0; y &lt; this.BOARD_HEIGHT; y++) {
            for (let x = 0; x &lt; this.BOARD_WIDTH; x++) {
                if (this.board[y][x]) {
                    const material = new THREE.MeshPhongMaterial({
                        color: this.board[y][x],
                        emissive: this.board[y][x],
                        emissiveIntensity: 0.2
                    });
                    const cube = new THREE.Mesh(geometry, material);
                    cube.position.set(
                        x - this.BOARD_WIDTH / 2 + 0.5,
                        y - this.BOARD_HEIGHT / 2 + 0.5,
                        0
                    );
                    cube.userData.isBlock = true;
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    this.scene.add(cube);
                }
            }
        }
        
        // Render current piece
        if (this.currentPiece) {
            const shape = this.currentPiece.shape;
            const color = this.currentPiece.color;
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            
            for (let y = 0; y &lt; shape.length; y++) {
                for (let x = 0; x &lt; shape[y].length; x++) {
                    if (shape[y][x]) {
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(
                            this.currentPiece.x + x - this.BOARD_WIDTH / 2 + 0.5,
                            this.currentPiece.y - y - this.BOARD_HEIGHT / 2 + 0.5,
                            0
                        );
                        cube.userData.isBlock = true;
                        cube.castShadow = true;
                        this.scene.add(cube);
                    }
                }
            }
        }
    }
    
    animate(currentTime) {
        requestAnimationFrame((time) =&gt; this.animate(time));
        
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        // Game logic
        if (this.gameRunning &amp;&amp; !this.gamePaused) {
            this.dropTimer += deltaTime;
            
            if (this.dropTimer &gt;= this.dropInterval) {
                this.dropPiece();
                this.dropTimer = 0;
            }
        }
        
        // Render
        this.render();
        this.renderer.render(this.scene, this.camera);
        
        // Render next piece
        if (this.nextRenderer) {
            this.nextRenderer.render(this.nextScene, this.nextCamera);
        }
    }
    
    startGame() {
        // Reset game state
        this.board = Array(this.BOARD_HEIGHT).fill(null).map(() =&gt; 
            Array(this.BOARD_WIDTH).fill(0)
        );
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.dropTimer = 0;
        this.updateDisplay();
        
        // Start game
        this.gameRunning = true;
        this.gamePaused = false;
        this.spawnPiece();
        
        // Hide overlay
        document.getElementById(&#x27;gameOverlay&#x27;).classList.add(&#x27;hidden&#x27;);
    }
    
    pauseGame() {
        if (this.gameRunning) {
            this.gamePaused = !this.gamePaused;
            
            if (this.gamePaused) {
                document.getElementById(&#x27;overlayTitle&#x27;).textContent = &#x27;PAUSED&#x27;;
                document.getElementById(&#x27;overlayMessage&#x27;).textContent = &#x27;Pキーで再開&#x27;;
                document.getElementById(&#x27;startBtn&#x27;).style.display = &#x27;none&#x27;;
                document.getElementById(&#x27;gameOverlay&#x27;).classList.remove(&#x27;hidden&#x27;);
            } else {
                document.getElementById(&#x27;gameOverlay&#x27;).classList.add(&#x27;hidden&#x27;);
                document.getElementById(&#x27;startBtn&#x27;).style.display = &#x27;block&#x27;;
            }
        }
    }
    
    gameOver() {
        this.gameRunning = false;
        document.getElementById(&#x27;overlayTitle&#x27;).textContent = &#x27;GAME OVER&#x27;;
        document.getElementById(&#x27;overlayMessage&#x27;).textContent = `スコア: ${this.score}`;
        document.getElementById(&#x27;startBtn&#x27;).textContent = &#x27;🔄 RETRY&#x27;;
        document.getElementById(&#x27;startBtn&#x27;).style.display = &#x27;block&#x27;;
        document.getElementById(&#x27;gameOverlay&#x27;).classList.remove(&#x27;hidden&#x27;);
    }
    
    setupEventListeners() {
        // Keyboard controls
        document.addEventListener(&#x27;keydown&#x27;, (e) =&gt; {
            if (!this.gameRunning || this.gamePaused) return;
            
            switch(e.key) {
                case &#x27;ArrowLeft&#x27;:
                    this.movePiece(-1, 0);
                    break;
                case &#x27;ArrowRight&#x27;:
                    this.movePiece(1, 0);
                    break;
                case &#x27;ArrowDown&#x27;:
                    this.dropPiece();
                    this.score += 1;
                    this.updateDisplay();
                    break;
                case &#x27;ArrowUp&#x27;:
                    this.rotatePiece();
                    break;
                case &#x27; &#x27;:
                    e.preventDefault();
                    this.hardDrop();
                    break;
            }
        });
        
        // Pause
        document.addEventListener(&#x27;keydown&#x27;, (e) =&gt; {
            if (e.key === &#x27;p&#x27; || e.key === &#x27;P&#x27;) {
                this.pauseGame();
            }
        });
        
        // Start button
        document.getElementById(&#x27;startBtn&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; {
            this.startGame();
        });
        
        // Space to start
        document.addEventListener(&#x27;keydown&#x27;, (e) =&gt; {
            if (e.key === &#x27; &#x27; &amp;&amp; !this.gameRunning) {
                e.preventDefault();
                this.startGame();
            }
        });
        
        // Window resize
        window.addEventListener(&#x27;resize&#x27;, () =&gt; {
            const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
            this.camera.aspect = aspect;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
        });
    }
}

// Initialize game
if (document.readyState === &#x27;loading&#x27;) {
    document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; {
        new Tetris3D();
    });
} else {
    new Tetris3D();
}
          })();
        &lt;/script&gt;
      &lt;/body&gt;
      &lt;/html&gt;
    " class="w-full transition-all duration-300 h-[700px]" title="Template Preview" sandbox="allow-scripts allow-same-origin allow-forms allow-modals allow-popups"></iframe></div></div></div></div><div class="mt-12 bg-gray-800 rounded-lg p-6"><h2 class="text-xl font-bold mb-4">使用方法</h2><ol class="space-y-3 text-gray-300"><li class="flex gap-3"><span class="text-blue-400 font-bold">1.</span><span>上のタブからHTML、CSS、JavaScriptのコードをそれぞれコピーします。</span></li><li class="flex gap-3"><span class="text-blue-400 font-bold">2.</span><span>新しいHTMLファイルを作成し、HTMLコードを貼り付けます。</span></li><li class="flex gap-3"><span class="text-blue-400 font-bold">3.</span><span>CSSコードを&lt;style&gt;タグ内に貼り付けるか、別ファイルとして保存してリンクします。</span></li><li class="flex gap-3"><span class="text-blue-400 font-bold">4.</span><span>JavaScriptコードを&lt;script&gt;タグ内に貼り付けるか、別ファイルとして保存してリンクします。</span></li><li class="flex gap-3"><span class="text-blue-400 font-bold">5.</span><span>必要に応じて、テキストや画像、色などをカスタマイズしてご使用ください。</span></li></ol><div class="mt-6 p-4 bg-blue-900/30 border border-blue-600 rounded"><p class="text-blue-400 mb-2">📚 初めての方へ</p><p class="text-gray-300 text-sm">HTMLやCSSが初めての方は、<a class="text-blue-400 hover:text-blue-300 underline" href="/note/webpage-temp/guide/">初心者向けWeb制作学習ガイド</a>をご覧ください。実際に手を動かしながら学べる詳しい手順を解説しています。</p></div></div><div class="mt-8 bg-yellow-900/30 border border-yellow-600 rounded-lg p-6"><h3 class="text-yellow-400 font-bold mb-2">注意事項</h3><ul class="space-y-2 text-gray-300 text-sm"><li>• このテンプレートは学習・参考用として提供されています。</li><li>• 実際のプロジェクトで使用する際は、セキュリティやパフォーマンスの最適化を行ってください。</li><li>• 画像やアイコンは実際のものに置き換えてご使用ください。</li><li>• レスポンシブ対応していますが、実機でのテストを推奨します。</li></ul></div><div class="mt-8 text-center"><a class="inline-block px-6 py-3 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors" href="/note/webpage-temp/">テンプレート一覧へ戻る</a></div></div></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-29ebadaebe2fcb3f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n5:I[9665,[],\"MetadataBoundary\"]\n7:I[9665,[],\"OutletBoundary\"]\na:I[4911,[],\"AsyncMetadataOutlet\"]\nc:I[9665,[],\"ViewportBoundary\"]\ne:I[6614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/21fca20b31fba572.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"qVnS570rtJXUlrEGWJ0ZU\",\"p\":\"\",\"c\":[\"\",\"note\",\"webpage-temp\",\"three-js-tetris\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"note\",{\"children\":[\"webpage-temp\",{\"children\":[[\"id\",\"three-js-tetris\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/21fca20b31fba572.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png\",\"type\":\"image/png\"}]}],[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[\"note\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"webpage-temp\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"three-js-tetris\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[\"$\",\"$L5\",null,{\"children\":\"$L6\"}],null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"yfJ1Yf4IO7D_5mapz3SyQ\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$e\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:\"$Sreact.suspense\"\n10:I[4911,[],\"AsyncMetadata\"]\n12:I[6874,[\"874\",\"static/chunks/874-8d3839f72fd80c3c.js\",\"588\",\"static/chunks/app/note/webpage-temp/%5Bid%5D/page-4b841b09f124fe29.js\"],\"\"]\n13:I[8863,[\"874\",\"static/chunks/874-8d3839f72fd80c3c.js\",\"588\",\"static/chunks/app/note/webpage-temp/%5Bid%5D/page-4b841b09f124fe29.js\"],\"default\"]\n14:I[9320,[\"874\",\"static/chunks/874-8d3839f72fd80c3c.js\",\"588\",\"static/chunks/app/note/webpage-temp/%5Bid%5D/page-4b841b09f124fe29.js\"],\"default\"]\n6:[\"$\",\"$f\",null,{\"fallback\":null,\"children\":[\"$\",\"$L10\",null,{\"promise\":\"$@11\"}]}]\n15:T9da,"])</script><script>self.__next_f.push([1,"\u003c!-- Three.js CDN --\u003e\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"\u003e\u003c/script\u003e\n\n\u003cdiv class=\"game-container\"\u003e\n    \u003cdiv class=\"game-header\"\u003e\n        \u003ch1\u003e🎮 3D TETRIS\u003c/h1\u003e\n        \u003cp class=\"subtitle\"\u003eClassic Game in 3D Space\u003c/p\u003e\n    \u003c/div\u003e\n\n    \u003cdiv class=\"game-layout\"\u003e\n        \u003cdiv class=\"side-panel left\"\u003e\n            \u003cdiv class=\"info-box\"\u003e\n                \u003ch3\u003eスコア\u003c/h3\u003e\n                \u003cdiv class=\"score\" id=\"score\"\u003e0\u003c/div\u003e\n            \u003c/div\u003e\n            \n            \u003cdiv class=\"info-box\"\u003e\n                \u003ch3\u003eレベル\u003c/h3\u003e\n                \u003cdiv class=\"level\" id=\"level\"\u003e1\u003c/div\u003e\n            \u003c/div\u003e\n            \n            \u003cdiv class=\"info-box\"\u003e\n                \u003ch3\u003eライン\u003c/h3\u003e\n                \u003cdiv class=\"lines\" id=\"lines\"\u003e0\u003c/div\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n\n        \u003cdiv class=\"game-board\"\u003e\n            \u003ccanvas id=\"tetrisCanvas\"\u003e\u003c/canvas\u003e\n            \n            \u003cdiv class=\"game-overlay\" id=\"gameOverlay\"\u003e\n                \u003cdiv class=\"overlay-content\"\u003e\n                    \u003ch2 id=\"overlayTitle\"\u003e3D TETRIS\u003c/h2\u003e\n                    \u003cp id=\"overlayMessage\"\u003eスペースキーでスタート\u003c/p\u003e\n                    \u003cbutton id=\"startBtn\"\u003e▶️ PLAY\u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n\n        \u003cdiv class=\"side-panel right\"\u003e\n            \u003cdiv class=\"info-box\"\u003e\n                \u003ch3\u003e次のブロック\u003c/h3\u003e\n                \u003ccanvas id=\"nextBlockCanvas\" width=\"150\" height=\"150\"\u003e\u003c/canvas\u003e\n            \u003c/div\u003e\n            \n            \u003cdiv class=\"info-box controls\"\u003e\n                \u003ch3\u003e操作方法\u003c/h3\u003e\n                \u003cdiv class=\"control-item\"\u003e\n                    \u003cspan class=\"key\"\u003e←→\u003c/span\u003e\n                    \u003cspan\u003e移動\u003c/span\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"control-item\"\u003e\n                    \u003cspan class=\"key\"\u003e↑\u003c/span\u003e\n                    \u003cspan\u003e回転\u003c/span\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"control-item\"\u003e\n                    \u003cspan class=\"key\"\u003e↓\u003c/span\u003e\n                    \u003cspan\u003e落下\u003c/span\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"control-item\"\u003e\n                    \u003cspan class=\"key\"\u003eSpace\u003c/span\u003e\n                    \u003cspan\u003e即落下\u003c/span\u003e\n                \u003c/div\u003e\n                \u003cdiv class=\"control-item\"\u003e\n                    \u003cspan class=\"key\"\u003eP\u003c/span\u003e\n                    \u003cspan\u003e一時停止\u003c/span\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\u003c/div\u003e"])</script><script>self.__next_f.push([1,"16:T1151,"])</script><script>self.__next_f.push([1,"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Courier New', monospace;\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    min-height: 100vh;\n    color: white;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.game-container {\n    width: 100%;\n    max-width: 1400px;\n    padding: 2rem;\n}\n\n.game-header {\n    text-align: center;\n    margin-bottom: 2rem;\n    animation: slideDown 0.5s ease;\n}\n\n.game-header h1 {\n    font-size: 3rem;\n    margin-bottom: 0.5rem;\n    text-shadow: 3px 3px 6px rgba(0,0,0,0.5);\n    background: linear-gradient(45deg, #00ff88, #00bbff);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.subtitle {\n    font-size: 1.2rem;\n    opacity: 0.9;\n}\n\n.game-layout {\n    display: flex;\n    gap: 2rem;\n    align-items: flex-start;\n}\n\n.side-panel {\n    flex: 0 0 200px;\n}\n\n.game-board {\n    flex: 1;\n    position: relative;\n    background: rgba(0, 0, 0, 0.3);\n    border-radius: 15px;\n    padding: 1rem;\n    box-shadow: 0 20px 60px rgba(0,0,0,0.5);\n}\n\n#tetrisCanvas {\n    width: 100%;\n    height: 600px;\n    display: block;\n    border-radius: 10px;\n}\n\n.game-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.8);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 10px;\n    backdrop-filter: blur(5px);\n    transition: opacity 0.3s;\n}\n\n.game-overlay.hidden {\n    opacity: 0;\n    pointer-events: none;\n}\n\n.overlay-content {\n    text-align: center;\n    animation: pulse 2s infinite;\n}\n\n.overlay-content h2 {\n    font-size: 3rem;\n    margin-bottom: 1rem;\n    background: linear-gradient(45deg, #ff00ff, #00ffff);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.overlay-content p {\n    font-size: 1.2rem;\n    margin-bottom: 2rem;\n    opacity: 0.9;\n}\n\n#startBtn {\n    padding: 1rem 3rem;\n    font-size: 1.2rem;\n    background: linear-gradient(45deg, #00ff88, #00bbff);\n    border: none;\n    border-radius: 50px;\n    color: #000;\n    font-weight: bold;\n    cursor: pointer;\n    transition: transform 0.2s, box-shadow 0.2s;\n    box-shadow: 0 5px 20px rgba(0,255,136,0.4);\n}\n\n#startBtn:hover {\n    transform: scale(1.05);\n    box-shadow: 0 8px 30px rgba(0,255,136,0.6);\n}\n\n.info-box {\n    background: rgba(0, 0, 0, 0.4);\n    border-radius: 10px;\n    padding: 1rem;\n    margin-bottom: 1rem;\n    backdrop-filter: blur(10px);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.info-box h3 {\n    font-size: 0.9rem;\n    text-transform: uppercase;\n    opacity: 0.7;\n    margin-bottom: 0.5rem;\n}\n\n.score, .level, .lines {\n    font-size: 2rem;\n    font-weight: bold;\n    background: linear-gradient(45deg, #ffaa00, #ff00aa);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n#nextBlockCanvas {\n    width: 100%;\n    height: 150px;\n    background: rgba(0, 0, 0, 0.3);\n    border-radius: 5px;\n}\n\n.controls {\n    font-size: 0.85rem;\n}\n\n.control-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 0.5rem;\n    padding: 0.3rem;\n    background: rgba(255, 255, 255, 0.05);\n    border-radius: 5px;\n}\n\n.key {\n    background: rgba(255, 255, 255, 0.2);\n    padding: 0.2rem 0.5rem;\n    border-radius: 3px;\n    font-weight: bold;\n    min-width: 60px;\n    text-align: center;\n}\n\n@keyframes slideDown {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n@keyframes pulse {\n    0%, 100% { transform: scale(1); }\n    50% { transform: scale(1.05); }\n}\n\n@media (max-width: 1024px) {\n    .game-layout {\n        flex-direction: column;\n        align-items: center;\n    }\n    \n    .side-panel {\n        width: 100%;\n        max-width: 400px;\n        display: flex;\n        gap: 1rem;\n    }\n    \n    .side-panel.left {\n        order: 2;\n    }\n    \n    .side-panel.right {\n        order: 3;\n    }\n    \n    .game-board {\n        order: 1;\n        width: 100%;\n        max-width: 600px;\n    }\n    \n    .info-box {\n        flex: 1;\n    }\n}\n\n@media (max-width: 640px) {\n    .game-header h1 {\n        font-size: 2rem;\n    }\n    \n    #tetrisCanvas {\n        height: 400px;\n    }\n    \n    .side-panel {\n        flex-direction: column;\n    }\n}"])</script><script>self.__next_f.push([1,"17:T49b1,"])</script><script>self.__next_f.push([1,"// 3D Tetris Game\nclass Tetris3D {\n    constructor() {\n        this.canvas = document.getElementById('tetrisCanvas');\n        this.nextCanvas = document.getElementById('nextBlockCanvas');\n        this.scene = null;\n        this.camera = null;\n        this.renderer = null;\n        this.nextRenderer = null;\n        \n        // Game state\n        this.board = [];\n        this.currentPiece = null;\n        this.nextPiece = null;\n        this.score = 0;\n        this.level = 1;\n        this.lines = 0;\n        this.gameRunning = false;\n        this.gamePaused = false;\n        this.dropTimer = 0;\n        this.dropInterval = 1000;\n        \n        // Board dimensions\n        this.BOARD_WIDTH = 10;\n        this.BOARD_HEIGHT = 20;\n        this.BOARD_DEPTH = 1;\n        \n        // Tetromino shapes\n        this.shapes = {\n            I: { shape: [[1,1,1,1]], color: 0x00ffff },\n            O: { shape: [[1,1],[1,1]], color: 0xffff00 },\n            T: { shape: [[0,1,0],[1,1,1]], color: 0xff00ff },\n            S: { shape: [[0,1,1],[1,1,0]], color: 0x00ff00 },\n            Z: { shape: [[1,1,0],[0,1,1]], color: 0xff0000 },\n            J: { shape: [[1,0,0],[1,1,1]], color: 0x0000ff },\n            L: { shape: [[0,0,1],[1,1,1]], color: 0xffa500 }\n        };\n        \n        this.init();\n        this.setupEventListeners();\n    }\n    \n    init() {\n        // Initialize board\n        this.board = Array(this.BOARD_HEIGHT).fill(null).map(() =\u003e \n            Array(this.BOARD_WIDTH).fill(0)\n        );\n        \n        // Main scene setup\n        this.scene = new THREE.Scene();\n        this.scene.background = new THREE.Color(0x0a0a0a);\n        \n        // Camera setup\n        const aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n        this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);\n        this.camera.position.set(0, 10, 25);\n        this.camera.lookAt(0, 0, 0);\n        \n        // Renderer setup\n        this.renderer = new THREE.WebGLRenderer({\n            canvas: this.canvas,\n            antialias: true\n        });\n        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\n        this.renderer.shadowMap.enabled = true;\n        \n        // Lighting\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\n        this.scene.add(ambientLight);\n        \n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);\n        directionalLight.position.set(5, 10, 5);\n        directionalLight.castShadow = true;\n        this.scene.add(directionalLight);\n        \n        // Create game board\n        this.createBoard();\n        \n        // Setup next block preview\n        this.setupNextBlockPreview();\n        \n        // Start animation loop\n        this.lastTime = 0;\n        this.animate(0);\n    }\n    \n    createBoard() {\n        // Board outline\n        const boardGeometry = new THREE.BoxGeometry(\n            this.BOARD_WIDTH + 0.2,\n            this.BOARD_HEIGHT + 0.2,\n            this.BOARD_DEPTH\n        );\n        const boardMaterial = new THREE.MeshBasicMaterial({\n            color: 0x222222,\n            wireframe: true\n        });\n        const boardMesh = new THREE.Mesh(boardGeometry, boardMaterial);\n        this.scene.add(boardMesh);\n        \n        // Grid lines\n        const gridMaterial = new THREE.LineBasicMaterial({\n            color: 0x333333,\n            transparent: true,\n            opacity: 0.3\n        });\n        \n        // Vertical lines\n        for (let x = -this.BOARD_WIDTH/2 + 1; x \u003c this.BOARD_WIDTH/2; x++) {\n            const points = [];\n            points.push(new THREE.Vector3(x, -this.BOARD_HEIGHT/2, 0));\n            points.push(new THREE.Vector3(x, this.BOARD_HEIGHT/2, 0));\n            const geometry = new THREE.BufferGeometry().setFromPoints(points);\n            const line = new THREE.Line(geometry, gridMaterial);\n            this.scene.add(line);\n        }\n        \n        // Horizontal lines\n        for (let y = -this.BOARD_HEIGHT/2 + 1; y \u003c this.BOARD_HEIGHT/2; y++) {\n            const points = [];\n            points.push(new THREE.Vector3(-this.BOARD_WIDTH/2, y, 0));\n            points.push(new THREE.Vector3(this.BOARD_WIDTH/2, y, 0));\n            const geometry = new THREE.BufferGeometry().setFromPoints(points);\n            const line = new THREE.Line(geometry, gridMaterial);\n            this.scene.add(line);\n        }\n    }\n    \n    setupNextBlockPreview() {\n        // Scene for next block\n        this.nextScene = new THREE.Scene();\n        this.nextScene.background = new THREE.Color(0x0a0a0a);\n        \n        // Camera for next block\n        this.nextCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);\n        this.nextCamera.position.set(0, 0, 8);\n        this.nextCamera.lookAt(0, 0, 0);\n        \n        // Renderer for next block\n        this.nextRenderer = new THREE.WebGLRenderer({\n            canvas: this.nextCanvas,\n            antialias: true\n        });\n        this.nextRenderer.setSize(150, 150);\n        \n        // Lighting for next block\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n        this.nextScene.add(ambientLight);\n    }\n    \n    createPiece(type) {\n        const shapeData = this.shapes[type];\n        const shape = shapeData.shape;\n        const color = shapeData.color;\n        \n        return {\n            type: type,\n            shape: shape,\n            color: color,\n            x: Math.floor(this.BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),\n            y: this.BOARD_HEIGHT - 1,\n            rotation: 0,\n            mesh: null\n        };\n    }\n    \n    spawnPiece() {\n        if (!this.nextPiece) {\n            const types = Object.keys(this.shapes);\n            const randomType = types[Math.floor(Math.random() * types.length)];\n            this.nextPiece = this.createPiece(randomType);\n        }\n        \n        this.currentPiece = this.nextPiece;\n        \n        // Generate next piece\n        const types = Object.keys(this.shapes);\n        const randomType = types[Math.floor(Math.random() * types.length)];\n        this.nextPiece = this.createPiece(randomType);\n        \n        // Display next piece\n        this.displayNextPiece();\n        \n        // Check if game over\n        if (!this.isValidPosition(this.currentPiece)) {\n            this.gameOver();\n            return false;\n        }\n        \n        return true;\n    }\n    \n    displayNextPiece() {\n        // Clear previous mesh\n        while(this.nextScene.children.length \u003e 1) {\n            const child = this.nextScene.children[1];\n            this.nextScene.remove(child);\n            if (child.geometry) child.geometry.dispose();\n            if (child.material) child.material.dispose();\n        }\n        \n        // Create mesh for next piece\n        const shape = this.nextPiece.shape;\n        const color = this.nextPiece.color;\n        const group = new THREE.Group();\n        \n        const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);\n        const material = new THREE.MeshPhongMaterial({\n            color: color,\n            emissive: color,\n            emissiveIntensity: 0.2\n        });\n        \n        for (let y = 0; y \u003c shape.length; y++) {\n            for (let x = 0; x \u003c shape[y].length; x++) {\n                if (shape[y][x]) {\n                    const cube = new THREE.Mesh(geometry, material);\n                    cube.position.set(\n                        x - shape[y].length / 2 + 0.5,\n                        -y + shape.length / 2 - 0.5,\n                        0\n                    );\n                    group.add(cube);\n                }\n            }\n        }\n        \n        this.nextScene.add(group);\n        \n        // Rotate preview\n        group.rotation.y = Math.PI / 6;\n        group.rotation.x = Math.PI / 8;\n    }\n    \n    rotatePiece() {\n        if (!this.currentPiece) return;\n        \n        const rotated = this.rotate(this.currentPiece.shape);\n        const testPiece = {...this.currentPiece, shape: rotated};\n        \n        if (this.isValidPosition(testPiece)) {\n            this.currentPiece.shape = rotated;\n            this.currentPiece.rotation += 90;\n        }\n    }\n    \n    rotate(matrix) {\n        const N = matrix.length;\n        const M = matrix[0].length;\n        const rotated = Array(M).fill(null).map(() =\u003e Array(N).fill(0));\n        \n        for (let i = 0; i \u003c N; i++) {\n            for (let j = 0; j \u003c M; j++) {\n                rotated[j][N - 1 - i] = matrix[i][j];\n            }\n        }\n        \n        return rotated;\n    }\n    \n    movePiece(dx, dy) {\n        if (!this.currentPiece) return;\n        \n        const testPiece = {\n            ...this.currentPiece,\n            x: this.currentPiece.x + dx,\n            y: this.currentPiece.y + dy\n        };\n        \n        if (this.isValidPosition(testPiece)) {\n            this.currentPiece.x += dx;\n            this.currentPiece.y += dy;\n            return true;\n        }\n        \n        return false;\n    }\n    \n    isValidPosition(piece) {\n        const shape = piece.shape;\n        \n        for (let y = 0; y \u003c shape.length; y++) {\n            for (let x = 0; x \u003c shape[y].length; x++) {\n                if (shape[y][x]) {\n                    const boardX = piece.x + x;\n                    const boardY = piece.y - y;\n                    \n                    // Check boundaries\n                    if (boardX \u003c 0 || boardX \u003e= this.BOARD_WIDTH ||\n                        boardY \u003c 0 || boardY \u003e= this.BOARD_HEIGHT) {\n                        return false;\n                    }\n                    \n                    // Check collision with placed pieces\n                    if (this.board[boardY][boardX]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    lockPiece() {\n        const shape = this.currentPiece.shape;\n        const color = this.currentPiece.color;\n        \n        for (let y = 0; y \u003c shape.length; y++) {\n            for (let x = 0; x \u003c shape[y].length; x++) {\n                if (shape[y][x]) {\n                    const boardX = this.currentPiece.x + x;\n                    const boardY = this.currentPiece.y - y;\n                    \n                    if (boardY \u003e= 0 \u0026\u0026 boardY \u003c this.BOARD_HEIGHT) {\n                        this.board[boardY][boardX] = color;\n                    }\n                }\n            }\n        }\n        \n        // Check for completed lines\n        this.checkLines();\n        \n        // Spawn new piece\n        this.spawnPiece();\n    }\n    \n    checkLines() {\n        let linesCleared = 0;\n        \n        for (let y = 0; y \u003c this.BOARD_HEIGHT; y++) {\n            if (this.board[y].every(cell =\u003e cell !== 0)) {\n                // Remove line\n                this.board.splice(y, 1);\n                // Add empty line at top\n                this.board.push(Array(this.BOARD_WIDTH).fill(0));\n                linesCleared++;\n                y--; // Check same line again\n            }\n        }\n        \n        if (linesCleared \u003e 0) {\n            this.lines += linesCleared;\n            this.score += linesCleared * 100 * this.level;\n            \n            // Level up every 10 lines\n            this.level = Math.floor(this.lines / 10) + 1;\n            this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);\n            \n            this.updateDisplay();\n        }\n    }\n    \n    dropPiece() {\n        if (!this.movePiece(0, -1)) {\n            this.lockPiece();\n        }\n    }\n    \n    hardDrop() {\n        while (this.movePiece(0, -1)) {\n            this.score += 2;\n        }\n        this.lockPiece();\n        this.updateDisplay();\n    }\n    \n    updateDisplay() {\n        document.getElementById('score').textContent = this.score;\n        document.getElementById('level').textContent = this.level;\n        document.getElementById('lines').textContent = this.lines;\n    }\n    \n    render() {\n        // Clear previous blocks\n        const blocksToRemove = [];\n        this.scene.traverse((child) =\u003e {\n            if (child.userData.isBlock) {\n                blocksToRemove.push(child);\n            }\n        });\n        blocksToRemove.forEach(block =\u003e {\n            this.scene.remove(block);\n            if (block.geometry) block.geometry.dispose();\n            if (block.material) block.material.dispose();\n        });\n        \n        // Render board\n        const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);\n        \n        for (let y = 0; y \u003c this.BOARD_HEIGHT; y++) {\n            for (let x = 0; x \u003c this.BOARD_WIDTH; x++) {\n                if (this.board[y][x]) {\n                    const material = new THREE.MeshPhongMaterial({\n                        color: this.board[y][x],\n                        emissive: this.board[y][x],\n                        emissiveIntensity: 0.2\n                    });\n                    const cube = new THREE.Mesh(geometry, material);\n                    cube.position.set(\n                        x - this.BOARD_WIDTH / 2 + 0.5,\n                        y - this.BOARD_HEIGHT / 2 + 0.5,\n                        0\n                    );\n                    cube.userData.isBlock = true;\n                    cube.castShadow = true;\n                    cube.receiveShadow = true;\n                    this.scene.add(cube);\n                }\n            }\n        }\n        \n        // Render current piece\n        if (this.currentPiece) {\n            const shape = this.currentPiece.shape;\n            const color = this.currentPiece.color;\n            const material = new THREE.MeshPhongMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 0.3,\n                transparent: true,\n                opacity: 0.9\n            });\n            \n            for (let y = 0; y \u003c shape.length; y++) {\n                for (let x = 0; x \u003c shape[y].length; x++) {\n                    if (shape[y][x]) {\n                        const cube = new THREE.Mesh(geometry, material);\n                        cube.position.set(\n                            this.currentPiece.x + x - this.BOARD_WIDTH / 2 + 0.5,\n                            this.currentPiece.y - y - this.BOARD_HEIGHT / 2 + 0.5,\n                            0\n                        );\n                        cube.userData.isBlock = true;\n                        cube.castShadow = true;\n                        this.scene.add(cube);\n                    }\n                }\n            }\n        }\n    }\n    \n    animate(currentTime) {\n        requestAnimationFrame((time) =\u003e this.animate(time));\n        \n        const deltaTime = currentTime - this.lastTime;\n        this.lastTime = currentTime;\n        \n        // Game logic\n        if (this.gameRunning \u0026\u0026 !this.gamePaused) {\n            this.dropTimer += deltaTime;\n            \n            if (this.dropTimer \u003e= this.dropInterval) {\n                this.dropPiece();\n                this.dropTimer = 0;\n            }\n        }\n        \n        // Render\n        this.render();\n        this.renderer.render(this.scene, this.camera);\n        \n        // Render next piece\n        if (this.nextRenderer) {\n            this.nextRenderer.render(this.nextScene, this.nextCamera);\n        }\n    }\n    \n    startGame() {\n        // Reset game state\n        this.board = Array(this.BOARD_HEIGHT).fill(null).map(() =\u003e \n            Array(this.BOARD_WIDTH).fill(0)\n        );\n        this.score = 0;\n        this.level = 1;\n        this.lines = 0;\n        this.dropTimer = 0;\n        this.updateDisplay();\n        \n        // Start game\n        this.gameRunning = true;\n        this.gamePaused = false;\n        this.spawnPiece();\n        \n        // Hide overlay\n        document.getElementById('gameOverlay').classList.add('hidden');\n    }\n    \n    pauseGame() {\n        if (this.gameRunning) {\n            this.gamePaused = !this.gamePaused;\n            \n            if (this.gamePaused) {\n                document.getElementById('overlayTitle').textContent = 'PAUSED';\n                document.getElementById('overlayMessage').textContent = 'Pキーで再開';\n                document.getElementById('startBtn').style.display = 'none';\n                document.getElementById('gameOverlay').classList.remove('hidden');\n            } else {\n                document.getElementById('gameOverlay').classList.add('hidden');\n                document.getElementById('startBtn').style.display = 'block';\n            }\n        }\n    }\n    \n    gameOver() {\n        this.gameRunning = false;\n        document.getElementById('overlayTitle').textContent = 'GAME OVER';\n        document.getElementById('overlayMessage').textContent = `スコア: ${this.score}`;\n        document.getElementById('startBtn').textContent = '🔄 RETRY';\n        document.getElementById('startBtn').style.display = 'block';\n        document.getElementById('gameOverlay').classList.remove('hidden');\n    }\n    \n    setupEventListeners() {\n        // Keyboard controls\n        document.addEventListener('keydown', (e) =\u003e {\n            if (!this.gameRunning || this.gamePaused) return;\n            \n            switch(e.key) {\n                case 'ArrowLeft':\n                    this.movePiece(-1, 0);\n                    break;\n                case 'ArrowRight':\n                    this.movePiece(1, 0);\n                    break;\n                case 'ArrowDown':\n                    this.dropPiece();\n                    this.score += 1;\n                    this.updateDisplay();\n                    break;\n                case 'ArrowUp':\n                    this.rotatePiece();\n                    break;\n                case ' ':\n                    e.preventDefault();\n                    this.hardDrop();\n                    break;\n            }\n        });\n        \n        // Pause\n        document.addEventListener('keydown', (e) =\u003e {\n            if (e.key === 'p' || e.key === 'P') {\n                this.pauseGame();\n            }\n        });\n        \n        // Start button\n        document.getElementById('startBtn').addEventListener('click', () =\u003e {\n            this.startGame();\n        });\n        \n        // Space to start\n        document.addEventListener('keydown', (e) =\u003e {\n            if (e.key === ' ' \u0026\u0026 !this.gameRunning) {\n                e.preventDefault();\n                this.startGame();\n            }\n        });\n        \n        // Window resize\n        window.addEventListener('resize', () =\u003e {\n            const aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n            this.camera.aspect = aspect;\n            this.camera.updateProjectionMatrix();\n            this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\n        });\n    }\n}\n\n// Initialize game\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () =\u003e {\n        new Tetris3D();\n    });\n} else {\n    new Tetris3D();\n}"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-900 text-gray-100\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-7xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"mb-6 flex gap-4\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"ホーム\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-500\",\"children\":\"/\"}],[\"$\",\"$L12\",null,{\"href\":\"/note/webpage-temp\",\"className\":\"text-blue-400 hover:text-blue-300 hover:underline\",\"children\":\"テンプレート一覧\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-500\",\"children\":\"/\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-400\",\"children\":\"3D テトリスゲーム\"}]]}],[\"$\",\"div\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4 mb-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold\",\"children\":\"3D テトリスゲーム\"}],[\"$\",\"span\",null,{\"className\":\"px-3 py-1 bg-blue-600 text-white rounded text-sm\",\"children\":\"3D Graphics\"}]]}],[\"$\",\"p\",null,{\"className\":\"text-gray-300 text-lg mb-4\",\"children\":\"Three.jsで作る立体的なテトリス。クラシックなゲームを3D空間で楽しもう！\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-4\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm\",\"children\":[\"✓ \",\"3D空間でのテトリス\"]}],[\"$\",\"span\",\"1\",{\"className\":\"px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm\",\"children\":[\"✓ \",\"キーボード操作（矢印キー、スペース）\"]}],[\"$\",\"span\",\"2\",{\"className\":\"px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm\",\"children\":[\"✓ \",\"スコアとレベルシステム\"]}],[\"$\",\"span\",\"3\",{\"className\":\"px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm\",\"children\":[\"✓ \",\"次のブロック表示\"]}],[\"$\",\"span\",\"4\",{\"className\":\"px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm\",\"children\":[\"✓ \",\"ゲームオーバー判定\"]}],[\"$\",\"span\",\"5\",{\"className\":\"px-3 py-1 bg-gray-800 text-gray-300 rounded text-sm\",\"children\":[\"✓ \",\"パーティクルエフェクト\"]}]]}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"text-sm text-gray-500\",\"children\":[\"#\",\"three.js\"]}],[\"$\",\"span\",\"1\",{\"className\":\"text-sm text-gray-500\",\"children\":[\"#\",\"3D\"]}],[\"$\",\"span\",\"2\",{\"className\":\"text-sm text-gray-500\",\"children\":[\"#\",\"game\"]}],[\"$\",\"span\",\"3\",{\"className\":\"text-sm text-gray-500\",\"children\":[\"#\",\"tetris\"]}],[\"$\",\"span\",\"4\",{\"className\":\"text-sm text-gray-500\",\"children\":[\"#\",\"interactive\"]}]]}],[\"$\",\"$L13\",null,{\"templateId\":\"three-js-tetris\"}]]}],[\"$\",\"$L14\",null,{\"template\":{\"id\":\"three-js-tetris\",\"title\":\"3D テトリスゲーム\",\"description\":\"Three.jsで作る立体的なテトリス。クラシックなゲームを3D空間で楽しもう！\",\"category\":\"3D Graphics\",\"thumbnail\":\"/templates/three-js-tetris.png\",\"tags\":[\"three.js\",\"3D\",\"game\",\"tetris\",\"interactive\"],\"features\":[\"3D空間でのテトリス\",\"キーボード操作（矢印キー、スペース）\",\"スコアとレベルシステム\",\"次のブロック表示\",\"ゲームオーバー判定\",\"パーティクルエフェクト\"],\"isPro\":true,\"code\":{\"html\":\"$15\",\"css\":\"$16\",\"js\":\"$17\"}}}],[\"$\",\"div\",null,{\"className\":\"mt-12 bg-gray-800 rounded-lg p-6\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-xl font-bold mb-4\",\"children\":\"使用方法\"}],[\"$\",\"ol\",null,{\"className\":\"space-y-3 text-gray-300\",\"children\":[[\"$\",\"li\",null,{\"className\":\"flex gap-3\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-blue-400 font-bold\",\"children\":\"1.\"}],[\"$\",\"span\",null,{\"children\":\"上のタブからHTML、CSS、JavaScriptのコードをそれぞれコピーします。\"}]]}],[\"$\",\"li\",null,{\"className\":\"flex gap-3\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-blue-400 font-bold\",\"children\":\"2.\"}],[\"$\",\"span\",null,{\"children\":\"新しいHTMLファイルを作成し、HTMLコードを貼り付けます。\"}]]}],[\"$\",\"li\",null,{\"className\":\"flex gap-3\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-blue-400 font-bold\",\"children\":\"3.\"}],[\"$\",\"span\",null,{\"children\":\"CSSコードを\u003cstyle\u003eタグ内に貼り付けるか、別ファイルとして保存してリンクします。\"}]]}],[\"$\",\"li\",null,{\"className\":\"flex gap-3\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-blue-400 font-bold\",\"children\":\"4.\"}],[\"$\",\"span\",null,{\"children\":\"JavaScriptコードを\u003cscript\u003eタグ内に貼り付けるか、別ファイルとして保存してリンクします。\"}]]}],[\"$\",\"li\",null,{\"className\":\"flex gap-3\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-blue-400 font-bold\",\"children\":\"5.\"}],[\"$\",\"span\",null,{\"children\":\"必要に応じて、テキストや画像、色などをカスタマイズしてご使用ください。\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mt-6 p-4 bg-blue-900/30 border border-blue-600 rounded\",\"children\":[[\"$\",\"p\",null,{\"className\":\"text-blue-400 mb-2\",\"children\":\"📚 初めての方へ\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-300 text-sm\",\"children\":[\"HTMLやCSSが初めての方は、\",[\"$\",\"$L12\",null,{\"href\":\"/note/webpage-temp/guide\",\"className\":\"text-blue-400 hover:text-blue-300 underline\",\"children\":\"初心者向けWeb制作学習ガイド\"}],\"をご覧ください。実際に手を動かしながら学べる詳しい手順を解説しています。\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 bg-yellow-900/30 border border-yellow-600 rounded-lg p-6\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-yellow-400 font-bold mb-2\",\"children\":\"注意事項\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-gray-300 text-sm\",\"children\":[[\"$\",\"li\",null,{\"children\":\"• このテンプレートは学習・参考用として提供されています。\"}],[\"$\",\"li\",null,{\"children\":\"• 実際のプロジェクトで使用する際は、セキュリティやパフォーマンスの最適化を行ってください。\"}],[\"$\",\"li\",null,{\"children\":\"• 画像やアイコンは実際のものに置き換えてご使用ください。\"}],[\"$\",\"li\",null,{\"children\":\"• レスポンシブ対応していますが、実機でのテストを推奨します。\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 text-center\",\"children\":[\"$\",\"$L12\",null,{\"href\":\"/note/webpage-temp\",\"className\":\"inline-block px-6 py-3 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\",\"children\":\"テンプレート一覧へ戻る\"}]}]]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"11:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Maita Tomoya Dev IO\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"米田智哉の技術ブログ。キャッチアップしたことをメモします。\"}]],\"error\":null,\"digest\":\"$undefined\"}\nb:{\"metadata\":\"$11:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>